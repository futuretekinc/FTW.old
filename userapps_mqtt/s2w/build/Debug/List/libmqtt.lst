###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      19/Nov/2015  15:13:19 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\src\mqtt\libmqtt.c                            #
#    Command line =  E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\src\mqtt\libmqtt.c -D                         #
#                    TX_ENABLE_IAR_LIBRARY_SUPPORT -D IAR -D FIXED_ROM_BUILD  #
#                    -D RUN_ALL_FROM_FLASH -D TM_USE_HTTPD -D S2W_DNS_CLIENT  #
#                    -D NX_INCLUDE_USER_DEFINE_FILE -D S2W_WEB_FS_AVAILABLE   #
#                    -D S2W_EXTFLASH_DRIVER_TEST -D S2W_PWM_SUPPORT -D        #
#                    S2W_MEM_ACCESS -D S2W_FORCE_UART_PORT -D                 #
#                    S2W_EXT_FLASH_FWUP_PUSH_METHOD -D                        #
#                    S2W_NCM_SUPPORT_ENABLE -D S2W_SECURITY_ENTERPRISE_PEAP_V #
#                    0_AVAILABLE -D S2W_EXT_FLASH_FWUP_PULL_METHOD -D         #
#                    S2W_SECURITY_ENTERPRISE_TLS_AVAILABLE -D                 #
#                    S2W_DNS_SERVER_ENABLE -D ADK_OTAFU -D S2W_GSLINK_RAW -D  #
#                    S2W_GSLINK_XML -D S2W_SECURITY_ENTERPRISE_PEAP_V1_AVAILA #
#                    BLE -D S2W_PING_TRACE -D S2W_RF_TEST -D                  #
#                    S2W_SSL_CLIENT_SUPPORT -D S2W_DEFAULT_UART_PARITY=0 -D   #
#                    S2W_DHCP_SERVER_ENABLE -D S2W_SECURITY_WPS_ENABLE -D     #
#                    ADK_PROV_CONFIG_LIMITED_AP -D S2W_WEB_SERVER -D          #
#                    ADK_PROV -D S2W_DEFAULT_UART_SW_FLOW=0 -D                #
#                    S2W_FILE_UPLOAD_API -D S2W_COAP_SUPPORT -D               #
#                    S2W_HTTPD_SSLCERT_UPLOAD -D                              #
#                    S2W_DEFAULT_UART_STOP_BITS=0 -D S2W_FACT_IMAGE_REQ -D    #
#                    S2W_DEFAULT_UART_BAUD=9600 -D S2W_ASYNC_MSG -D           #
#                    S2W_HTTPS_SUPPORT -D S2W_DEFAULT_UART_HW_FLOW=0 -D       #
#                    S2W_SECURITY_ENTERPRISE_FAST_GTC_AVAILABLE -D            #
#                    S2W_WEB_PROV -D S2W_UNASSOC_TXRX_SUPPORT -D S2W_SNTP -D  #
#                    S2W_UART_ENABLE -D S2W_GSLINK_XMLNESTED_PARSER -D        #
#                    S2W_GSLINK -D S2W_SECURITY_ENTERPRISE_TTLS_AVAILABLE -D  #
#                    S2W_ADC_SUPPORT -D S2W_HTTPC_SUPPORT -D                  #
#                    S2W_SECURITY_ENTERPRISE_FAST_MSCHAPV2_AVAILABLE -D       #
#                    S2W_SSL_SERVER_SUPPORT -D ADK_PROV_CONFIG_CLIENT -D      #
#                    S2W_DEFAULT_UART_BITS_PER_CHAR=3 -D S2W_MDNS_ENABLE -lC  #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\Debug\List\ -lA                         #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\Debug\List\ --diag_suppress             #
#                    Pa050,Pe231,Pe177 -o E:\Gainspan\gs2011mxx_SDK_s2w_tls_t #
#                    lslp_5.1.5_GA\userapps_mqtt\s2w\build\Debug\Obj\         #
#                    --debug --endian=little --cpu=Cortex-M3 -e --fpu=None    #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA #
#                    \userapps_mqtt\s2w\build\..\..\..\geps\inc\ -I           #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\core\ -I              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\drivers\ -I           #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\modules\ -I           #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\rtos\ -I              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\netx\ -I              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\netx\netx_bsd_layer\  #
#                    -I E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\user #
#                    apps_mqtt\s2w\build\..\..\..\geps\inc\main\ -I           #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\fs\ -I                #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\fs\hcc\src\ -I        #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\security\src\ -I      #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\security\hw_engine_if #
#                    \ -I E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\us #
#                    erapps_mqtt\s2w\build\..\..\..\geps\inc\security\wpa_if\ #
#                     -I E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\use #
#                    rapps_mqtt\s2w\build\..\..\..\userlib\ncm\inc\ -I        #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\userlib\ -I                    #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\ctx\ -I                          #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\ -I                              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\main\ -I                         #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\hal\ -I                          #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\parser\ -I                       #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\config\ -I                       #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\ -I                              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\adk\otafu\inc\ -I              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\adk\provisioning\inc\ -I       #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\mqtt\ -I                         #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\mqtt\ -I                         #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\one_wire\ -I                     #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\one_wire\ -I                     #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\linked_list\ -I                  #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\linked_list\ -I                  #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\mqtt_main\ -I                    #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\mqtt_main\ -I                    #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\mqtt_log\ -I                     #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\mqtt_log\ -Ohz --use_c++_inline  #
#                    -I "C:\Program Files (x86)\IAR Systems\Embedded          #
#                    Workbench 6.5\arm\CMSIS\Include\"                        #
#    List file    =  E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\Debug\List\libmqtt.lst                  #
#    Object file  =  E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\Debug\Obj\libmqtt.o                     #
#                                                                             #
#                                                                             #
###############################################################################

E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapps_mqtt\s2w\src\mqtt\libmqtt.c
      1           /* 
      2            * This file is part of libemqtt. 
      3            * 
      4            * libemqtt is free software: you can redistribute it and/or modify 
      5            * it under the terms of the GNU Lesser General Public License as published by 
      6            * the Free Software Foundation, either version 3 of the License, or 
      7            * (at your option) any later version. 
      8            * 
      9            * libemqtt is distributed in the hope that it will be 
     10            * but WITHOUT ANY WARRANTY; without even the implied warranty of 
     11            * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
     12            * GNU General Public License for more details. 
     13            * 
     14            * You should have received a copy of the GNU General Public License 
     15            * along with libemqtt.  If not, see <http://www.gnu.org/licenses/>. 
     16            */ 
     17           
     18           
     19           /* 
     20            * 
     21            * Created by Filipe Varela on 09/10/16. 
     22            * Copyright 2009 Caixa Magica Software. All rights reserved. 
     23            * 
     24            * Fork developed by Vicente Ruiz Rodriguez 
     25            * Copyright 2012 Vicente Ruiz Rodriguez <vruiz2.0@gmail.com>. All rights reserved. 
     26            * 
     27            */ 
     28           //#include <mqx.h> 
     29           #include <string.h> 

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp void *memcpy(void *, void const *, size_t)
   \                     memcpy:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x.... 0x....      BL       __aeabi_memcpy
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp void *memset(void *, int, size_t)
   \                     memset:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4610             MOV      R0,R2
   \   00000006   0x460A             MOV      R2,R1
   \   00000008   0x4601             MOV      R1,R0
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       __aeabi_memset
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
     30           #include "mqtt/libmqtt.h" 
     31          #include "mqtt_main/mqtt_main.h"
     32          
     33           
     34           #define MQTT_DUP_FLAG     1<<3 
     35           #define MQTT_QOS0_FLAG    0<<1 
     36           #define MQTT_QOS1_FLAG    1<<1 
     37           #define MQTT_QOS2_FLAG    2<<1 
     38           
     39           
     40           #define MQTT_RETAIN_FLAG  1 
     41           
     42           
     43           #define MQTT_CLEAN_SESSION  1<<1 
     44           #define MQTT_WILL_FLAG      1<<2 
     45           #define MQTT_WILL_RETAIN    1<<5 
     46           #define MQTT_USERNAME_FLAG  1<<7 
     47           #define MQTT_PASSWORD_FLAG  1<<6 
     48           
     49           
     50           
     51           

   \                                 In section .text, align 2, keep-with-next
     52           UINT8 mqtt_num_rem_len_bytes(const UINT8* buf) { 
     53           	UINT8 num_bytes = 1; 
     54           	 
     55           	//printf("mqtt_num_rem_len_bytes\n"); 
     56           	 
     57           	if ((buf[1] & 0x80) == 0x80) { 
   \                     mqtt_num_rem_len_bytes:
   \   00000000   0x7842             LDRB     R2,[R0, #+1]
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x0612             LSLS     R2,R2,#+24
   \   00000006   0xD508             BPL.N    ??mqtt_num_rem_len_bytes_0
     58           		num_bytes++; 
     59           		if ((buf[2] & 0x80) == 0x80) { 
   \   00000008   0x7882             LDRB     R2,[R0, #+2]
   \   0000000A   0x2102             MOVS     R1,#+2
   \   0000000C   0x0612             LSLS     R2,R2,#+24
   \   0000000E   0xD504             BPL.N    ??mqtt_num_rem_len_bytes_0
     60           			num_bytes ++; 
     61           			if ((buf[3] & 0x80) == 0x80) { 
   \   00000010   0x78C0             LDRB     R0,[R0, #+3]
   \   00000012   0x2103             MOVS     R1,#+3
   \   00000014   0x0600             LSLS     R0,R0,#+24
   \   00000016   0xBF48             IT       MI 
   \   00000018   0x2104             MOVMI    R1,#+4
     62           				num_bytes ++; 
     63           			} 
     64           		} 
     65           	} 
     66           	return num_bytes; 
   \                     ??mqtt_num_rem_len_bytes_0:
   \   0000001A   0x4608             MOV      R0,R1
   \   0000001C   0x4770             BX       LR               ;; return
     67           } 
     68           
     69           

   \                                 In section .text, align 2, keep-with-next
     70           UINT16 mqtt_parse_rem_len(const UINT8* buf) { 
   \                     mqtt_parse_rem_len:
   \   00000000   0xB510             PUSH     {R4,LR}
     71           	UINT16 multiplier = 1; 
   \   00000002   0x2201             MOVS     R2,#+1
     72           	UINT16 value = 0; 
   \   00000004   0x2100             MOVS     R1,#+0
     73           	UINT8 digit; 
     74           	 
     75           	//printf("mqtt_parse_rem_len\n"); 
     76           	 
     77           	buf++;	// skip "flags" byte in fixed header 
   \   00000006   0x1C40             ADDS     R0,R0,#+1
     78           
     79           
     80           	do { 
     81           		digit = *buf; 
   \                     ??mqtt_parse_rem_len_0:
   \   00000008   0xF810 0x3B01      LDRB     R3,[R0], #+1
     82           		value += (digit & 127) * multiplier; 
   \   0000000C   0xF003 0x047F      AND      R4,R3,#0x7F
   \   00000010   0xFB02 0x1104      MLA      R1,R2,R4,R1
     83           		multiplier *= 128; 
   \   00000014   0x05D2             LSLS     R2,R2,#+23
   \   00000016   0x0C12             LSRS     R2,R2,#+16
   \   00000018   0xB289             UXTH     R1,R1
     84           		buf++; 
     85           	} while ((digit & 128) != 0); 
   \   0000001A   0x061B             LSLS     R3,R3,#+24
   \   0000001C   0xD4F4             BMI.N    ??mqtt_parse_rem_len_0
     86           
     87           
     88           	return value; 
   \   0000001E   0x4608             MOV      R0,R1
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
     89           } 
     90           
     91           

   \                                 In section .text, align 2, keep-with-next
     92           UINT16 mqtt_parse_msg_id(const UINT8* buf) { 
   \                     mqtt_parse_msg_id:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
     93           	UINT8 type = MQTTParseMessageType(buf); 
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0xF000 0x01F0      AND      R1,R0,#0xF0
     94           	UINT8 qos = MQTTParseMessageQos(buf); 
   \   0000000A   0x0842             LSRS     R2,R0,#+1
     95           	UINT16 id = 0; 
   \   0000000C   0x2000             MOVS     R0,#+0
     96           	 
     97           	//printf("mqtt_parse_msg_id\n"); 
     98           	 
     99           	if(type >= MQTT_MSG_PUBLISH && type <= MQTT_MSG_UNSUBACK) { 
   \   0000000E   0xF1A1 0x0330      SUB      R3,R1,#+48
   \   00000012   0x2B81             CMP      R3,#+129
   \   00000014   0xD218             BCS.N    ??mqtt_parse_msg_id_0
    100           		if(type == MQTT_MSG_PUBLISH) { 
   \   00000016   0x2930             CMP      R1,#+48
   \   00000018   0xD10E             BNE.N    ??mqtt_parse_msg_id_1
    101           			if(qos != 0) { 
   \   0000001A   0x2103             MOVS     R1,#+3
   \   0000001C   0x420A             TST      R2,R1
   \   0000001E   0xD013             BEQ.N    ??mqtt_parse_msg_id_0
    102           				// fixed header length + Topic (UTF encoded) 
    103           				// = 1 for "flags" byte + rlb for length bytes + topic size 
    104           				UINT8 rlb = mqtt_num_rem_len_bytes(buf); 
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       mqtt_num_rem_len_bytes
    105           				UINT8 offset = *(buf+1+rlb)<<8;	// topic UTF MSB 
    106           				offset |= *(buf+1+rlb+1);			// topic UTF LSB 
    107           				offset += (1+rlb+2);					// fixed header + topic size 
   \   00000026   0x1901             ADDS     R1,R0,R4
   \   00000028   0x7889             LDRB     R1,[R1, #+2]
   \   0000002A   0x1840             ADDS     R0,R0,R1
   \   0000002C   0x1CC0             ADDS     R0,R0,#+3
   \   0000002E   0xB2C0             UXTB     R0,R0
    108           				id = *(buf+offset)<<8;				// id MSB 
    109           				id |= *(buf+offset+1);				// id LSB 
   \   00000030   0x5D01             LDRB     R1,[R0, R4]
   \   00000032   0x1900             ADDS     R0,R0,R4
   \   00000034   0x7840             LDRB     R0,[R0, #+1]
   \   00000036   0xE005             B.N      ??mqtt_parse_msg_id_2
    110           			} 
    111           		} else { 
    112           			// fixed header length 
    113           			// 1 for "flags" byte + rlb for length bytes 
    114           			UINT8 rlb = mqtt_num_rem_len_bytes(buf); 
   \                     ??mqtt_parse_msg_id_1:
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       mqtt_num_rem_len_bytes
    115           			id = *(buf+1+rlb)<<8;	// id MSB 
    116           			id |= *(buf+1+rlb+1);	// id LSB 
   \   0000003E   0x1900             ADDS     R0,R0,R4
   \   00000040   0x7841             LDRB     R1,[R0, #+1]
   \   00000042   0x7880             LDRB     R0,[R0, #+2]
   \                     ??mqtt_parse_msg_id_2:
   \   00000044   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
    117           		} 
    118           	} 
    119           	return id; 
   \                     ??mqtt_parse_msg_id_0:
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
    120           } 
    121           
    122           

   \                                 In section .text, align 2, keep-with-next
    123           UINT16 mqtt_parse_pub_topic(const UINT8* buf, UINT8* topic) { 
   \                     mqtt_parse_pub_topic:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    124           	const UINT8* ptr; 
    125           	UINT16 topic_len = mqtt_parse_pub_topic_ptr(buf, &ptr); 
   \   00000004   0xA900             ADD      R1,SP,#+0
   \   00000006   0x.... 0x....      BL       mqtt_parse_pub_topic_ptr
   \   0000000A   0x0005             MOVS     R5,R0
    126           	 
    127           	//printf("mqtt_parse_pub_topic\n"); 
    128           	 
    129           	if(topic_len != 0 && ptr != NULL) { 
   \   0000000C   0xBF1C             ITT      NE 
   \   0000000E   0x9800             LDRNE    R0,[SP, #+0]
   \   00000010   0x2800             CMPNE    R0,#+0
   \   00000012   0x....             B.N      ?Subroutine0
    130           		memcpy(topic, ptr, topic_len); 
    131           	} 
    132           	 
    133           	return topic_len; 
    134           }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0xD004             BEQ.N    ??Subroutine0_0
   \   00000002   0x4601             MOV      R1,R0
   \   00000004   0x462A             MOV      R2,R5
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       memcpy
   \                     ??Subroutine0_0:
   \   0000000C   0x4628             MOV      R0,R5
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    135           
    136           

   \                                 In section .text, align 2, keep-with-next
    137           UINT16 mqtt_parse_pub_topic_ptr(const UINT8* buf, const UINT8 **topic_ptr) { 
   \                     mqtt_parse_pub_topic_ptr:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
    138           	UINT16 len = 0; 
    139           	 
    140           	//printf("mqtt_parse_pub_topic_ptr\n"); 
    141           
    142           
    143           	if(MQTTParseMessageType(buf) == MQTT_MSG_PUBLISH) { 
   \   00000006   0x7829             LDRB     R1,[R5, #+0]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF001 0x01F0      AND      R1,R1,#0xF0
   \   0000000E   0x2930             CMP      R1,#+48
   \   00000010   0xD10B             BNE.N    ??mqtt_parse_pub_topic_ptr_0
    144           		// fixed header length = 1 for "flags" byte + rlb for length bytes 
    145           		UINT8 rlb = mqtt_num_rem_len_bytes(buf); 
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       mqtt_num_rem_len_bytes
    146           		len = *(buf+1+rlb)<<8;	// MSB of topic UTF 
    147           		len |= *(buf+1+rlb+1);	// LSB of topic UTF 
   \   00000018   0x1941             ADDS     R1,R0,R5
   \   0000001A   0x7848             LDRB     R0,[R1, #+1]
   \   0000001C   0x788A             LDRB     R2,[R1, #+2]
    148           		// start of topic = add 1 for "flags", rlb for remaining length, 2 for UTF 
    149           		*topic_ptr = (buf + (1+rlb+2)); 
   \   0000001E   0xF201 0x0103      ADDW     R1,R1,#+3
   \   00000022   0xEA42 0x2000      ORR      R0,R2,R0, LSL #+8
   \   00000026   0x6021             STR      R1,[R4, #+0]
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}
    150           	} else { 
    151           		*topic_ptr = NULL; 
   \                     ??mqtt_parse_pub_topic_ptr_0:
   \   0000002A   0x6020             STR      R0,[R4, #+0]
    152           	} 
    153           	return len; 
   \   0000002C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    154           } 
    155           
    156           

   \                                 In section .text, align 2, keep-with-next
    157           UINT16 mqtt_parse_publish_msg(const UINT8* buf, UINT8* msg) { 
   \                     mqtt_parse_publish_msg:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    158           	const UINT8* ptr; 
    159           	 
    160           	//printf("mqtt_parse_publish_msg\n"); 
    161           	 
    162           	UINT16 msg_len = mqtt_parse_pub_msg_ptr(buf, &ptr); 
   \   00000004   0xA900             ADD      R1,SP,#+0
   \   00000006   0x.... 0x....      BL       mqtt_parse_pub_msg_ptr
   \   0000000A   0x0005             MOVS     R5,R0
    163           	 
    164           	if(msg_len != 0 && ptr != NULL) { 
   \   0000000C   0xBF1C             ITT      NE 
   \   0000000E   0x9800             LDRNE    R0,[SP, #+0]
   \   00000010   0x2800             CMPNE    R0,#+0
   \   00000012                      REQUIRE ?Subroutine0
   \   00000012                      ;; // Fall through to label ?Subroutine0
    165           		memcpy(msg, ptr, msg_len); 
    166           	} 
    167           	 
    168           	return msg_len; 
    169           } 
    170           
    171           

   \                                 In section .text, align 2, keep-with-next
    172           UINT16 mqtt_parse_pub_msg_ptr(const UINT8* buf, const UINT8 **msg_ptr) { 
   \                     mqtt_parse_pub_msg_ptr:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    173           	UINT16 len = 0; 
    174           	 
    175           	//printf("mqtt_parse_pub_msg_ptr\n"); 
    176           	 
    177           	if(MQTTParseMessageType(buf) == MQTT_MSG_PUBLISH) { 
   \   00000006   0x7821             LDRB     R1,[R4, #+0]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF001 0x01F0      AND      R1,R1,#0xF0
   \   0000000E   0x2930             CMP      R1,#+48
   \   00000010   0xD117             BNE.N    ??mqtt_parse_pub_msg_ptr_0
    178           		// message starts at 
    179           		// fixed header length + Topic (UTF encoded) + msg id (if QoS>0) 
    180           		UINT8 rlb = mqtt_num_rem_len_bytes(buf); 
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       mqtt_num_rem_len_bytes
   \   00000018   0x4606             MOV      R6,R0
    181           		UINT8 offset = (*(buf+1+rlb))<<8;	// topic UTF MSB 
    182           		offset |= *(buf+1+rlb+1);			// topic UTF LSB 
    183           		offset += (1+rlb+2);				// fixed header + topic size 
   \   0000001A   0x1930             ADDS     R0,R6,R4
   \   0000001C   0x7880             LDRB     R0,[R0, #+2]
   \   0000001E   0x1830             ADDS     R0,R6,R0
   \   00000020   0x1CC7             ADDS     R7,R0,#+3
    184           
    185           
    186           		if(MQTTParseMessageQos(buf)) { 
   \   00000022   0x7820             LDRB     R0,[R4, #+0]
   \   00000024   0xB2FF             UXTB     R7,R7
   \   00000026   0xF3C0 0x0041      UBFX     R0,R0,#+1,#+2
   \   0000002A   0xB108             CBZ.N    R0,??mqtt_parse_pub_msg_ptr_1
    187           			offset += 2;					// add two bytes of msg id 
   \   0000002C   0x1CBF             ADDS     R7,R7,#+2
   \   0000002E   0xB2FF             UXTB     R7,R7
    188           		} 
    189           
    190           
    191           		*msg_ptr = (buf + offset); 
   \                     ??mqtt_parse_pub_msg_ptr_1:
   \   00000030   0x1938             ADDS     R0,R7,R4
   \   00000032   0x6028             STR      R0,[R5, #+0]
    192           				 
    193           		// offset is now pointing to start of message 
    194           		// length of the message is remaining length - variable header 
    195           		// variable header is offset - fixed header 
    196           		// fixed header is 1 + rlb 
    197           		// so, lom = remlen - (offset - (1+rlb)) 
    198                 	len = mqtt_parse_rem_len(buf) - (offset-(rlb+1)); 
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       mqtt_parse_rem_len
   \   0000003A   0x1BC0             SUBS     R0,R0,R7
   \   0000003C   0x1830             ADDS     R0,R6,R0
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \   00000040   0xE000             B.N      ??mqtt_parse_pub_msg_ptr_2
    199           	} else { 
    200           		*msg_ptr = NULL; 
   \                     ??mqtt_parse_pub_msg_ptr_0:
   \   00000042   0x6028             STR      R0,[R5, #+0]
    201           	} 
    202           	return len; 
   \                     ??mqtt_parse_pub_msg_ptr_2:
   \   00000044   0xB280             UXTH     R0,R0
   \   00000046   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    203           } 
    204           
    205           

   \                                 In section .text, align 2, keep-with-next
    206           void mqtt_init(mqtt_broker_handle_t* broker, const char* clientid) { 
   \                     mqtt_init:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    207           	// Connection options 
    208           	broker->alive = 300; // 300 seconds = 5 minutes 
   \   00000004   0xF104 0x0640      ADD      R6,R4,#+64
   \   00000008   0xF44F 0x7096      MOV      R0,#+300
   \   0000000C   0x8270             STRH     R0,[R6, #+18]
   \   0000000E   0x460D             MOV      R5,R1
    209           	broker->seq = 1; // Sequency for message indetifiers 
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x8230             STRH     R0,[R6, #+16]
    210           	// Client options 
    211           	//memset(broker->clientid, 0, sizeof(broker->clientid)); 
    212           	//memset(broker->username, 0, sizeof(broker->username)); 
    213           	//memset(broker->password, 0, sizeof(broker->password)); 
    214           	if(clientid) { 
   \   00000014   0xB145             CBZ.N    R5,??mqtt_init_0
    215           		//strncpy(broker->clientid, clientid, sizeof(broker->clientid));
    216          	    memcpy(broker->clientid,clientid,strlen(clientid));
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       strlen
   \   0000001C   0x4602             MOV      R2,R0
   \   0000001E   0x6C20             LDR      R0,[R4, #+64]
   \   00000020   0x4629             MOV      R1,R5
   \   00000022   0x.... 0x....      BL       memcpy
   \   00000026   0xE005             B.N      ??mqtt_init_1
    217           	} else { 
    218           		strcpy(broker->clientid, "emqtt"); 
   \                     ??mqtt_init_0:
   \   00000028   0x6C20             LDR      R0,[R4, #+64]
   \   0000002A   0x.... 0x....      ADR.W    R1,`?<Constant "emqtt">`
   \   0000002E   0x2206             MOVS     R2,#+6
   \   00000030   0x.... 0x....      BL       __aeabi_memcpy
    219           	} 
    220           	// Will topic 
    221           	broker->clean_session = 1; 
   \                     ??mqtt_init_1:
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x73B0             STRB     R0,[R6, #+14]
    222           } 
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
    223           
    224           

   \                                 In section .text, align 2, keep-with-next
    225           void mqtt_init_auth(mqtt_broker_handle_t* broker, const char* username, const char* password) { 
   \                     mqtt_init_auth:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x4616             MOV      R6,R2
    226           	if(username && username[0] != '\0') 
   \   00000008   0xBF1C             ITT      NE 
   \   0000000A   0x7828             LDRBNE   R0,[R5, #+0]
   \   0000000C   0x2800             CMPNE    R0,#+0
   \   0000000E   0xD007             BEQ.N    ??mqtt_init_auth_0
    227           		//strncpy(broker->username, username, sizeof(broker->username)-1); 
    228          	    memcpy(broker->username,username,strlen(username));
   \   00000010   0x4628             MOV      R0,R5
   \   00000012   0x.... 0x....      BL       strlen
   \   00000016   0x4602             MOV      R2,R0
   \   00000018   0x6C60             LDR      R0,[R4, #+68]
   \   0000001A   0x4629             MOV      R1,R5
   \   0000001C   0x.... 0x....      BL       memcpy
    229           	if(password && password[0] != '\0') 
   \                     ??mqtt_init_auth_0:
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xBF1C             ITT      NE 
   \   00000024   0x7830             LDRBNE   R0,[R6, #+0]
   \   00000026   0x2800             CMPNE    R0,#+0
   \   00000028   0xD009             BEQ.N    ??mqtt_init_auth_1
    230           		//strncpy(broker->password, password, sizeof(broker->password)-1);
    231          	    memcpy(broker->password,password,strlen(password));
   \   0000002A   0x4630             MOV      R0,R6
   \   0000002C   0x.... 0x....      BL       strlen
   \   00000030   0x4602             MOV      R2,R0
   \   00000032   0x6CA0             LDR      R0,[R4, #+72]
   \   00000034   0x4631             MOV      R1,R6
   \   00000036   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000003A   0x.... 0x....      B.W      memcpy
    232           } 
   \                     ??mqtt_init_auth_1:
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return
    233           
    234           

   \                                 In section .text, align 2, keep-with-next
    235           void mqtt_set_alive(mqtt_broker_handle_t* broker, UINT16 alive) { 
    236           	broker->alive = alive; 
   \                     mqtt_set_alive:
   \   00000000   0xF8A0 0x1052      STRH     R1,[R0, #+82]
    237           } 
   \   00000004   0x4770             BX       LR               ;; return
    238           
    239           

   \                                 In section .text, align 2, keep-with-next
    240           UINT8 mqtt_connect(mqtt_broker_handle_t* broker) 
    241           { 
   \                     mqtt_connect:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
    242               UINT8 fixedHeaderSize = 0; 
    243               UINT8 fixed_header[3]; 
    244               UINT8 remainLen = 0; 
    245           	 UINT8 flags = 0x00; 
    246               UINT8 var_header[12] =  
    247               { 
    248                   0x00,0x06,0x4d,0x51,0x49,0x73,0x64,0x70, // Protocol name: MQIsdp 
    249           		0x03, // Protocol version 
    250                   0x00, // Connect flags 
    251                   0x00, // Keep alive LSB 
    252                   0x00  // Keep alive MSB 
    253               }; 
   \   00000006   0x.... 0x....      ADR.W    R1,`?<Constant {0, 6, 77, 81, 73, 115, 100, 112, 3`
   \   0000000A   0xC92C             LDM      R1!,{R2,R3,R5}
   \   0000000C   0x4604             MOV      R4,R0
   \   0000000E   0xA802             ADD      R0,SP,#+8
   \   00000010   0xF04F 0x0900      MOV      R9,#+0
   \   00000014   0xC02C             STM      R0!,{R2,R3,R5}
    254                
    255           	UINT16 offset = 0; 
    256               UINT16 packetSize = 0; 
    257           	UINT8 *packet = NULL; 
    258           	UINT16 clientidlen = strlen(broker->clientid); 
   \   00000016   0xF104 0x053C      ADD      R5,R4,#+60
   \   0000001A   0x6868             LDR      R0,[R5, #+4]
   \   0000001C   0x.... 0x....      BL       strlen
   \   00000020   0xB286             UXTH     R6,R0
    259           	UINT16 usernamelen = strlen(broker->username); 
   \   00000022   0x68A8             LDR      R0,[R5, #+8]
   \   00000024   0x.... 0x....      BL       strlen
   \   00000028   0xB287             UXTH     R7,R0
    260           	UINT16 passwordlen = strlen(broker->password); 
   \   0000002A   0x68E8             LDR      R0,[R5, #+12]
   \   0000002C   0x.... 0x....      BL       strlen
   \   00000030   0xFA1F 0xF880      UXTH     R8,R0
    261           	UINT16 payload_len = clientidlen + 2; 
   \   00000034   0x1CB0             ADDS     R0,R6,#+2
   \   00000036   0xB280             UXTH     R0,R0
    262           
    263          
    264           	// Preparing the flags 
    265           	if(usernamelen)  
   \   00000038   0xB127             CBZ.N    R7,??mqtt_connect_0
    266               { 
    267           		payload_len += usernamelen + 2; 
   \   0000003A   0x1838             ADDS     R0,R7,R0
   \   0000003C   0x1C80             ADDS     R0,R0,#+2
   \   0000003E   0xB280             UXTH     R0,R0
    268           		flags |= MQTT_USERNAME_FLAG; 
   \   00000040   0xF04F 0x0980      MOV      R9,#+128
    269           	} 
    270                
    271           	if(passwordlen)  
   \                     ??mqtt_connect_0:
   \   00000044   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000048   0xD004             BEQ.N    ??mqtt_connect_1
    272               { 
    273           		payload_len += passwordlen + 2; 
   \   0000004A   0x4440             ADD      R0,R8,R0
   \   0000004C   0x1C80             ADDS     R0,R0,#+2
   \   0000004E   0xB280             UXTH     R0,R0
    274           		flags |= MQTT_PASSWORD_FLAG; 
   \   00000050   0xF049 0x0940      ORR      R9,R9,#0x40
    275           	} 
    276                
    277           	if(broker->clean_session)  
   \                     ??mqtt_connect_1:
   \   00000054   0x7CA9             LDRB     R1,[R5, #+18]
   \   00000056   0xB109             CBZ.N    R1,??mqtt_connect_2
    278               { 
    279           		flags |= MQTT_CLEAN_SESSION; 
   \   00000058   0xF049 0x0902      ORR      R9,R9,#0x2
    280           	} 
    281           
    282          
    283           	// Variable header 
    284           	var_header[9] = flags; // Connect flags 
   \                     ??mqtt_connect_2:
   \   0000005C   0xF88D 0x9011      STRB     R9,[SP, #+17]
    285               var_header[10] = broker->alive>>8;   // Keep alive LSB 
    286               var_header[11] = broker->alive&0xFF; // Keep alive MSB 
    287           
    288          
    289           
    290          
    291              	// Fixed header 
    292               fixedHeaderSize = 2;    // Default size = one byte Message Type + one byte Remaining Length 
   \   00000060   0xF04F 0x0B02      MOV      R11,#+2
   \   00000064   0x8AE9             LDRH     R1,[R5, #+22]
   \   00000066   0x0A09             LSRS     R1,R1,#+8
   \   00000068   0xF88D 0x1012      STRB     R1,[SP, #+18]
    293               // Message Type 
    294               fixed_header[0] = MQTT_MSG_CONNECT; 
    295               // Remaining Length 
    296               remainLen = sizeof(var_header)+payload_len; 
    297               if (remainLen <= 127)  
   \   0000006C   0xAA01             ADD      R2,SP,#+4
   \   0000006E   0x8AE9             LDRH     R1,[R5, #+22]
   \   00000070   0xF88D 0x1013      STRB     R1,[SP, #+19]
   \   00000074   0x2110             MOVS     R1,#+16
   \   00000076   0xF88D 0x1004      STRB     R1,[SP, #+4]
   \   0000007A   0xF100 0x010C      ADD      R1,R0,#+12
   \   0000007E   0xB2C9             UXTB     R1,R1
   \   00000080   0x2980             CMP      R1,#+128
   \   00000082   0xBFB8             IT       LT 
   \   00000084   0x7051             STRBLT   R1,[R2, #+1]
    298               { 
    299                   fixed_header[1] = remainLen; 
   \   00000086   0xDB06             BLT.N    ??mqtt_connect_3
    300               } 
    301               else 
    302               { 
    303                   fixedHeaderSize++;          // add an additional byte for Remaining Length 
    304                   // first byte is remainder (mod) of 128, then set the MSB to indicate more bytes 
    305                   fixed_header[1] = remainLen % 128; 
    306                   fixed_header[1] = fixed_header[1] | 0x80; 
   \   00000088   0xF041 0x0380      ORR      R3,R1,#0x80
    307                   // second byte is number of 128s 
    308                   fixed_header[2] = remainLen / 128; 
   \   0000008C   0x09C9             LSRS     R1,R1,#+7
   \   0000008E   0xF04F 0x0B03      MOV      R11,#+3
   \   00000092   0x7053             STRB     R3,[R2, #+1]
   \   00000094   0x7091             STRB     R1,[R2, #+2]
   \                     ??mqtt_connect_3:
   \   00000096   0x4458             ADD      R0,R0,R11
   \   00000098   0x300C             ADDS     R0,R0,#+12
   \   0000009A   0xFA1F 0xF980      UXTH     R9,R0
    309               } 
    310                
    311           
    312          
    313               offset = 0; 
    314               packetSize = fixedHeaderSize+sizeof(var_header)+payload_len; 
    315          
    316          	 packet = (UINT8 *)gsn_malloc(packetSize);
   \   0000009E   0x2200             MOVS     R2,#+0
   \   000000A0   0xF44F 0x719E      MOV      R1,#+316
   \   000000A4   0x4648             MOV      R0,R9
   \   000000A6   0x.... 0x....      BL       GsnDynMemMgmt_Alloc
   \   000000AA   0xEA5F 0x0A00      MOVS     R10,R0
    317               if (packet == NULL) 
   \   000000AE   0xD10F             BNE.N    ??mqtt_connect_4
    318               {
    319          	     S2w_Printf("\r\n CONNECT PACKET is NULL");
   \   000000B0   0x.... 0x....      ADR.W    R0,`?<Constant "\\r\\n CONNECT PACKET is ...">`
   \   000000B4   0x.... 0x....      BL       S2w_Printf
    320                   goto error; 
    321               }
    322          	 memset(packet, 0, packetSize);
    323           	memcpy(packet, fixed_header, fixedHeaderSize); 
    324           	offset += fixedHeaderSize; 
    325           	memcpy(packet+offset, var_header, sizeof(var_header)); 
    326           	offset += sizeof(var_header); 
    327           	// Client ID - UTF encoded 
    328           	packet[offset++] = clientidlen>>8; 
    329           	packet[offset++] = clientidlen&0xFF; 
    330           	memcpy(packet+offset, broker->clientid, clientidlen); 
    331           	offset += clientidlen; 
    332           
    333          
    334           	if(usernamelen) { 
    335           		// Username - UTF encoded 
    336           		packet[offset++] = usernamelen>>8; 
    337           		packet[offset++] = usernamelen&0xFF; 
    338           		memcpy(packet+offset, broker->username, usernamelen); 
    339           		offset += usernamelen; 
    340           	} 
    341           
    342          
    343           	if(passwordlen) { 
    344           		// Password - UTF encoded 
    345           		packet[offset++] = passwordlen>>8; 
    346           		packet[offset++] = passwordlen&0xFF; 
    347           		memcpy(packet+offset, broker->password, passwordlen); 
    348           		offset += passwordlen; 
    349           	} 
    350           
    351          
    352           	// Send the packet 
    353          	
    354            	if( AppS2wHal_NetTx(broker->mqtt_cid, broker->mqtt_peerData.ipAddr, broker->mqtt_peerData.port, packet, packetSize) != 0 )
    355                  {
    356                    goto error; 
    357           	} 
    358          	if (packet != NULL) 
    359               { 
    360          	   gsn_free(packet);
    361          	   packet=NULL;
    362               } 
    363           	return 0; 
    364           error: 
    365               S2w_Printf("\r\n connect Error");
   \                     ??mqtt_connect_5:
   \   000000B8   0x.... 0x....      ADR.W    R0,`?<Constant "\\r\\n connect Error">`
   \   000000BC   0x.... 0x....      BL       S2w_Printf
    366               if (packet != NULL) 
   \   000000C0   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000C4   0xBF1C             ITT      NE 
   \   000000C6   0x4650             MOVNE    R0,R10
   \   000000C8   0x.... 0x....      BLNE     GsnDynMemMgmt_Free
    367               { 
    368          	   gsn_free(packet);
    369          	   packet=NULL;
    370               } 
    371          
    372               return  1; 
   \   000000CC   0x2001             MOVS     R0,#+1
   \                     ??mqtt_connect_6:
   \   000000CE   0x....             B.N      ?Subroutine3
   \                     ??mqtt_connect_4:
   \   000000D0   0x464A             MOV      R2,R9
   \   000000D2   0x.... 0x....      BL       ??Subroutine8_1
   \                     ??CrossCallReturnLabel_12:
   \   000000D6   0x465A             MOV      R2,R11
   \   000000D8   0xA901             ADD      R1,SP,#+4
   \   000000DA   0x4650             MOV      R0,R10
   \   000000DC   0x.... 0x....      BL       memcpy
   \   000000E0   0x220C             MOVS     R2,#+12
   \   000000E2   0xA902             ADD      R1,SP,#+8
   \   000000E4   0xEB0B 0x000A      ADD      R0,R11,R10
   \   000000E8   0x.... 0x....      BL       memcpy
   \   000000EC   0xF10B 0x000C      ADD      R0,R11,#+12
   \   000000F0   0xB280             UXTH     R0,R0
   \   000000F2   0x0A31             LSRS     R1,R6,#+8
   \   000000F4   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_21:
   \   000000F8   0x4632             MOV      R2,R6
   \   000000FA   0xF800 0x600A      STRB     R6,[R0, R10]
   \   000000FE   0x1C40             ADDS     R0,R0,#+1
   \   00000100   0x6869             LDR      R1,[R5, #+4]
   \   00000102   0xFA1F 0xFB80      UXTH     R11,R0
   \   00000106   0xEB0B 0x000A      ADD      R0,R11,R10
   \   0000010A   0x.... 0x....      BL       memcpy
   \   0000010E   0xEB06 0x000B      ADD      R0,R6,R11
   \   00000112   0xB177             CBZ.N    R7,??mqtt_connect_7
   \   00000114   0xB280             UXTH     R0,R0
   \   00000116   0x0A39             LSRS     R1,R7,#+8
   \   00000118   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_22:
   \   0000011C   0x1C46             ADDS     R6,R0,#+1
   \   0000011E   0xF800 0x700A      STRB     R7,[R0, R10]
   \   00000122   0xB2B6             UXTH     R6,R6
   \   00000124   0x68A9             LDR      R1,[R5, #+8]
   \   00000126   0x463A             MOV      R2,R7
   \   00000128   0xEB06 0x000A      ADD      R0,R6,R10
   \   0000012C   0x.... 0x....      BL       memcpy
   \   00000130   0x19B8             ADDS     R0,R7,R6
   \                     ??mqtt_connect_7:
   \   00000132   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000136   0xD00D             BEQ.N    ??mqtt_connect_8
   \   00000138   0xB280             UXTH     R0,R0
   \   0000013A   0xEA4F 0x2118      LSR      R1,R8,#+8
   \   0000013E   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_23:
   \   00000142   0x4642             MOV      R2,R8
   \   00000144   0xF800 0x800A      STRB     R8,[R0, R10]
   \   00000148   0x1C40             ADDS     R0,R0,#+1
   \   0000014A   0x68E9             LDR      R1,[R5, #+12]
   \   0000014C   0xB280             UXTH     R0,R0
   \   0000014E   0x4450             ADD      R0,R0,R10
   \   00000150   0x.... 0x....      BL       memcpy
   \                     ??mqtt_connect_8:
   \   00000154   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   00000158   0x8862             LDRH     R2,[R4, #+2]
   \   0000015A   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \   0000015E   0x4653             MOV      R3,R10
   \   00000160   0x1D21             ADDS     R1,R4,#+4
   \   00000162   0x.... 0x....      BL       AppS2wHal_NetTx
   \   00000166   0x2800             CMP      R0,#+0
   \   00000168   0xD1A6             BNE.N    ??mqtt_connect_5
   \   0000016A   0x4650             MOV      R0,R10
   \   0000016C   0x.... 0x....      BL       GsnDynMemMgmt_Free
   \   00000170   0x2000             MOVS     R0,#+0
   \   00000172   0xE7AC             B.N      ??mqtt_connect_6
    373           } 

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11:
   \   00000000   0xF800 0x100A      STRB     R1,[R0, R10]
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   \   00000006   0xB280             UXTH     R0,R0
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   0xB005             ADD      SP,SP,#+20
   \   00000002   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8:
   \   00000000   0x4605             MOV      R5,R0
   \                     ??Subroutine8_0:
   \   00000002   0x4622             MOV      R2,R4
   \                     ??Subroutine8_1:
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x.... 0x....      B.W      memset
    374           
    375          

   \                                 In section .text, align 2, keep-with-next
    376           int mqtt_disconnect(mqtt_broker_handle_t* broker)  
    377           { 
   \                     mqtt_disconnect:
   \   00000000   0xB500             PUSH     {LR}
    378           	UINT8 packet[] =  
    379               { 
    380           		MQTT_MSG_DISCONNECT, // Message Type, DUP flag, QoS level, Retain 
    381           		0x00 // Remaining length 
    382           	}; 
   \   00000002   0x.... 0x....      ADR.W    R1,`?<Constant {224, 0}>`
   \   00000006   0x8809             LDRH     R1,[R1, #+0]
   \   00000008   0xB083             SUB      SP,SP,#+12
    383           
    384          
    385           	// Send the packet 
    386          	
    387               if( AppS2wHal_NetTx(broker->mqtt_cid, broker->mqtt_peerData.ipAddr, broker->mqtt_peerData.port, packet, sizeof(packet) != 0 ))
   \   0000000A   0xAB01             ADD      R3,SP,#+4
   \   0000000C   0xF8AD 0x1004      STRH     R1,[SP, #+4]
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_26:
   \   00000016   0xB100             CBZ.N    R0,??mqtt_disconnect_0
    388               { 
    389           		return 1; 
   \   00000018   0x2001             MOVS     R0,#+1
    390           	 } 
    391           	//broker->send(broker->socket_info,packet,sizeof(packet));
    392          
    393           	return 0; 
   \                     ??mqtt_disconnect_0:
   \   0000001A   0xBD0E             POP      {R1-R3,PC}       ;; return
    394           } 

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12:
   \   00000000   0x9100             STR      R1,[SP, #+0]
   \   00000002   0x1D01             ADDS     R1,R0,#+4
   \   00000004   0x8842             LDRH     R2,[R0, #+2]
   \   00000006   0xF890 0x003C      LDRB     R0,[R0, #+60]
   \   0000000A   0x.... 0x....      B.W      AppS2wHal_NetTx
    395           
    396          

   \                                 In section .text, align 2, keep-with-next
    397           int mqtt_ping(mqtt_broker_handle_t* broker)  
    398           { 
   \                     mqtt_ping:
   \   00000000   0xB500             PUSH     {LR}
    399           	UINT8 packet[] =  
    400               { 
    401           		MQTT_MSG_PINGREQ, // Message Type, DUP flag, QoS level, Retain 
    402           		0x00 // Remaining length 
    403           	}; 
   \   00000002   0x.... 0x....      ADR.W    R1,`?<Constant {192, 0}>`
   \   00000006   0x8809             LDRH     R1,[R1, #+0]
   \   00000008   0xB083             SUB      SP,SP,#+12
    404           
    405          
    406           	// Send the packet 
    407           	/*if(broker->send(broker->socket_info, packet, sizeof(packet)) < sizeof(packet))  
    408               { 
    409           		return -1; 
    410           	} */
    411           	if( AppS2wHal_NetTx(broker->mqtt_cid, broker->mqtt_peerData.ipAddr, broker->mqtt_peerData.port, packet, sizeof(packet)) != 0 )
   \   0000000A   0xAB01             ADD      R3,SP,#+4
   \   0000000C   0xF8AD 0x1004      STRH     R1,[SP, #+4]
   \   00000010   0x2102             MOVS     R1,#+2
   \   00000012   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_25:
   \   00000016   0xB108             CBZ.N    R0,??mqtt_ping_0
    412              {
    413                    return -1; 
   \   00000018   0xF04F 0x30FF      MOV      R0,#-1
    414           	}
    415          
    416           	return 0; 
   \                     ??mqtt_ping_0:
   \   0000001C   0xBD0E             POP      {R1-R3,PC}       ;; return
    417           } 
    418           
    419          
    420           /*int mqtt_publish(mqtt_broker_handle_t* broker, const char* topic, const char* msg, UINT8 retain)  
    421           { 
    422           	return mqtt_publish_with_qos(broker, topic, msg, retain, 0, NULL); 
    423           } */
    424           
    425          

   \                                 In section .text, align 2, keep-with-next
    426           UINT8 mqtt_publish_with_qos(mqtt_broker_handle_t* broker, const char* topic, const char* msg, UINT8 retain, UINT8 qos, UINT16* message_id)  
    427           { 
   \                     mqtt_publish_with_qos:
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x461C             MOV      R4,R3
    428           	UINT8 fixedHeaderSize = 0; 
    429           	UINT16 remainLen = 0; 
    430              UINT16 packetLen = 0; 
    431           	UINT8 *packet = NULL; 
   \   00000008   0xF04F 0x0800      MOV      R8,#+0
    432           	UINT16 topiclen = strlen(topic); 
   \   0000000C   0x4608             MOV      R0,R1
   \   0000000E   0x.... 0x....      BL       strlen
   \   00000012   0xB286             UXTH     R6,R0
    433           	UINT16 msglen = strlen(msg); 
   \   00000014   0x9804             LDR      R0,[SP, #+16]
   \   00000016   0x.... 0x....      BL       strlen
   \   0000001A   0x4683             MOV      R11,R0
    434              UINT16 var_header_len = 0;  
    435           	UINT8 *var_header = NULL; 
    436           	UINT8 fixed_header[3]; 
    437          
    438          
    439           	UINT8 qos_flag = MQTT_QOS0_FLAG; 
    440           	UINT8 qos_size = 0; // No QoS included 
   \   0000001C   0x980E             LDR      R0,[SP, #+56]
   \   0000001E   0x2500             MOVS     R5,#+0
   \   00000020   0x46C1             MOV      R9,R8
    441                
    442           	if(qos == 1)  
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD102             BNE.N    ??mqtt_publish_with_qos_0
    443               { 
    444           		qos_size = 2; // 2 bytes for QoS 
   \   00000026   0x2502             MOVS     R5,#+2
    445           		qos_flag = MQTT_QOS1_FLAG; 
   \   00000028   0x46A9             MOV      R9,R5
   \   0000002A   0xE004             B.N      ??mqtt_publish_with_qos_1
    446           	} 
    447           	else if(qos == 2)  
   \                     ??mqtt_publish_with_qos_0:
   \   0000002C   0x2802             CMP      R0,#+2
   \   0000002E   0xBF04             ITT      EQ 
   \   00000030   0x2502             MOVEQ    R5,#+2
   \   00000032   0xF04F 0x0904      MOVEQ    R9,#+4
    448               { 
    449           		qos_size = 2; // 2 bytes for QoS 
    450           		qos_flag = MQTT_QOS2_FLAG; 
    451           	} 
    452           
    453          
    454           	// Variable header 
    455               var_header_len = topiclen+2+qos_size; // Topic size (2 bytes), utf-encoded topic 
   \                     ??mqtt_publish_with_qos_1:
   \   00000036   0x19A8             ADDS     R0,R5,R6
   \   00000038   0x1C80             ADDS     R0,R0,#+2
   \   0000003A   0xFA1F 0xFA80      UXTH     R10,R0
    456          
    457               var_header = (UINT8*)gsn_malloc(var_header_len);
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0xF240 0x11C9      MOVW     R1,#+457
   \   00000044   0x4650             MOV      R0,R10
   \   00000046   0x.... 0x....      BL       GsnDynMemMgmt_Alloc
   \   0000004A   0x0007             MOVS     R7,R0
    458          	 
    459               if (var_header == NULL) 
   \   0000004C   0xD112             BNE.N    ??mqtt_publish_with_qos_2
    460               { 
    461          	     S2w_Printf("\r\n PUBLISH VAILD HEADER is NULL");
   \   0000004E   0x.... 0x....      ADR.W    R0,`?<Constant "\\r\\n PUBLISH VAILD HEAD...">`
   \                     ??mqtt_publish_with_qos_3:
   \   00000052   0x.... 0x....      BL       S2w_Printf
    462                   goto error; 
    463               } 
    464          	 memset(var_header,0,var_header_len);
    465           	var_header[0] = topiclen>>8; 
    466           	var_header[1] = topiclen&0xFF; 
    467           	memcpy(var_header+2, topic, topiclen); 
    468           	if(qos_size)  
    469               { 
    470           		var_header[topiclen+2] = broker->seq>>8; 
    471           		var_header[topiclen+3] = broker->seq&0xFF; 
    472           		if(message_id) // Returning message id 
    473                   {  
    474           			*message_id = broker->seq; 
    475           		} 
    476           		broker->seq++;
    477           	} 
    478                  //broker->seq = broker->seq % 128;
    479          
    480           	// Fixed header 
    481           	// the remaining length is one byte for messages up to 127 bytes, then two bytes after that 
    482           	// actually, it can be up to 4 bytes but I'm making the assumption the embedded device will only 
    483           	// need up to two bytes of length (handles up to 16,383 (almost 16k) sized message) 
    484           	fixedHeaderSize = 2;    // Default size = one byte Message Type + one byte Remaining Length 
    485               // Message Type, DUP flag, QoS level, Retain 
    486               fixed_header[0] = MQTT_MSG_PUBLISH | qos_flag; 
    487           	if(retain)  
    488               { 
    489           		fixed_header[0] |= MQTT_RETAIN_FLAG; 
    490               } 
    491                
    492           	remainLen = var_header_len+msglen; 
    493               // Remaining Length 
    494               if (remainLen <= 127)  
    495               { 
    496                   fixed_header[1] = remainLen; 
    497               }  
    498               else  
    499              { 
    500                   fixedHeaderSize++;          // add an additional byte for Remaining Length 
    501                
    502                   // first byte is remainder (mod) of 128, then set the MSB to indicate more bytes 
    503                   fixed_header[1] = remainLen % 128; 
    504                   fixed_header[1] = fixed_header[1] | 0x80; 
    505                   // second byte is number of 128s 
    506                   fixed_header[2] = remainLen / 128; 
    507               } 
    508           
    509          
    510               packetLen = fixedHeaderSize+var_header_len+msglen; 
    511          
    512          	 packet = (UINT8*)gsn_malloc(packetLen);
    513          	  if (packet == NULL) 
    514               { 
    515          		 S2w_Printf("\r\n PUBLISH PACKET is NULL");
    516                   goto error; 
    517               } 
    518          	 memset(packet,0,packetLen);
    519           	memcpy(packet, fixed_header, fixedHeaderSize); 
    520           	memcpy(packet+fixedHeaderSize, var_header, var_header_len); 
    521           	memcpy(packet+fixedHeaderSize+var_header_len, msg, msglen); 
    522           
    523          
    524           	// Send the packet 
    525          	if( AppS2wHal_NetTx(broker->mqtt_cid, broker->mqtt_peerData.ipAddr, broker->mqtt_peerData.port, packet, packetLen) != 0 )
    526              { 
    527                   goto error; 
    528           	} 
    529          
    530          	if (var_header != NULL) 
    531               { 
    532          
    533          	   gsn_free(var_header);
    534          
    535          	   var_header = NULL;
    536               } 
    537          
    538          	if (packet != NULL) 
    539               { 
    540          	   gsn_free(packet);
    541          
    542          	   packet = NULL;
    543               } 
    544          	
    545           	return 0; 
    546           error: 
    547             S2w_Printf("\r\n publish Error");    
   \                     ??mqtt_publish_with_qos_4:
   \   00000056   0x.... 0x....      ADR.W    R0,`?<Constant "\\r\\n publish Error">`
   \   0000005A   0x.... 0x....      BL       S2w_Printf
    548               if (var_header != NULL) 
   \   0000005E   0xB10F             CBZ.N    R7,??CrossCallReturnLabel_30
    549               { 
    550          
    551          	   gsn_free(var_header);
   \   00000060   0x.... 0x....      BL       ?Subroutine13
    552          
    553          	   var_header = NULL;
    554               } 
    555                
    556               if (packet != NULL) 
   \                     ??CrossCallReturnLabel_30:
   \   00000064   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000068   0xBF1C             ITT      NE 
   \   0000006A   0x4640             MOVNE    R0,R8
   \   0000006C   0x.... 0x....      BLNE     GsnDynMemMgmt_Free
    557               { 
    558          
    559          	   gsn_free(packet);
    560          
    561          	   packet = NULL;
    562               } 
    563                
    564               return  1; 
   \   00000070   0x2001             MOVS     R0,#+1
   \                     ??mqtt_publish_with_qos_5:
   \   00000072   0x....             B.N      ?Subroutine3
   \                     ??mqtt_publish_with_qos_2:
   \   00000074   0x4652             MOV      R2,R10
   \   00000076   0x.... 0x....      BL       ??Subroutine8_1
   \                     ??CrossCallReturnLabel_11:
   \   0000007A   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_7:
   \   0000007E   0xB175             CBZ.N    R5,??mqtt_publish_with_qos_6
   \   00000080   0x9902             LDR      R1,[SP, #+8]
   \   00000082   0x313C             ADDS     R1,R1,#+60
   \   00000084   0x19F0             ADDS     R0,R6,R7
   \   00000086   0x8A8A             LDRH     R2,[R1, #+20]
   \   00000088   0x0A12             LSRS     R2,R2,#+8
   \   0000008A   0x7082             STRB     R2,[R0, #+2]
   \   0000008C   0x8A8A             LDRH     R2,[R1, #+20]
   \   0000008E   0x70C2             STRB     R2,[R0, #+3]
   \   00000090   0x980F             LDR      R0,[SP, #+60]
   \   00000092   0xB108             CBZ.N    R0,??mqtt_publish_with_qos_7
   \   00000094   0x8A8A             LDRH     R2,[R1, #+20]
   \   00000096   0x8002             STRH     R2,[R0, #+0]
   \                     ??mqtt_publish_with_qos_7:
   \   00000098   0x8A88             LDRH     R0,[R1, #+20]
   \   0000009A   0x1C40             ADDS     R0,R0,#+1
   \   0000009C   0x8288             STRH     R0,[R1, #+20]
   \                     ??mqtt_publish_with_qos_6:
   \   0000009E   0xF049 0x0030      ORR      R0,R9,#0x30
   \   000000A2   0x2602             MOVS     R6,#+2
   \   000000A4   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   000000A8   0xB12C             CBZ.N    R4,??mqtt_publish_with_qos_8
   \   000000AA   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000AE   0xF040 0x0001      ORR      R0,R0,#0x1
   \   000000B2   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \                     ??mqtt_publish_with_qos_8:
   \   000000B6   0xEB0B 0x000A      ADD      R0,R11,R10
   \   000000BA   0xB280             UXTH     R0,R0
   \   000000BC   0xA901             ADD      R1,SP,#+4
   \   000000BE   0x2880             CMP      R0,#+128
   \   000000C0   0xBFB8             IT       LT 
   \   000000C2   0x7048             STRBLT   R0,[R1, #+1]
   \   000000C4   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_19:
   \   000000C8   0xEB0A 0x0006      ADD      R0,R10,R6
   \   000000CC   0xEB0B 0x0400      ADD      R4,R11,R0
   \   000000D0   0xB2A4             UXTH     R4,R4
   \   000000D2   0x2200             MOVS     R2,#+0
   \   000000D4   0xF44F 0x7100      MOV      R1,#+512
   \   000000D8   0x4620             MOV      R0,R4
   \   000000DA   0x.... 0x....      BL       GsnDynMemMgmt_Alloc
   \   000000DE   0xEA5F 0x0800      MOVS     R8,R0
   \   000000E2   0xBF08             IT       EQ 
   \   000000E4   0x.... 0x....      ADREQ.W  R0,`?<Constant "\\r\\n PUBLISH PACKET is ...">`
   \   000000E8   0xD0B3             BEQ.N    ??mqtt_publish_with_qos_3
   \   000000EA   0x.... 0x....      BL       ??Subroutine8_0
   \                     ??CrossCallReturnLabel_14:
   \   000000EE   0x4632             MOV      R2,R6
   \   000000F0   0xA901             ADD      R1,SP,#+4
   \   000000F2   0x4640             MOV      R0,R8
   \   000000F4   0x.... 0x....      BL       memcpy
   \   000000F8   0x4446             ADD      R6,R6,R8
   \   000000FA   0x4652             MOV      R2,R10
   \   000000FC   0x4639             MOV      R1,R7
   \   000000FE   0x4630             MOV      R0,R6
   \   00000100   0x.... 0x....      BL       memcpy
   \   00000104   0x9904             LDR      R1,[SP, #+16]
   \   00000106   0xFA1F 0xF28B      UXTH     R2,R11
   \   0000010A   0xEB0A 0x0006      ADD      R0,R10,R6
   \   0000010E   0x.... 0x....      BL       memcpy
   \   00000112   0x9802             LDR      R0,[SP, #+8]
   \   00000114   0x9400             STR      R4,[SP, #+0]
   \   00000116   0x4643             MOV      R3,R8
   \   00000118   0x8842             LDRH     R2,[R0, #+2]
   \   0000011A   0x1D01             ADDS     R1,R0,#+4
   \   0000011C   0xF890 0x003C      LDRB     R0,[R0, #+60]
   \   00000120   0x.... 0x....      BL       AppS2wHal_NetTx
   \   00000124   0x2800             CMP      R0,#+0
   \   00000126   0xD196             BNE.N    ??mqtt_publish_with_qos_4
   \   00000128   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_29:
   \   0000012C   0x4640             MOV      R0,R8
   \   0000012E   0x.... 0x....      BL       GsnDynMemMgmt_Free
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0xE79D             B.N      ??mqtt_publish_with_qos_5
    565           } 

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13:
   \   00000000   0x4638             MOV      R0,R7
   \   00000002   0x.... 0x....      B.W      GsnDynMemMgmt_Free

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10:
   \   00000000   0xDB05             BLT.N    ??Subroutine10_0
   \   00000002   0xF040 0x0280      ORR      R2,R0,#0x80
   \   00000006   0x09C0             LSRS     R0,R0,#+7
   \   00000008   0x2603             MOVS     R6,#+3
   \   0000000A   0x704A             STRB     R2,[R1, #+1]
   \   0000000C   0x7088             STRB     R0,[R1, #+2]
   \                     ??Subroutine10_0:
   \   0000000E   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7:
   \   00000000   0x0A30             LSRS     R0,R6,#+8
   \   00000002   0x7038             STRB     R0,[R7, #+0]
   \   00000004   0x707E             STRB     R6,[R7, #+1]
   \   00000006   0x4632             MOV      R2,R6
   \   00000008   0x9903             LDR      R1,[SP, #+12]
   \   0000000A   0x1CB8             ADDS     R0,R7,#+2
   \   0000000C   0x.... 0x....      B.W      memcpy
    566           
    567           

   \                                 In section .text, align 2, keep-with-next
    568           int mqtt_pubrel(mqtt_broker_handle_t* broker, UINT16 message_id)  
    569           { 
   \                     mqtt_pubrel:
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    570           	UINT8 packet[] =  
    571               { 
    572           		MQTT_MSG_PUBREL | MQTT_QOS1_FLAG, // Message Type, DUP flag, QoS level, Retain 
    573           		0x02, // Remaining length 
    574           		message_id>>8, 
    575           		message_id&0xFF 
    576           	}; 
   \   00000002   0x.... 0x....      ADR.W    R3,`?<Constant {98, 2, 0, 0}>`
   \   00000006   0x681C             LDR      R4,[R3, #0]
   \   00000008   0xAA01             ADD      R2,SP,#+4
    577           
    578          
    579           	// Send the packet 
    580           	/*if(broker->send(broker->socket_info, packet, sizeof(packet)) < sizeof(packet))  
    581               { 
    582           		return -1; 
    583           	} */
    584              if( AppS2wHal_NetTx(broker->mqtt_cid, broker->mqtt_peerData.ipAddr, broker->mqtt_peerData.port, packet, sizeof(packet)) != 0 )
   \   0000000A   0xAB01             ADD      R3,SP,#+4
   \   0000000C   0x6014             STR      R4,[R2, #+0]
   \   0000000E   0xF88D 0x1007      STRB     R1,[SP, #+7]
   \   00000012   0x0A0A             LSRS     R2,R1,#+8
   \   00000014   0xF88D 0x2006      STRB     R2,[SP, #+6]
   \   00000018   0x2104             MOVS     R1,#+4
   \   0000001A   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_24:
   \   0000001E   0xB100             CBZ.N    R0,??mqtt_pubrel_0
    585              { 
    586                   return 1; 
   \   00000020   0x2001             MOVS     R0,#+1
    587           	} 
    588          
    589           	return 0; 
   \                     ??mqtt_pubrel_0:
   \   00000022   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    590           } 
    591           
    592          

   \                                 In section .text, align 2, keep-with-next
    593           int mqtt_subscribe(mqtt_broker_handle_t* broker, const char* topic, UINT16* message_id)  
    594           { 
   \                     mqtt_subscribe:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine5
    595               UINT16    utf_topic_len = 0; 
    596           	UINT8     *utf_topic = NULL;  
    597               UINT16    packetLen = 0; 
    598           	UINT8     *packet = NULL; 
    599           	UINT8     fixed_header[2]; 
    600           	UINT8     var_header[2]; // Message ID 
    601                
    602           	UINT16 topiclen = strlen(topic); 
   \                     ??CrossCallReturnLabel_3:
   \   00000006   0x.... 0x....      BL       ?Subroutine9
    603           
    604          
    605           	// Variable header 
    606           	var_header[0] = broker->seq>>8; 
    607           	var_header[1] = broker->seq&0xFF; 
    608           	if(message_id) // Returning message id 
    609               {  
    610           		*message_id = broker->seq; 
    611           	} 
    612           	broker->seq++; 
    613           
    614          
    615           	// utf topic 
    616               utf_topic_len = topiclen+3;// Topic size (2 bytes), utf-encoded topic, QoS byte 
   \                     ??CrossCallReturnLabel_17:
   \   0000000A   0x1CEE             ADDS     R6,R5,#+3
   \   0000000C   0xB2B6             UXTH     R6,R6
    617               //utf_topic = (UINT8*)_mem_alloc_zero(utf_topic_len);
    618               utf_topic = malloc(utf_topic_len);
   \   0000000E   0x4630             MOV      R0,R6
   \   00000010   0x.... 0x....      BL       malloc
   \   00000014   0x4607             MOV      R7,R0
    619               memset(utf_topic,0,utf_topic_len);  
   \   00000016   0x4632             MOV      R2,R6
   \   00000018   0x.... 0x....      BL       ??Subroutine8_1
    620               if (utf_topic == NULL) 
   \                     ??CrossCallReturnLabel_10:
   \   0000001C   0xB15F             CBZ.N    R7,??mqtt_subscribe_0
    621               { 
    622                   goto error; 
    623               } 
    624           	utf_topic[0] = topiclen>>8; 
   \   0000001E   0x.... 0x....      BL       ?Subroutine6
    625           	utf_topic[1] = topiclen&0xFF; 
    626           	memcpy(utf_topic+2, topic, topiclen); 
    627           
    628          
    629           	// Fixed header 
    630           	fixed_header[0] = MQTT_MSG_SUBSCRIBE | MQTT_QOS1_FLAG; // Message Type, DUP flag, QoS level, Retain 
   \                     ??CrossCallReturnLabel_5:
   \   00000022   0x2082             MOVS     R0,#+130
   \   00000024   0x.... 0x....      BL       ?Subroutine4
    631               fixed_header[1] = sizeof(var_header)+utf_topic_len; 
    632           
    633          
    634               packetLen = sizeof(var_header)+sizeof(fixed_header)+utf_topic_len; 
    635               //packet = (UINT8*)_mem_alloc_zero(packetLen); 
    636               packet = malloc(packetLen);
   \                     ??CrossCallReturnLabel_1:
   \   00000028   0x.... 0x....      BL       ?Subroutine8
    637               memset(packet,0,packetLen); 
    638               if (packet == NULL) 
   \                     ??CrossCallReturnLabel_16:
   \   0000002C   0xB105             CBZ.N    R5,??mqtt_subscribe_1
    639               { 
    640                   goto error; 
    641               } 
    642           	memcpy(packet, fixed_header, sizeof(fixed_header)); 
   \   0000002E   0x....             B.N      ?Subroutine1
    643           	memcpy(packet+sizeof(fixed_header), var_header, sizeof(var_header)); 
    644           	memcpy(packet+sizeof(fixed_header)+sizeof(var_header), utf_topic, utf_topic_len); 
    645           
    646          
    647           	// Send the packet 
    648           	/*if(broker->send(broker->socket_info, packet, packetLen) < packetLen) { 
    649                   goto error; 
    650           	} */
    651           
    652          
    653               //_mem_free(utf_topic);
    654                  free(utf_topic);
    655               //_mem_free(packet);
    656                  free(packet);
    657                
    658           	return 1; 
    659                
    660           error: 
    661               if (utf_topic != NULL) 
    662               { 
    663                   //_mem_free(utf_topic);
    664                 free(utf_topic);
   \                     ??mqtt_subscribe_1:
   \   00000030   0x4638             MOV      R0,R7
   \   00000032   0x.... 0x....      BL       free
    665               } 
    666                
    667               if (packet != NULL) 
    668               { 
    669                   //_mem_free(packet);
    670                 free(packet);
    671               } 
    672                
    673               return  -1; 
   \                     ??mqtt_subscribe_0:
   \   00000036   0x....             B.N      ?Subroutine2
    674           } 

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   0xF04F 0x30FF      MOV      R0,#-1
   \   00000004   0xBDF2             POP      {R1,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9:
   \   00000000   0xB285             UXTH     R5,R0
   \   00000002   0xF8B6 0x0050      LDRH     R0,[R6, #+80]
   \   00000006   0x0A00             LSRS     R0,R0,#+8
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000000C   0xF8B6 0x0050      LDRH     R0,[R6, #+80]
   \   00000010   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   00000014   0xB117             CBZ.N    R7,??Subroutine9_0
   \   00000016   0xF8B6 0x0050      LDRH     R0,[R6, #+80]
   \   0000001A   0x8038             STRH     R0,[R7, #+0]
   \                     ??Subroutine9_0:
   \   0000001C   0xF8B6 0x0050      LDRH     R0,[R6, #+80]
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0xF8A6 0x0050      STRH     R0,[R6, #+80]
   \   00000026   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6:
   \   00000000   0x0A28             LSRS     R0,R5,#+8
   \   00000002   0x7038             STRB     R0,[R7, #+0]
   \   00000004   0x707D             STRB     R5,[R7, #+1]
   \   00000006   0x462A             MOV      R2,R5
   \   00000008   0x4621             MOV      R1,R4
   \   0000000A   0x1CB8             ADDS     R0,R7,#+2
   \   0000000C   0x.... 0x....      B.W      memcpy

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5:
   \   00000000   0x4606             MOV      R6,R0
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4617             MOV      R7,R2
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      B.W      strlen

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4:
   \   00000000   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   00000004   0x1D34             ADDS     R4,R6,#+4
   \   00000006   0x1CB0             ADDS     R0,R6,#+2
   \   00000008   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   0000000C   0xB2A4             UXTH     R4,R4
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      B.W      malloc

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0x2202             MOVS     R2,#+2
   \   00000002   0xF10D 0x0102      ADD      R1,SP,#+2
   \   00000006   0x4628             MOV      R0,R5
   \   00000008   0x.... 0x....      BL       memcpy
   \   0000000C   0x2202             MOVS     R2,#+2
   \   0000000E   0xA900             ADD      R1,SP,#+0
   \   00000010   0x1CA8             ADDS     R0,R5,#+2
   \   00000012   0x.... 0x....      BL       memcpy
   \   00000016   0x4632             MOV      R2,R6
   \   00000018   0x4639             MOV      R1,R7
   \   0000001A   0x1D28             ADDS     R0,R5,#+4
   \   0000001C   0x.... 0x....      BL       memcpy
   \   00000020   0x4638             MOV      R0,R7
   \   00000022   0x.... 0x....      BL       free
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x.... 0x....      BL       free
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xBDF2             POP      {R1,R4-R7,PC}
    675           
    676          

   \                                 In section .text, align 2, keep-with-next
    677           int mqtt_unsubscribe(mqtt_broker_handle_t* broker, const char* topic, UINT16* message_id)  
    678           { 
   \                     mqtt_unsubscribe:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine5
    679               UINT16    packetLen = 0; 
    680           	UINT8     *packet = NULL;     
    681           	UINT8     fixed_header[2]; 
    682           	UINT16    topiclen = strlen(topic); 
   \                     ??CrossCallReturnLabel_2:
   \   00000006   0x.... 0x....      BL       ?Subroutine9
    683               UINT16    utf_topic_len = 0; 
    684           	UINT8     *utf_topic = NULL; 
    685           
    686          
    687           	// Variable header 
    688           	UINT8 var_header[2]; // Message ID 
    689           	var_header[0] = broker->seq>>8; 
    690           	var_header[1] = broker->seq&0xFF; 
    691           	if(message_id) { // Returning message id 
    692           		*message_id = broker->seq; 
    693           	} 
    694           	broker->seq++; 
    695           
    696          
    697           	// utf topic 
    698               utf_topic_len = topiclen+2;         // Topic size (2 bytes), utf-encoded topic 
   \                     ??CrossCallReturnLabel_18:
   \   0000000A   0x1CAE             ADDS     R6,R5,#+2
   \   0000000C   0xB2B6             UXTH     R6,R6
    699               //utf_topic = (UINT8*)_mem_alloc_zero(utf_topic_len); 
    700               utf_topic = malloc(utf_topic_len);
   \   0000000E   0x4630             MOV      R0,R6
   \   00000010   0x.... 0x....      BL       malloc
   \   00000014   0x4607             MOV      R7,R0
    701               memset(utf_topic,0,utf_topic_len);
   \   00000016   0x4632             MOV      R2,R6
   \   00000018   0x.... 0x....      BL       ??Subroutine8_1
    702               if (utf_topic == NULL) 
   \                     ??CrossCallReturnLabel_9:
   \   0000001C   0xB15F             CBZ.N    R7,??mqtt_unsubscribe_0
    703               { 
    704                   goto error; 
    705               } 
    706                
    707           	utf_topic[0] = topiclen>>8; 
   \   0000001E   0x.... 0x....      BL       ?Subroutine6
    708           	utf_topic[1] = topiclen&0xFF; 
    709           	memcpy(utf_topic+2, topic, topiclen); 
    710           
    711          
    712           	// Fixed header 
    713           	fixed_header[0] = MQTT_MSG_UNSUBSCRIBE | MQTT_QOS1_FLAG; // Message Type, DUP flag, QoS level, Retain 
   \                     ??CrossCallReturnLabel_4:
   \   00000022   0x20A2             MOVS     R0,#+162
   \   00000024   0x.... 0x....      BL       ?Subroutine4
    714               fixed_header[1] = sizeof(var_header) + utf_topic_len; 
    715           
    716          
    717               packetLen = sizeof(var_header)+sizeof(fixed_header)+utf_topic_len; 
    718           	//packet = (UINT8*)_mem_alloc_zero(packetLen);
    719               packet = malloc(packetLen);
   \                     ??CrossCallReturnLabel_0:
   \   00000028   0x.... 0x....      BL       ?Subroutine8
    720               memset(packet,0,packetLen);
    721               if (packet == NULL) 
   \                     ??CrossCallReturnLabel_15:
   \   0000002C   0xB105             CBZ.N    R5,??mqtt_unsubscribe_1
    722               { 
    723                   goto error; 
    724               } 
    725           	memcpy(packet, fixed_header, sizeof(fixed_header)); 
   \   0000002E   0x....             B.N      ?Subroutine1
    726           	memcpy(packet+sizeof(fixed_header), var_header, sizeof(var_header)); 
    727           	memcpy(packet+sizeof(fixed_header)+sizeof(var_header), utf_topic, utf_topic_len); 
    728           
    729          
    730           	// Send the packet 
    731           	/*if(broker->send(broker->socket_info, packet, packetLen) < packetLen)  
    732               { 
    733           		goto error;         
    734           	} */
    735           
    736          
    737               //_mem_free(utf_topic);
    738                  free(utf_topic);
    739               //_mem_free(packet);
    740                  free(packet);
    741                
    742           	return 1; 
    743                
    744           error: 
    745               if (utf_topic != NULL) 
    746               { 
    747                   //_mem_free(utf_topic);
    748                 free(utf_topic);
   \                     ??mqtt_unsubscribe_1:
   \   00000030   0x4638             MOV      R0,R7
   \   00000032   0x.... 0x....      BL       free
    749               } 
    750                
    751               if (packet != NULL) 
    752               { 
    753                   //_mem_free(packet);
    754                 free(packet);
    755               } 
    756                
    757               return  -1; 
   \                     ??mqtt_unsubscribe_0:
   \   00000036                      REQUIRE ?Subroutine2
   \   00000036                      ;; // Fall through to label ?Subroutine2
    758           } 
    759          

   \                                 In section .text, align 2, keep-with-next
    760          UINT8 mqtt_publish_retry_dup(mqtt_broker_handle_t* broker, const char* topic, const char* msg, UINT8 DUP, UINT8 qos, UINT16 message_id)  
    761           { 
   \                     mqtt_publish_retry_dup:
   \   00000000   0xE92D 0x4FF6      PUSH     {R1,R2,R4-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0xB083             SUB      SP,SP,#+12
    762           	UINT8 fixedHeaderSize = 0; 
    763           	UINT16 remainLen = 0; 
    764              UINT16 packetLen = 0; 
    765           	UINT8 *packet = NULL; 
   \   00000008   0xF04F 0x0A00      MOV      R10,#+0
    766           	UINT16 topiclen = strlen(topic); 
   \   0000000C   0x4608             MOV      R0,R1
   \   0000000E   0x.... 0x....      BL       strlen
   \   00000012   0xB286             UXTH     R6,R0
    767           	UINT16 msglen = strlen(msg); 
   \   00000014   0x9804             LDR      R0,[SP, #+16]
   \   00000016   0x.... 0x....      BL       strlen
   \   0000001A   0x4683             MOV      R11,R0
    768              UINT16 var_header_len = 0;  
    769           	UINT8 *var_header = NULL; 
    770           	UINT8 fixed_header[3]; 
    771          
    772          
    773           	UINT8 qos_flag = MQTT_QOS0_FLAG; 
    774           	UINT8 qos_size = 0; // No QoS included 
   \   0000001C   0x980E             LDR      R0,[SP, #+56]
   \   0000001E   0x2400             MOVS     R4,#+0
   \   00000020   0x46D1             MOV      R9,R10
    775                
    776           	if(qos == 1)  
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD102             BNE.N    ??mqtt_publish_retry_dup_0
    777               { 
    778           		qos_size = 2; // 2 bytes for QoS 
   \   00000026   0x2402             MOVS     R4,#+2
    779           		qos_flag = MQTT_QOS1_FLAG; 
   \   00000028   0x46A1             MOV      R9,R4
   \   0000002A   0xE004             B.N      ??mqtt_publish_retry_dup_1
    780           	} 
    781           	else if(qos == 2)  
   \                     ??mqtt_publish_retry_dup_0:
   \   0000002C   0x2802             CMP      R0,#+2
   \   0000002E   0xBF04             ITT      EQ 
   \   00000030   0x2402             MOVEQ    R4,#+2
   \   00000032   0xF04F 0x0904      MOVEQ    R9,#+4
    782               { 
    783           		qos_size = 2; // 2 bytes for QoS 
    784           		qos_flag = MQTT_QOS2_FLAG; 
    785           	} 
    786           
    787          
    788           	// Variable header 
    789               var_header_len = topiclen+2+qos_size; // Topic size (2 bytes), utf-encoded topic 
   \                     ??mqtt_publish_retry_dup_1:
   \   00000036   0x19A0             ADDS     R0,R4,R6
   \   00000038   0x1C80             ADDS     R0,R0,#+2
   \   0000003A   0xB285             UXTH     R5,R0
    790          
    791               var_header = (UINT8*)gsn_malloc(var_header_len);
   \   0000003C   0x2200             MOVS     R2,#+0
   \   0000003E   0xF240 0x3117      MOVW     R1,#+791
   \   00000042   0x4628             MOV      R0,R5
   \   00000044   0x.... 0x....      BL       GsnDynMemMgmt_Alloc
   \   00000048   0x0007             MOVS     R7,R0
    792          	 
    793               if (var_header == NULL) 
   \   0000004A   0xD112             BNE.N    ??mqtt_publish_retry_dup_2
    794               { 
    795          	     S2w_Printf("\r\n PUBLISH VAILD HEADER is NULL");
   \   0000004C   0x.... 0x....      ADR.W    R0,`?<Constant "\\r\\n PUBLISH VAILD HEAD...">`
   \                     ??mqtt_publish_retry_dup_3:
   \   00000050   0x.... 0x....      BL       S2w_Printf
    796                   goto error; 
    797               } 
    798          	memset(var_header,0,var_header_len);
    799           	var_header[0] = topiclen>>8; 
    800           	var_header[1] = topiclen&0xFF; 
    801           	memcpy(var_header+2, topic, topiclen); 
    802           	if(qos_size)  
    803              { 
    804           		var_header[topiclen+2] = message_id>>8; 
    805           		var_header[topiclen+3] = message_id&0xFF; 
    806           	} 
    807          
    808           	// Fixed header 
    809           	// the remaining length is one byte for messages up to 127 bytes, then two bytes after that 
    810           	// actually, it can be up to 4 bytes but I'm making the assumption the embedded device will only 
    811           	// need up to two bytes of length (handles up to 16,383 (almost 16k) sized message) 
    812           	fixedHeaderSize = 2;    // Default size = one byte Message Type + one byte Remaining Length 
    813               // Message Type, DUP flag, QoS level, Retain 
    814               fixed_header[0] = MQTT_MSG_PUBLISH | qos_flag | MQTT_DUP_FLAG; 
    815                
    816           	remainLen = var_header_len+msglen; 
    817               // Remaining Length 
    818               if (remainLen <= 127)  
    819               { 
    820                   fixed_header[1] = remainLen; 
    821               }  
    822               else  
    823              { 
    824                   fixedHeaderSize++;          // add an additional byte for Remaining Length 
    825                
    826                   // first byte is remainder (mod) of 128, then set the MSB to indicate more bytes 
    827                   fixed_header[1] = remainLen % 128; 
    828                   fixed_header[1] = fixed_header[1] | 0x80; 
    829                   // second byte is number of 128s 
    830                   fixed_header[2] = remainLen / 128; 
    831               } 
    832           
    833          
    834               packetLen = fixedHeaderSize+var_header_len+msglen; 
    835          
    836          	 packet = (UINT8*)gsn_malloc(packetLen);
    837          	  if (packet == NULL) 
    838               { 
    839          		 S2w_Printf("\r\n PUBLISH PACKET is NULL");
    840                   goto error; 
    841               } 
    842          	 memset(packet,0,packetLen);
    843           	memcpy(packet, fixed_header, fixedHeaderSize); 
    844           	memcpy(packet+fixedHeaderSize, var_header, var_header_len); 
    845           	memcpy(packet+fixedHeaderSize+var_header_len, msg, msglen); 
    846           
    847          
    848           	// Send the packet 
    849          	if( AppS2wHal_NetTx(broker->mqtt_cid, broker->mqtt_peerData.ipAddr, broker->mqtt_peerData.port, packet, packetLen) != 0 )
    850              { 
    851                   goto error; 
    852           	} 
    853          
    854          	if (var_header != NULL) 
    855               { 
    856          
    857          	   gsn_free(var_header);
    858          
    859          	   var_header = NULL;
    860               } 
    861          
    862          	if (packet != NULL) 
    863               { 
    864          	   gsn_free(packet);
    865          
    866          	   packet = NULL;
    867               } 
    868          	
    869           	return 0; 
    870           error: 
    871             S2w_Printf("\r\n publish retry Error");    
   \                     ??mqtt_publish_retry_dup_4:
   \   00000054   0x.... 0x....      ADR.W    R0,`?<Constant "\\r\\n publish retry Error">`
   \   00000058   0x.... 0x....      BL       S2w_Printf
    872               if (var_header != NULL) 
   \   0000005C   0xB10F             CBZ.N    R7,??CrossCallReturnLabel_28
    873               { 
    874          
    875          	   gsn_free(var_header);
   \   0000005E   0x.... 0x....      BL       ?Subroutine13
    876          
    877          	   var_header = NULL;
    878               } 
    879                
    880               if (packet != NULL) 
   \                     ??CrossCallReturnLabel_28:
   \   00000062   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000066   0xBF1C             ITT      NE 
   \   00000068   0x4650             MOVNE    R0,R10
   \   0000006A   0x.... 0x....      BLNE     GsnDynMemMgmt_Free
    881               { 
    882          
    883          	   gsn_free(packet);
    884          
    885          	   packet = NULL;
    886               } 
    887                
    888               return  1; 
   \   0000006E   0x2001             MOVS     R0,#+1
   \                     ??mqtt_publish_retry_dup_5:
   \   00000070   0x....             B.N      ?Subroutine3
   \                     ??mqtt_publish_retry_dup_2:
   \   00000072   0x462A             MOV      R2,R5
   \   00000074   0x.... 0x....      BL       ??Subroutine8_1
   \                     ??CrossCallReturnLabel_8:
   \   00000078   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_6:
   \   0000007C   0xB12C             CBZ.N    R4,??mqtt_publish_retry_dup_6
   \   0000007E   0x980F             LDR      R0,[SP, #+60]
   \   00000080   0x19F1             ADDS     R1,R6,R7
   \   00000082   0xB280             UXTH     R0,R0
   \   00000084   0x0A02             LSRS     R2,R0,#+8
   \   00000086   0x708A             STRB     R2,[R1, #+2]
   \   00000088   0x70C8             STRB     R0,[R1, #+3]
   \                     ??mqtt_publish_retry_dup_6:
   \   0000008A   0xF049 0x0038      ORR      R0,R9,#0x38
   \   0000008E   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   00000092   0x2602             MOVS     R6,#+2
   \   00000094   0xEB0B 0x0005      ADD      R0,R11,R5
   \   00000098   0xB280             UXTH     R0,R0
   \   0000009A   0xA901             ADD      R1,SP,#+4
   \   0000009C   0x2880             CMP      R0,#+128
   \   0000009E   0xBFB8             IT       LT 
   \   000000A0   0x7048             STRBLT   R0,[R1, #+1]
   \   000000A2   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_20:
   \   000000A6   0x19A8             ADDS     R0,R5,R6
   \   000000A8   0x4458             ADD      R0,R11,R0
   \   000000AA   0xB284             UXTH     R4,R0
   \   000000AC   0x2200             MOVS     R2,#+0
   \   000000AE   0xF44F 0x7151      MOV      R1,#+836
   \   000000B2   0x4620             MOV      R0,R4
   \   000000B4   0x.... 0x....      BL       GsnDynMemMgmt_Alloc
   \   000000B8   0xEA5F 0x0A00      MOVS     R10,R0
   \   000000BC   0xBF08             IT       EQ 
   \   000000BE   0x.... 0x....      ADREQ.W  R0,`?<Constant "\\r\\n PUBLISH PACKET is ...">`
   \   000000C2   0xD0C5             BEQ.N    ??mqtt_publish_retry_dup_3
   \   000000C4   0x.... 0x....      BL       ??Subroutine8_0
   \                     ??CrossCallReturnLabel_13:
   \   000000C8   0x4632             MOV      R2,R6
   \   000000CA   0xA901             ADD      R1,SP,#+4
   \   000000CC   0x4650             MOV      R0,R10
   \   000000CE   0x.... 0x....      BL       memcpy
   \   000000D2   0x4456             ADD      R6,R6,R10
   \   000000D4   0x462A             MOV      R2,R5
   \   000000D6   0x4639             MOV      R1,R7
   \   000000D8   0x4630             MOV      R0,R6
   \   000000DA   0x.... 0x....      BL       memcpy
   \   000000DE   0x9904             LDR      R1,[SP, #+16]
   \   000000E0   0xFA1F 0xF28B      UXTH     R2,R11
   \   000000E4   0x19A8             ADDS     R0,R5,R6
   \   000000E6   0x.... 0x....      BL       memcpy
   \   000000EA   0x9400             STR      R4,[SP, #+0]
   \   000000EC   0xF8B8 0x2002      LDRH     R2,[R8, #+2]
   \   000000F0   0xF898 0x003C      LDRB     R0,[R8, #+60]
   \   000000F4   0x4653             MOV      R3,R10
   \   000000F6   0xF108 0x0104      ADD      R1,R8,#+4
   \   000000FA   0x.... 0x....      BL       AppS2wHal_NetTx
   \   000000FE   0x2800             CMP      R0,#+0
   \   00000100   0xD1A8             BNE.N    ??mqtt_publish_retry_dup_4
   \   00000102   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_27:
   \   00000106   0x4650             MOV      R0,R10
   \   00000108   0x.... 0x....      BL       GsnDynMemMgmt_Free
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0xE7AF             B.N      ??mqtt_publish_retry_dup_5
    889           } 

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "emqtt">`:
   \   00000000   0x65 0x6D          DC8 "emqtt"
   \              0x71 0x74    
   \              0x74 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0, 6, 77, 81, 73, 115, 100, 112, 3`:
   \   00000000   0x00 0x06          DC8 0, 6, 77, 81, 73, 115, 100, 112, 3, 0, 0, 0
   \              0x4D 0x51    
   \              0x49 0x73    
   \              0x64 0x70    
   \              0x03 0x00    
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\r\\n CONNECT PACKET is ...">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012 CONNECT PACKET is NULL"
   \              0x20 0x43    
   \              0x4F 0x4E    
   \              0x4E 0x45    
   \              0x43 0x54    
   \              0x20 0x50    
   \              0x41 0x43    
   \              0x4B 0x45    
   \              0x54 0x20    
   \              0x69 0x73    
   \              0x20 0x4E    
   \              0x55 0x4C    
   \              0x4C 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\r\\n connect Error">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012 connect Error"
   \              0x20 0x63    
   \              0x6F 0x6E    
   \              0x6E 0x65    
   \              0x63 0x74    
   \              0x20 0x45    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {224, 0}>`:
   \   00000000   0xE0 0x00          DC8 224, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {192, 0}>`:
   \   00000000   0xC0 0x00          DC8 192, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\r\\n PUBLISH VAILD HEAD...">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012 PUBLISH VAILD HEADER is NULL"
   \              0x20 0x50    
   \              0x55 0x42    
   \              0x4C 0x49    
   \              0x53 0x48    
   \              0x20 0x56    
   \              0x41 0x49    
   \              0x4C 0x44    
   \              0x20 0x48    
   \              0x45 0x41    
   \              0x44 0x45    
   \              0x52 0x20    
   \              0x69 0x73    
   \              0x20 0x4E    
   \              0x55 0x4C    
   \              0x4C 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\r\\n PUBLISH PACKET is ...">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012 PUBLISH PACKET is NULL"
   \              0x20 0x50    
   \              0x55 0x42    
   \              0x4C 0x49    
   \              0x53 0x48    
   \              0x20 0x50    
   \              0x41 0x43    
   \              0x4B 0x45    
   \              0x54 0x20    
   \              0x69 0x73    
   \              0x20 0x4E    
   \              0x55 0x4C    
   \              0x4C 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\r\\n publish Error">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012 publish Error"
   \              0x20 0x70    
   \              0x75 0x62    
   \              0x6C 0x69    
   \              0x73 0x68    
   \              0x20 0x45    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {98, 2, 0, 0}>`:
   \   00000000   0x62 0x02          DC8 98, 2, 0, 0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\r\\n publish retry Error">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012 publish retry Error"
   \              0x20 0x70    
   \              0x75 0x62    
   \              0x6C 0x69    
   \              0x73 0x68    
   \              0x20 0x72    
   \              0x65 0x74    
   \              0x72 0x79    
   \              0x20 0x45    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x00         
   \   00000017   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   memcpy
         8   -> __aeabi_memcpy
       8   memset
         8   -> __aeabi_memset
      56   mqtt_connect
        56   -> AppS2wHal_NetTx
        56   -> GsnDynMemMgmt_Alloc
        56   -> GsnDynMemMgmt_Free
        56   -> S2w_Printf
        56   -> memcpy
        56   -> memset
        56   -> strlen
      16   mqtt_disconnect
        16   -> AppS2wHal_NetTx
      16   mqtt_init
        16   -> __aeabi_memcpy
        16   -> memcpy
        16   -> strlen
      16   mqtt_init_auth
         0   -> memcpy
        16   -> memcpy
        16   -> strlen
       0   mqtt_num_rem_len_bytes
       8   mqtt_parse_msg_id
         8   -> mqtt_num_rem_len_bytes
      24   mqtt_parse_pub_msg_ptr
        24   -> mqtt_num_rem_len_bytes
        24   -> mqtt_parse_rem_len
      16   mqtt_parse_pub_topic
        16   -> memcpy
        16   -> mqtt_parse_pub_topic_ptr
      16   mqtt_parse_pub_topic_ptr
        16   -> mqtt_num_rem_len_bytes
      16   mqtt_parse_publish_msg
        16   -> memcpy
        16   -> mqtt_parse_pub_msg_ptr
       8   mqtt_parse_rem_len
      16   mqtt_ping
        16   -> AppS2wHal_NetTx
      56   mqtt_publish_retry_dup
        56   -> AppS2wHal_NetTx
        56   -> GsnDynMemMgmt_Alloc
        56   -> GsnDynMemMgmt_Free
        56   -> S2w_Printf
        56   -> memcpy
        56   -> memset
        56   -> strlen
      56   mqtt_publish_with_qos
        56   -> AppS2wHal_NetTx
        56   -> GsnDynMemMgmt_Alloc
        56   -> GsnDynMemMgmt_Free
        56   -> S2w_Printf
        56   -> memcpy
        56   -> memset
        56   -> strlen
      16   mqtt_pubrel
        16   -> AppS2wHal_NetTx
       0   mqtt_set_alive
      24   mqtt_subscribe
        24   -> free
        24   -> malloc
        24   -> memcpy
        24   -> memset
        24   -> strlen
      24   mqtt_unsubscribe
        24   -> free
        24   -> malloc
        24   -> memcpy
        24   -> memset
        24   -> strlen


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      28  ?<Constant "\r\n CONNECT PACKET is ...">
      28  ?<Constant "\r\n PUBLISH PACKET is ...">
      32  ?<Constant "\r\n PUBLISH VAILD HEAD...">
      20  ?<Constant "\r\n connect Error">
      20  ?<Constant "\r\n publish Error">
      24  ?<Constant "\r\n publish retry Error">
       8  ?<Constant "emqtt">
      12  ?<Constant {0, 6, 77, 81, 73, 115, 100, 112, 3
       2  ?<Constant {192, 0}>
       2  ?<Constant {224, 0}>
       4  ?<Constant {98, 2, 0, 0}>
      16  ?Subroutine0
      48  ?Subroutine1
      16  ?Subroutine10
      10  ?Subroutine11
      14  ?Subroutine12
       6  ?Subroutine13
       6  ?Subroutine2
       6  ?Subroutine3
      20  ?Subroutine4
      12  ?Subroutine5
      16  ?Subroutine6
      16  ?Subroutine7
      10  ?Subroutine8
      40  ?Subroutine9
      12  memcpy
      20  memset
     372  mqtt_connect
      28  mqtt_disconnect
      58  mqtt_init
      64  mqtt_init_auth
      30  mqtt_num_rem_len_bytes
      74  mqtt_parse_msg_id
      72  mqtt_parse_pub_msg_ptr
      20  mqtt_parse_pub_topic
      46  mqtt_parse_pub_topic_ptr
      18  mqtt_parse_publish_msg
      34  mqtt_parse_rem_len
      30  mqtt_ping
     272  mqtt_publish_retry_dup
     310  mqtt_publish_with_qos
      36  mqtt_pubrel
       6  mqtt_set_alive
      56  mqtt_subscribe
      54  mqtt_unsubscribe

 
 2 028 bytes in section .text
 
 1 996 bytes of CODE memory (+ 32 bytes shared)

Errors: none
Warnings: none
