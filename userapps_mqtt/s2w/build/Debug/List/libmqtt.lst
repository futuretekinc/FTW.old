###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      30/Oct/2015  09:58:19 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\src\mqtt\libmqtt.c                            #
#    Command line =  E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\src\mqtt\libmqtt.c -D                         #
#                    TX_ENABLE_IAR_LIBRARY_SUPPORT -D IAR -D FIXED_ROM_BUILD  #
#                    -D RUN_ALL_FROM_FLASH -D TM_USE_HTTPD -D S2W_DNS_CLIENT  #
#                    -D NX_INCLUDE_USER_DEFINE_FILE -D S2W_WEB_FS_AVAILABLE   #
#                    -D S2W_EXTFLASH_DRIVER_TEST -D S2W_PWM_SUPPORT -D        #
#                    S2W_MEM_ACCESS -D S2W_FORCE_UART_PORT -D                 #
#                    S2W_EXT_FLASH_FWUP_PUSH_METHOD -D                        #
#                    S2W_NCM_SUPPORT_ENABLE -D S2W_SECURITY_ENTERPRISE_PEAP_V #
#                    0_AVAILABLE -D S2W_EXT_FLASH_FWUP_PULL_METHOD -D         #
#                    S2W_SECURITY_ENTERPRISE_TLS_AVAILABLE -D                 #
#                    S2W_DNS_SERVER_ENABLE -D ADK_OTAFU -D S2W_GSLINK_RAW -D  #
#                    S2W_GSLINK_XML -D S2W_SECURITY_ENTERPRISE_PEAP_V1_AVAILA #
#                    BLE -D S2W_PING_TRACE -D S2W_RF_TEST -D                  #
#                    S2W_SSL_CLIENT_SUPPORT -D S2W_DEFAULT_UART_PARITY=0 -D   #
#                    S2W_DHCP_SERVER_ENABLE -D S2W_SECURITY_WPS_ENABLE -D     #
#                    ADK_PROV_CONFIG_LIMITED_AP -D S2W_WEB_SERVER -D          #
#                    ADK_PROV -D S2W_DEFAULT_UART_SW_FLOW=0 -D                #
#                    S2W_FILE_UPLOAD_API -D S2W_COAP_SUPPORT -D               #
#                    S2W_HTTPD_SSLCERT_UPLOAD -D                              #
#                    S2W_DEFAULT_UART_STOP_BITS=0 -D S2W_FACT_IMAGE_REQ -D    #
#                    S2W_DEFAULT_UART_BAUD=9600 -D S2W_ASYNC_MSG -D           #
#                    S2W_HTTPS_SUPPORT -D S2W_DEFAULT_UART_HW_FLOW=0 -D       #
#                    S2W_SECURITY_ENTERPRISE_FAST_GTC_AVAILABLE -D            #
#                    S2W_WEB_PROV -D S2W_UNASSOC_TXRX_SUPPORT -D S2W_SNTP -D  #
#                    S2W_UART_ENABLE -D S2W_GSLINK_XMLNESTED_PARSER -D        #
#                    S2W_GSLINK -D S2W_SECURITY_ENTERPRISE_TTLS_AVAILABLE -D  #
#                    S2W_ADC_SUPPORT -D S2W_HTTPC_SUPPORT -D                  #
#                    S2W_SECURITY_ENTERPRISE_FAST_MSCHAPV2_AVAILABLE -D       #
#                    S2W_SSL_SERVER_SUPPORT -D ADK_PROV_CONFIG_CLIENT -D      #
#                    S2W_DEFAULT_UART_BITS_PER_CHAR=3 -D S2W_MDNS_ENABLE -lC  #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\Debug\List\ -lA                         #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\Debug\List\ --diag_suppress             #
#                    Pa050,Pe231,Pe177 -o E:\Gainspan\gs2011mxx_SDK_s2w_tls_t #
#                    lslp_5.1.5_GA\userapps_mqtt\s2w\build\Debug\Obj\         #
#                    --debug --endian=little --cpu=Cortex-M3 -e --fpu=None    #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA #
#                    \userapps_mqtt\s2w\build\..\..\..\geps\inc\ -I           #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\core\ -I              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\drivers\ -I           #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\modules\ -I           #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\rtos\ -I              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\netx\ -I              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\netx\netx_bsd_layer\  #
#                    -I E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\user #
#                    apps_mqtt\s2w\build\..\..\..\geps\inc\main\ -I           #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\fs\ -I                #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\fs\hcc\src\ -I        #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\security\src\ -I      #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\security\hw_engine_if #
#                    \ -I E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\us #
#                    erapps_mqtt\s2w\build\..\..\..\geps\inc\security\wpa_if\ #
#                     -I E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\use #
#                    rapps_mqtt\s2w\build\..\..\..\userlib\ncm\inc\ -I        #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\userlib\ -I                    #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\ctx\ -I                          #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\ -I                              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\main\ -I                         #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\hal\ -I                          #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\parser\ -I                       #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\config\ -I                       #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\ -I                              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\adk\otafu\inc\ -I              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\adk\provisioning\inc\ -I       #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\mqtt\ -I                         #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\mqtt\ -I                         #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\one_wire\ -I                     #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\one_wire\ -I                     #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\linked_list\ -I                  #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\linked_list\ -I                  #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\mqtt_main\ -I                    #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\mqtt_main\ -Ohz                  #
#                    --use_c++_inline -I "C:\Program Files (x86)\IAR          #
#                    Systems\Embedded Workbench 6.5\arm\CMSIS\Include\"       #
#    List file    =  E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\Debug\List\libmqtt.lst                  #
#    Object file  =  E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\Debug\Obj\libmqtt.o                     #
#                                                                             #
#                                                                             #
###############################################################################

E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapps_mqtt\s2w\src\mqtt\libmqtt.c
      1           /* 
      2            * This file is part of libemqtt. 
      3            * 
      4            * libemqtt is free software: you can redistribute it and/or modify 
      5            * it under the terms of the GNU Lesser General Public License as published by 
      6            * the Free Software Foundation, either version 3 of the License, or 
      7            * (at your option) any later version. 
      8            * 
      9            * libemqtt is distributed in the hope that it will be 
     10            * but WITHOUT ANY WARRANTY; without even the implied warranty of 
     11            * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
     12            * GNU General Public License for more details. 
     13            * 
     14            * You should have received a copy of the GNU General Public License 
     15            * along with libemqtt.  If not, see <http://www.gnu.org/licenses/>. 
     16            */ 
     17           
     18           
     19           /* 
     20            * 
     21            * Created by Filipe Varela on 09/10/16. 
     22            * Copyright 2009 Caixa Magica Software. All rights reserved. 
     23            * 
     24            * Fork developed by Vicente Ruiz Rodriguez 
     25            * Copyright 2012 Vicente Ruiz Rodriguez <vruiz2.0@gmail.com>. All rights reserved. 
     26            * 
     27            */ 
     28           //#include <mqx.h> 
     29           #include <string.h> 

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp void *memcpy(void *, void const *, size_t)
   \                     memcpy:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x.... 0x....      BL       __aeabi_memcpy
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp void *memset(void *, int, size_t)
   \                     memset:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4610             MOV      R0,R2
   \   00000006   0x460A             MOV      R2,R1
   \   00000008   0x4601             MOV      R1,R0
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       __aeabi_memset
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
     30           #include "mqtt/libmqtt.h" 
     31          
     32           
     33           #define MQTT_DUP_FLAG     1<<3 
     34           #define MQTT_QOS0_FLAG    0<<1 
     35           #define MQTT_QOS1_FLAG    1<<1 
     36           #define MQTT_QOS2_FLAG    2<<1 
     37           
     38           
     39           #define MQTT_RETAIN_FLAG  1 
     40           
     41           
     42           #define MQTT_CLEAN_SESSION  1<<1 
     43           #define MQTT_WILL_FLAG      1<<2 
     44           #define MQTT_WILL_RETAIN    1<<5 
     45           #define MQTT_USERNAME_FLAG  1<<7 
     46           #define MQTT_PASSWORD_FLAG  1<<6 
     47           
     48           
     49           
     50           

   \                                 In section .text, align 2, keep-with-next
     51           UINT8 mqtt_num_rem_len_bytes(const UINT8* buf) { 
     52           	UINT8 num_bytes = 1; 
     53           	 
     54           	//printf("mqtt_num_rem_len_bytes\n"); 
     55           	 
     56           	if ((buf[1] & 0x80) == 0x80) { 
   \                     mqtt_num_rem_len_bytes:
   \   00000000   0x7842             LDRB     R2,[R0, #+1]
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x0612             LSLS     R2,R2,#+24
   \   00000006   0xD508             BPL.N    ??mqtt_num_rem_len_bytes_0
     57           		num_bytes++; 
     58           		if ((buf[2] & 0x80) == 0x80) { 
   \   00000008   0x7882             LDRB     R2,[R0, #+2]
   \   0000000A   0x2102             MOVS     R1,#+2
   \   0000000C   0x0612             LSLS     R2,R2,#+24
   \   0000000E   0xD504             BPL.N    ??mqtt_num_rem_len_bytes_0
     59           			num_bytes ++; 
     60           			if ((buf[3] & 0x80) == 0x80) { 
   \   00000010   0x78C0             LDRB     R0,[R0, #+3]
   \   00000012   0x2103             MOVS     R1,#+3
   \   00000014   0x0600             LSLS     R0,R0,#+24
   \   00000016   0xBF48             IT       MI 
   \   00000018   0x2104             MOVMI    R1,#+4
     61           				num_bytes ++; 
     62           			} 
     63           		} 
     64           	} 
     65           	return num_bytes; 
   \                     ??mqtt_num_rem_len_bytes_0:
   \   0000001A   0x4608             MOV      R0,R1
   \   0000001C   0x4770             BX       LR               ;; return
     66           } 
     67           
     68           

   \                                 In section .text, align 2, keep-with-next
     69           UINT16 mqtt_parse_rem_len(const UINT8* buf) { 
   \                     mqtt_parse_rem_len:
   \   00000000   0xB510             PUSH     {R4,LR}
     70           	UINT16 multiplier = 1; 
   \   00000002   0x2201             MOVS     R2,#+1
     71           	UINT16 value = 0; 
   \   00000004   0x2100             MOVS     R1,#+0
     72           	UINT8 digit; 
     73           	 
     74           	//printf("mqtt_parse_rem_len\n"); 
     75           	 
     76           	buf++;	// skip "flags" byte in fixed header 
   \   00000006   0x1C40             ADDS     R0,R0,#+1
     77           
     78           
     79           	do { 
     80           		digit = *buf; 
   \                     ??mqtt_parse_rem_len_0:
   \   00000008   0xF810 0x3B01      LDRB     R3,[R0], #+1
     81           		value += (digit & 127) * multiplier; 
   \   0000000C   0xF003 0x047F      AND      R4,R3,#0x7F
   \   00000010   0xFB02 0x1104      MLA      R1,R2,R4,R1
     82           		multiplier *= 128; 
   \   00000014   0x05D2             LSLS     R2,R2,#+23
   \   00000016   0x0C12             LSRS     R2,R2,#+16
   \   00000018   0xB289             UXTH     R1,R1
     83           		buf++; 
     84           	} while ((digit & 128) != 0); 
   \   0000001A   0x061B             LSLS     R3,R3,#+24
   \   0000001C   0xD4F4             BMI.N    ??mqtt_parse_rem_len_0
     85           
     86           
     87           	return value; 
   \   0000001E   0x4608             MOV      R0,R1
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
     88           } 
     89           
     90           

   \                                 In section .text, align 2, keep-with-next
     91           UINT16 mqtt_parse_msg_id(const UINT8* buf) { 
   \                     mqtt_parse_msg_id:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
     92           	UINT8 type = MQTTParseMessageType(buf); 
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0xF000 0x01F0      AND      R1,R0,#0xF0
     93           	UINT8 qos = MQTTParseMessageQos(buf); 
   \   0000000A   0x0842             LSRS     R2,R0,#+1
     94           	UINT16 id = 0; 
   \   0000000C   0x2000             MOVS     R0,#+0
     95           	 
     96           	//printf("mqtt_parse_msg_id\n"); 
     97           	 
     98           	if(type >= MQTT_MSG_PUBLISH && type <= MQTT_MSG_UNSUBACK) { 
   \   0000000E   0xF1A1 0x0330      SUB      R3,R1,#+48
   \   00000012   0x2B81             CMP      R3,#+129
   \   00000014   0xD218             BCS.N    ??mqtt_parse_msg_id_0
     99           		if(type == MQTT_MSG_PUBLISH) { 
   \   00000016   0x2930             CMP      R1,#+48
   \   00000018   0xD10E             BNE.N    ??mqtt_parse_msg_id_1
    100           			if(qos != 0) { 
   \   0000001A   0x2103             MOVS     R1,#+3
   \   0000001C   0x420A             TST      R2,R1
   \   0000001E   0xD013             BEQ.N    ??mqtt_parse_msg_id_0
    101           				// fixed header length + Topic (UTF encoded) 
    102           				// = 1 for "flags" byte + rlb for length bytes + topic size 
    103           				UINT8 rlb = mqtt_num_rem_len_bytes(buf); 
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       mqtt_num_rem_len_bytes
    104           				UINT8 offset = *(buf+1+rlb)<<8;	// topic UTF MSB 
    105           				offset |= *(buf+1+rlb+1);			// topic UTF LSB 
    106           				offset += (1+rlb+2);					// fixed header + topic size 
   \   00000026   0x1901             ADDS     R1,R0,R4
   \   00000028   0x7889             LDRB     R1,[R1, #+2]
   \   0000002A   0x1840             ADDS     R0,R0,R1
   \   0000002C   0x1CC0             ADDS     R0,R0,#+3
   \   0000002E   0xB2C0             UXTB     R0,R0
    107           				id = *(buf+offset)<<8;				// id MSB 
    108           				id |= *(buf+offset+1);				// id LSB 
   \   00000030   0x5D01             LDRB     R1,[R0, R4]
   \   00000032   0x1900             ADDS     R0,R0,R4
   \   00000034   0x7840             LDRB     R0,[R0, #+1]
   \   00000036   0xE005             B.N      ??mqtt_parse_msg_id_2
    109           			} 
    110           		} else { 
    111           			// fixed header length 
    112           			// 1 for "flags" byte + rlb for length bytes 
    113           			UINT8 rlb = mqtt_num_rem_len_bytes(buf); 
   \                     ??mqtt_parse_msg_id_1:
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       mqtt_num_rem_len_bytes
    114           			id = *(buf+1+rlb)<<8;	// id MSB 
    115           			id |= *(buf+1+rlb+1);	// id LSB 
   \   0000003E   0x1900             ADDS     R0,R0,R4
   \   00000040   0x7841             LDRB     R1,[R0, #+1]
   \   00000042   0x7880             LDRB     R0,[R0, #+2]
   \                     ??mqtt_parse_msg_id_2:
   \   00000044   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
    116           		} 
    117           	} 
    118           	return id; 
   \                     ??mqtt_parse_msg_id_0:
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
    119           } 
    120           
    121           

   \                                 In section .text, align 2, keep-with-next
    122           UINT16 mqtt_parse_pub_topic(const UINT8* buf, UINT8* topic) { 
   \                     mqtt_parse_pub_topic:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    123           	const UINT8* ptr; 
    124           	UINT16 topic_len = mqtt_parse_pub_topic_ptr(buf, &ptr); 
   \   00000004   0xA900             ADD      R1,SP,#+0
   \   00000006   0x.... 0x....      BL       mqtt_parse_pub_topic_ptr
   \   0000000A   0x0005             MOVS     R5,R0
    125           	 
    126           	//printf("mqtt_parse_pub_topic\n"); 
    127           	 
    128           	if(topic_len != 0 && ptr != NULL) { 
   \   0000000C   0xBF1C             ITT      NE 
   \   0000000E   0x9800             LDRNE    R0,[SP, #+0]
   \   00000010   0x2800             CMPNE    R0,#+0
   \   00000012   0x....             B.N      ?Subroutine0
    129           		memcpy(topic, ptr, topic_len); 
    130           	} 
    131           	 
    132           	return topic_len; 
    133           }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0xD004             BEQ.N    ??Subroutine0_0
   \   00000002   0x4601             MOV      R1,R0
   \   00000004   0x462A             MOV      R2,R5
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       memcpy
   \                     ??Subroutine0_0:
   \   0000000C   0x4628             MOV      R0,R5
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    134           
    135           

   \                                 In section .text, align 2, keep-with-next
    136           UINT16 mqtt_parse_pub_topic_ptr(const UINT8* buf, const UINT8 **topic_ptr) { 
   \                     mqtt_parse_pub_topic_ptr:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
    137           	UINT16 len = 0; 
    138           	 
    139           	//printf("mqtt_parse_pub_topic_ptr\n"); 
    140           
    141           
    142           	if(MQTTParseMessageType(buf) == MQTT_MSG_PUBLISH) { 
   \   00000006   0x7829             LDRB     R1,[R5, #+0]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF001 0x01F0      AND      R1,R1,#0xF0
   \   0000000E   0x2930             CMP      R1,#+48
   \   00000010   0xD10B             BNE.N    ??mqtt_parse_pub_topic_ptr_0
    143           		// fixed header length = 1 for "flags" byte + rlb for length bytes 
    144           		UINT8 rlb = mqtt_num_rem_len_bytes(buf); 
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       mqtt_num_rem_len_bytes
    145           		len = *(buf+1+rlb)<<8;	// MSB of topic UTF 
    146           		len |= *(buf+1+rlb+1);	// LSB of topic UTF 
   \   00000018   0x1941             ADDS     R1,R0,R5
   \   0000001A   0x7848             LDRB     R0,[R1, #+1]
   \   0000001C   0x788A             LDRB     R2,[R1, #+2]
    147           		// start of topic = add 1 for "flags", rlb for remaining length, 2 for UTF 
    148           		*topic_ptr = (buf + (1+rlb+2)); 
   \   0000001E   0xF201 0x0103      ADDW     R1,R1,#+3
   \   00000022   0xEA42 0x2000      ORR      R0,R2,R0, LSL #+8
   \   00000026   0x6021             STR      R1,[R4, #+0]
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}
    149           	} else { 
    150           		*topic_ptr = NULL; 
   \                     ??mqtt_parse_pub_topic_ptr_0:
   \   0000002A   0x6020             STR      R0,[R4, #+0]
    151           	} 
    152           	return len; 
   \   0000002C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    153           } 
    154           
    155           

   \                                 In section .text, align 2, keep-with-next
    156           UINT16 mqtt_parse_publish_msg(const UINT8* buf, UINT8* msg) { 
   \                     mqtt_parse_publish_msg:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    157           	const UINT8* ptr; 
    158           	 
    159           	//printf("mqtt_parse_publish_msg\n"); 
    160           	 
    161           	UINT16 msg_len = mqtt_parse_pub_msg_ptr(buf, &ptr); 
   \   00000004   0xA900             ADD      R1,SP,#+0
   \   00000006   0x.... 0x....      BL       mqtt_parse_pub_msg_ptr
   \   0000000A   0x0005             MOVS     R5,R0
    162           	 
    163           	if(msg_len != 0 && ptr != NULL) { 
   \   0000000C   0xBF1C             ITT      NE 
   \   0000000E   0x9800             LDRNE    R0,[SP, #+0]
   \   00000010   0x2800             CMPNE    R0,#+0
   \   00000012                      REQUIRE ?Subroutine0
   \   00000012                      ;; // Fall through to label ?Subroutine0
    164           		memcpy(msg, ptr, msg_len); 
    165           	} 
    166           	 
    167           	return msg_len; 
    168           } 
    169           
    170           

   \                                 In section .text, align 2, keep-with-next
    171           UINT16 mqtt_parse_pub_msg_ptr(const UINT8* buf, const UINT8 **msg_ptr) { 
   \                     mqtt_parse_pub_msg_ptr:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    172           	UINT16 len = 0; 
    173           	 
    174           	//printf("mqtt_parse_pub_msg_ptr\n"); 
    175           	 
    176           	if(MQTTParseMessageType(buf) == MQTT_MSG_PUBLISH) { 
   \   00000006   0x7821             LDRB     R1,[R4, #+0]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF001 0x01F0      AND      R1,R1,#0xF0
   \   0000000E   0x2930             CMP      R1,#+48
   \   00000010   0xD117             BNE.N    ??mqtt_parse_pub_msg_ptr_0
    177           		// message starts at 
    178           		// fixed header length + Topic (UTF encoded) + msg id (if QoS>0) 
    179           		UINT8 rlb = mqtt_num_rem_len_bytes(buf); 
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       mqtt_num_rem_len_bytes
   \   00000018   0x4606             MOV      R6,R0
    180           		UINT8 offset = (*(buf+1+rlb))<<8;	// topic UTF MSB 
    181           		offset |= *(buf+1+rlb+1);			// topic UTF LSB 
    182           		offset += (1+rlb+2);				// fixed header + topic size 
   \   0000001A   0x1930             ADDS     R0,R6,R4
   \   0000001C   0x7880             LDRB     R0,[R0, #+2]
   \   0000001E   0x1830             ADDS     R0,R6,R0
   \   00000020   0x1CC7             ADDS     R7,R0,#+3
    183           
    184           
    185           		if(MQTTParseMessageQos(buf)) { 
   \   00000022   0x7820             LDRB     R0,[R4, #+0]
   \   00000024   0xB2FF             UXTB     R7,R7
   \   00000026   0xF3C0 0x0041      UBFX     R0,R0,#+1,#+2
   \   0000002A   0xB108             CBZ.N    R0,??mqtt_parse_pub_msg_ptr_1
    186           			offset += 2;					// add two bytes of msg id 
   \   0000002C   0x1CBF             ADDS     R7,R7,#+2
   \   0000002E   0xB2FF             UXTB     R7,R7
    187           		} 
    188           
    189           
    190           		*msg_ptr = (buf + offset); 
   \                     ??mqtt_parse_pub_msg_ptr_1:
   \   00000030   0x1938             ADDS     R0,R7,R4
   \   00000032   0x6028             STR      R0,[R5, #+0]
    191           				 
    192           		// offset is now pointing to start of message 
    193           		// length of the message is remaining length - variable header 
    194           		// variable header is offset - fixed header 
    195           		// fixed header is 1 + rlb 
    196           		// so, lom = remlen - (offset - (1+rlb)) 
    197                 	len = mqtt_parse_rem_len(buf) - (offset-(rlb+1)); 
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       mqtt_parse_rem_len
   \   0000003A   0x1BC0             SUBS     R0,R0,R7
   \   0000003C   0x1830             ADDS     R0,R6,R0
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \   00000040   0xE000             B.N      ??mqtt_parse_pub_msg_ptr_2
    198           	} else { 
    199           		*msg_ptr = NULL; 
   \                     ??mqtt_parse_pub_msg_ptr_0:
   \   00000042   0x6028             STR      R0,[R5, #+0]
    200           	} 
    201           	return len; 
   \                     ??mqtt_parse_pub_msg_ptr_2:
   \   00000044   0xB280             UXTH     R0,R0
   \   00000046   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    202           } 
    203           
    204           

   \                                 In section .text, align 2, keep-with-next
    205           void mqtt_init(mqtt_broker_handle_t* broker, const char* clientid) { 
   \                     mqtt_init:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    206           	// Connection options 
    207           	broker->alive = 300; // 300 seconds = 5 minutes 
   \   00000004   0xF104 0x0640      ADD      R6,R4,#+64
   \   00000008   0xF44F 0x7096      MOV      R0,#+300
   \   0000000C   0x8270             STRH     R0,[R6, #+18]
   \   0000000E   0x460D             MOV      R5,R1
    208           	broker->seq = 1; // Sequency for message indetifiers 
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x8230             STRH     R0,[R6, #+16]
    209           	// Client options 
    210           	//memset(broker->clientid, 0, sizeof(broker->clientid)); 
    211           	//memset(broker->username, 0, sizeof(broker->username)); 
    212           	//memset(broker->password, 0, sizeof(broker->password)); 
    213           	if(clientid) { 
   \   00000014   0xB145             CBZ.N    R5,??mqtt_init_0
    214           		//strncpy(broker->clientid, clientid, sizeof(broker->clientid));
    215          	    memcpy(broker->clientid,clientid,strlen(clientid));
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       strlen
   \   0000001C   0x4602             MOV      R2,R0
   \   0000001E   0x6C20             LDR      R0,[R4, #+64]
   \   00000020   0x4629             MOV      R1,R5
   \   00000022   0x.... 0x....      BL       memcpy
   \   00000026   0xE005             B.N      ??mqtt_init_1
    216           	} else { 
    217           		strcpy(broker->clientid, "emqtt"); 
   \                     ??mqtt_init_0:
   \   00000028   0x6C20             LDR      R0,[R4, #+64]
   \   0000002A   0x.... 0x....      ADR.W    R1,`?<Constant "emqtt">`
   \   0000002E   0x2206             MOVS     R2,#+6
   \   00000030   0x.... 0x....      BL       __aeabi_memcpy
    218           	} 
    219           	// Will topic 
    220           	broker->clean_session = 1; 
   \                     ??mqtt_init_1:
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x73B0             STRB     R0,[R6, #+14]
    221           } 
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
    222           
    223           

   \                                 In section .text, align 2, keep-with-next
    224           void mqtt_init_auth(mqtt_broker_handle_t* broker, const char* username, const char* password) { 
   \                     mqtt_init_auth:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x4616             MOV      R6,R2
    225           	if(username && username[0] != '\0') 
   \   00000008   0xBF1C             ITT      NE 
   \   0000000A   0x7828             LDRBNE   R0,[R5, #+0]
   \   0000000C   0x2800             CMPNE    R0,#+0
   \   0000000E   0xD007             BEQ.N    ??mqtt_init_auth_0
    226           		//strncpy(broker->username, username, sizeof(broker->username)-1); 
    227          	    memcpy(broker->username,username,strlen(username));
   \   00000010   0x4628             MOV      R0,R5
   \   00000012   0x.... 0x....      BL       strlen
   \   00000016   0x4602             MOV      R2,R0
   \   00000018   0x6C60             LDR      R0,[R4, #+68]
   \   0000001A   0x4629             MOV      R1,R5
   \   0000001C   0x.... 0x....      BL       memcpy
    228           	if(password && password[0] != '\0') 
   \                     ??mqtt_init_auth_0:
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xBF1C             ITT      NE 
   \   00000024   0x7830             LDRBNE   R0,[R6, #+0]
   \   00000026   0x2800             CMPNE    R0,#+0
   \   00000028   0xD009             BEQ.N    ??mqtt_init_auth_1
    229           		//strncpy(broker->password, password, sizeof(broker->password)-1);
    230          	    memcpy(broker->password,password,strlen(password));
   \   0000002A   0x4630             MOV      R0,R6
   \   0000002C   0x.... 0x....      BL       strlen
   \   00000030   0x4602             MOV      R2,R0
   \   00000032   0x6CA0             LDR      R0,[R4, #+72]
   \   00000034   0x4631             MOV      R1,R6
   \   00000036   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000003A   0x.... 0x....      B.W      memcpy
    231           } 
   \                     ??mqtt_init_auth_1:
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return
    232           
    233           

   \                                 In section .text, align 2, keep-with-next
    234           void mqtt_set_alive(mqtt_broker_handle_t* broker, UINT16 alive) { 
    235           	broker->alive = alive; 
   \                     mqtt_set_alive:
   \   00000000   0xF8A0 0x1052      STRH     R1,[R0, #+82]
    236           } 
   \   00000004   0x4770             BX       LR               ;; return
    237           
    238           

   \                                 In section .text, align 2, keep-with-next
    239           UINT8 mqtt_connect(mqtt_broker_handle_t* broker) 
    240           { 
   \                     mqtt_connect:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
    241               UINT8 fixedHeaderSize = 0; 
    242               UINT8 fixed_header[3]; 
    243               UINT8 remainLen = 0; 
    244           	 UINT8 flags = 0x00; 
    245               UINT8 var_header[12] =  
    246               { 
    247                   0x00,0x06,0x4d,0x51,0x49,0x73,0x64,0x70, // Protocol name: MQIsdp 
    248           		0x03, // Protocol version 
    249                   0x00, // Connect flags 
    250                   0x00, // Keep alive LSB 
    251                   0x00  // Keep alive MSB 
    252               }; 
   \   00000006   0x.... 0x....      ADR.W    R1,`?<Constant {0, 6, 77, 81, 73, 115, 100, 112, 3`
   \   0000000A   0xC92C             LDM      R1!,{R2,R3,R5}
   \   0000000C   0x4604             MOV      R4,R0
   \   0000000E   0xA802             ADD      R0,SP,#+8
   \   00000010   0xF04F 0x0900      MOV      R9,#+0
   \   00000014   0xC02C             STM      R0!,{R2,R3,R5}
    253                
    254           	UINT16 offset = 0; 
    255               UINT16 packetSize = 0; 
    256           	UINT8 *packet = NULL; 
    257           	UINT16 clientidlen = strlen(broker->clientid); 
   \   00000016   0xF104 0x053C      ADD      R5,R4,#+60
   \   0000001A   0x6868             LDR      R0,[R5, #+4]
   \   0000001C   0x.... 0x....      BL       strlen
   \   00000020   0xB286             UXTH     R6,R0
    258           	UINT16 usernamelen = strlen(broker->username); 
   \   00000022   0x68A8             LDR      R0,[R5, #+8]
   \   00000024   0x.... 0x....      BL       strlen
   \   00000028   0xB287             UXTH     R7,R0
    259           	UINT16 passwordlen = strlen(broker->password); 
   \   0000002A   0x68E8             LDR      R0,[R5, #+12]
   \   0000002C   0x.... 0x....      BL       strlen
   \   00000030   0xFA1F 0xF880      UXTH     R8,R0
    260           	UINT16 payload_len = clientidlen + 2; 
   \   00000034   0x1CB0             ADDS     R0,R6,#+2
   \   00000036   0xB280             UXTH     R0,R0
    261           
    262          
    263           	// Preparing the flags 
    264           	if(usernamelen)  
   \   00000038   0xB127             CBZ.N    R7,??mqtt_connect_0
    265               { 
    266           		payload_len += usernamelen + 2; 
   \   0000003A   0x1838             ADDS     R0,R7,R0
   \   0000003C   0x1C80             ADDS     R0,R0,#+2
   \   0000003E   0xB280             UXTH     R0,R0
    267           		flags |= MQTT_USERNAME_FLAG; 
   \   00000040   0xF04F 0x0980      MOV      R9,#+128
    268           	} 
    269                
    270           	if(passwordlen)  
   \                     ??mqtt_connect_0:
   \   00000044   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000048   0xD004             BEQ.N    ??mqtt_connect_1
    271               { 
    272           		payload_len += passwordlen + 2; 
   \   0000004A   0x4440             ADD      R0,R8,R0
   \   0000004C   0x1C80             ADDS     R0,R0,#+2
   \   0000004E   0xB280             UXTH     R0,R0
    273           		flags |= MQTT_PASSWORD_FLAG; 
   \   00000050   0xF049 0x0940      ORR      R9,R9,#0x40
    274           	} 
    275                
    276           	if(broker->clean_session)  
   \                     ??mqtt_connect_1:
   \   00000054   0x7CA9             LDRB     R1,[R5, #+18]
   \   00000056   0xB109             CBZ.N    R1,??mqtt_connect_2
    277               { 
    278           		flags |= MQTT_CLEAN_SESSION; 
   \   00000058   0xF049 0x0902      ORR      R9,R9,#0x2
    279           	} 
    280           
    281          
    282           	// Variable header 
    283           	var_header[9] = flags; // Connect flags 
   \                     ??mqtt_connect_2:
   \   0000005C   0xF88D 0x9011      STRB     R9,[SP, #+17]
    284               var_header[10] = broker->alive>>8;   // Keep alive LSB 
    285               var_header[11] = broker->alive&0xFF; // Keep alive MSB 
    286           
    287          
    288           
    289          
    290              	// Fixed header 
    291               fixedHeaderSize = 2;    // Default size = one byte Message Type + one byte Remaining Length 
   \   00000060   0xF04F 0x0B02      MOV      R11,#+2
   \   00000064   0x8AE9             LDRH     R1,[R5, #+22]
   \   00000066   0x0A09             LSRS     R1,R1,#+8
   \   00000068   0xF88D 0x1012      STRB     R1,[SP, #+18]
    292               // Message Type 
    293               fixed_header[0] = MQTT_MSG_CONNECT; 
    294               // Remaining Length 
    295               remainLen = sizeof(var_header)+payload_len; 
    296               if (remainLen <= 127)  
   \   0000006C   0xAA01             ADD      R2,SP,#+4
   \   0000006E   0x8AE9             LDRH     R1,[R5, #+22]
   \   00000070   0xF88D 0x1013      STRB     R1,[SP, #+19]
   \   00000074   0x2110             MOVS     R1,#+16
   \   00000076   0xF88D 0x1004      STRB     R1,[SP, #+4]
   \   0000007A   0xF100 0x010C      ADD      R1,R0,#+12
   \   0000007E   0xB2C9             UXTB     R1,R1
   \   00000080   0x2980             CMP      R1,#+128
   \   00000082   0xBFB8             IT       LT 
   \   00000084   0x7051             STRBLT   R1,[R2, #+1]
    297               { 
    298                   fixed_header[1] = remainLen; 
   \   00000086   0xDB06             BLT.N    ??mqtt_connect_3
    299               } 
    300               else 
    301               { 
    302                   fixedHeaderSize++;          // add an additional byte for Remaining Length 
    303                   // first byte is remainder (mod) of 128, then set the MSB to indicate more bytes 
    304                   fixed_header[1] = remainLen % 128; 
    305                   fixed_header[1] = fixed_header[1] | 0x80; 
   \   00000088   0xF041 0x0380      ORR      R3,R1,#0x80
    306                   // second byte is number of 128s 
    307                   fixed_header[2] = remainLen / 128; 
   \   0000008C   0x09C9             LSRS     R1,R1,#+7
   \   0000008E   0xF04F 0x0B03      MOV      R11,#+3
   \   00000092   0x7053             STRB     R3,[R2, #+1]
   \   00000094   0x7091             STRB     R1,[R2, #+2]
   \                     ??mqtt_connect_3:
   \   00000096   0x4458             ADD      R0,R0,R11
   \   00000098   0x300C             ADDS     R0,R0,#+12
   \   0000009A   0xFA1F 0xF980      UXTH     R9,R0
    308               } 
    309                
    310           
    311          
    312               offset = 0; 
    313               packetSize = fixedHeaderSize+sizeof(var_header)+payload_len; 
    314               //packet = (UINT8*)_mem_alloc_zero(packetSize);
    315               //packet = (UINT8 *)malloc(packetSize);
    316          	 while(1)
    317          	 {
    318          	 	packet = (UINT8 *)gsn_malloc(packetSize);
   \                     ??mqtt_connect_4:
   \   0000009E   0x2200             MOVS     R2,#+0
   \   000000A0   0xF44F 0x719F      MOV      R1,#+318
   \   000000A4   0x4648             MOV      R0,R9
   \   000000A6   0x.... 0x....      BL       GsnDynMemMgmt_Alloc
   \   000000AA   0xEA5F 0x0A00      MOVS     R10,R0
    319               	if(packet == NULL)
   \   000000AE   0xD0F6             BEQ.N    ??mqtt_connect_4
    320          		  continue;
    321          		else
    322          		{
    323          			memset(packet, 0, packetSize);
   \   000000B0   0x464A             MOV      R2,R9
   \   000000B2   0x.... 0x....      BL       ??Subroutine8_0
    324          			break;
    325          		}
    326          	 }
    327               if (packet == NULL) 
    328               {
    329          	     S2w_Printf("\r\n CONNECT PACKET is NULL");
    330                   goto error; 
    331               } 
    332           	memcpy(packet, fixed_header, fixedHeaderSize); 
   \                     ??CrossCallReturnLabel_12:
   \   000000B6   0x465A             MOV      R2,R11
   \   000000B8   0xA901             ADD      R1,SP,#+4
   \   000000BA   0x4650             MOV      R0,R10
   \   000000BC   0x.... 0x....      BL       memcpy
    333           	offset += fixedHeaderSize; 
    334           	memcpy(packet+offset, var_header, sizeof(var_header)); 
   \   000000C0   0x220C             MOVS     R2,#+12
   \   000000C2   0xA902             ADD      R1,SP,#+8
   \   000000C4   0xEB0B 0x000A      ADD      R0,R11,R10
   \   000000C8   0x.... 0x....      BL       memcpy
    335           	offset += sizeof(var_header); 
   \   000000CC   0xF10B 0x000C      ADD      R0,R11,#+12
    336           	// Client ID - UTF encoded 
    337           	packet[offset++] = clientidlen>>8; 
   \   000000D0   0xB280             UXTH     R0,R0
   \   000000D2   0x0A31             LSRS     R1,R6,#+8
   \   000000D4   0x.... 0x....      BL       ?Subroutine9
    338           	packet[offset++] = clientidlen&0xFF; 
    339           	memcpy(packet+offset, broker->clientid, clientidlen); 
   \                     ??CrossCallReturnLabel_15:
   \   000000D8   0x4632             MOV      R2,R6
   \   000000DA   0xF800 0x600A      STRB     R6,[R0, R10]
   \   000000DE   0x1C40             ADDS     R0,R0,#+1
   \   000000E0   0x6869             LDR      R1,[R5, #+4]
   \   000000E2   0xFA1F 0xFB80      UXTH     R11,R0
   \   000000E6   0xEB0B 0x000A      ADD      R0,R11,R10
   \   000000EA   0x.... 0x....      BL       memcpy
    340           	offset += clientidlen; 
   \   000000EE   0xEB06 0x000B      ADD      R0,R6,R11
    341           
    342          
    343           	if(usernamelen) { 
   \   000000F2   0xB177             CBZ.N    R7,??mqtt_connect_5
    344           		// Username - UTF encoded 
    345           		packet[offset++] = usernamelen>>8; 
   \   000000F4   0xB280             UXTH     R0,R0
   \   000000F6   0x0A39             LSRS     R1,R7,#+8
   \   000000F8   0x.... 0x....      BL       ?Subroutine9
    346           		packet[offset++] = usernamelen&0xFF; 
   \                     ??CrossCallReturnLabel_16:
   \   000000FC   0x1C46             ADDS     R6,R0,#+1
   \   000000FE   0xF800 0x700A      STRB     R7,[R0, R10]
    347           		memcpy(packet+offset, broker->username, usernamelen); 
   \   00000102   0xB2B6             UXTH     R6,R6
   \   00000104   0x68A9             LDR      R1,[R5, #+8]
   \   00000106   0x463A             MOV      R2,R7
   \   00000108   0xEB06 0x000A      ADD      R0,R6,R10
   \   0000010C   0x.... 0x....      BL       memcpy
    348           		offset += usernamelen; 
   \   00000110   0x19B8             ADDS     R0,R7,R6
    349           	} 
    350           
    351          
    352           	if(passwordlen) { 
   \                     ??mqtt_connect_5:
   \   00000112   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000116   0xD00D             BEQ.N    ??mqtt_connect_6
    353           		// Password - UTF encoded 
    354           		packet[offset++] = passwordlen>>8; 
   \   00000118   0xB280             UXTH     R0,R0
   \   0000011A   0xEA4F 0x2118      LSR      R1,R8,#+8
   \   0000011E   0x.... 0x....      BL       ?Subroutine9
    355           		packet[offset++] = passwordlen&0xFF; 
    356           		memcpy(packet+offset, broker->password, passwordlen); 
   \                     ??CrossCallReturnLabel_17:
   \   00000122   0x4642             MOV      R2,R8
   \   00000124   0xF800 0x800A      STRB     R8,[R0, R10]
   \   00000128   0x1C40             ADDS     R0,R0,#+1
   \   0000012A   0x68E9             LDR      R1,[R5, #+12]
   \   0000012C   0xB280             UXTH     R0,R0
   \   0000012E   0x4450             ADD      R0,R0,R10
   \   00000130   0x.... 0x....      BL       memcpy
    357           		offset += passwordlen; 
    358           	} 
    359           
    360          
    361           	// Send the packet 
    362          	
    363            	if( AppS2wHal_NetTx(broker->mqtt_cid, broker->mqtt_peerData.ipAddr, broker->mqtt_peerData.port, packet, packetSize) != 0 )
   \                     ??mqtt_connect_6:
   \   00000134   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   00000138   0x8862             LDRH     R2,[R4, #+2]
   \   0000013A   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \   0000013E   0x4653             MOV      R3,R10
   \   00000140   0x1D21             ADDS     R1,R4,#+4
   \   00000142   0x.... 0x....      BL       AppS2wHal_NetTx
   \   00000146   0xB920             CBNZ.N   R0,??mqtt_connect_7
    364                  {
    365                    goto error; 
    366           	} 
    367          	//broker->send(broker->socket_info, packet, packetSize);
    368          	//free(packet);
    369          	if (packet != NULL) 
    370               { 
    371                 //free(packet);
    372          	   gsn_free(packet);
   \   00000148   0x4650             MOV      R0,R10
   \   0000014A   0x.... 0x....      BL       GsnDynMemMgmt_Free
    373          	   packet=NULL;
    374               } 
    375           	return 0; 
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0xE007             B.N      ??mqtt_connect_8
    376           error: 
    377               S2w_Printf("\r\n connect Error");
   \                     ??mqtt_connect_7:
   \   00000152   0x.... 0x....      ADR.W    R0,`?<Constant "\\r\\n connect Error">`
   \   00000156   0x.... 0x....      BL       S2w_Printf
    378               if (packet != NULL) 
    379               { 
    380                 //free(packet);
    381          	   gsn_free(packet);
   \   0000015A   0x4650             MOV      R0,R10
   \   0000015C   0x.... 0x....      BL       GsnDynMemMgmt_Free
    382          	   packet=NULL;
    383               } 
    384          
    385               return  1; 
   \   00000160   0x2001             MOVS     R0,#+1
   \                     ??mqtt_connect_8:
   \   00000162   0x....             B.N      ?Subroutine3
    386           } 

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9:
   \   00000000   0xF800 0x100A      STRB     R1,[R0, R10]
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   \   00000006   0xB280             UXTH     R0,R0
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   0xB005             ADD      SP,SP,#+20
   \   00000002   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8:
   \   00000000   0x4607             MOV      R7,R0
   \   00000002   0x4632             MOV      R2,R6
   \                     ??Subroutine8_0:
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x.... 0x....      B.W      memset
    387           
    388          

   \                                 In section .text, align 2, keep-with-next
    389           int mqtt_disconnect(mqtt_broker_handle_t* broker)  
    390           { 
   \                     mqtt_disconnect:
   \   00000000   0xB500             PUSH     {LR}
    391           	UINT8 packet[] =  
    392               { 
    393           		MQTT_MSG_DISCONNECT, // Message Type, DUP flag, QoS level, Retain 
    394           		0x00 // Remaining length 
    395           	}; 
   \   00000002   0x.... 0x....      ADR.W    R1,`?<Constant {224, 0}>`
   \   00000006   0x8809             LDRH     R1,[R1, #+0]
   \   00000008   0xB083             SUB      SP,SP,#+12
    396           
    397          
    398           	// Send the packet 
    399          	
    400               if( AppS2wHal_NetTx(broker->mqtt_cid, broker->mqtt_peerData.ipAddr, broker->mqtt_peerData.port, packet, sizeof(packet) != 0 ))
   \   0000000A   0xAB01             ADD      R3,SP,#+4
   \   0000000C   0xF8AD 0x1004      STRH     R1,[SP, #+4]
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x9100             STR      R1,[SP, #+0]
   \   00000014   0x1D01             ADDS     R1,R0,#+4
   \   00000016   0x8842             LDRH     R2,[R0, #+2]
   \   00000018   0xF890 0x003C      LDRB     R0,[R0, #+60]
   \   0000001C   0x.... 0x....      BL       AppS2wHal_NetTx
   \   00000020   0xB100             CBZ.N    R0,??mqtt_disconnect_0
    401               { 
    402           		return 1; 
   \   00000022   0x2001             MOVS     R0,#+1
    403           	 } 
    404           	//broker->send(broker->socket_info,packet,sizeof(packet));
    405          
    406           	return 0; 
   \                     ??mqtt_disconnect_0:
   \   00000024   0xBD0E             POP      {R1-R3,PC}       ;; return
    407           } 
    408           
    409          

   \                                 In section .text, align 2, keep-with-next
    410           int mqtt_ping(mqtt_broker_handle_t* broker)  
    411           { 
    412           	UINT8 packet[] =  
    413               { 
    414           		MQTT_MSG_PINGREQ, // Message Type, DUP flag, QoS level, Retain 
    415           		0x00 // Remaining length 
    416           	}; 
    417           
    418          
    419           	// Send the packet 
    420           	/*if(broker->send(broker->socket_info, packet, sizeof(packet)) < sizeof(packet))  
    421               { 
    422           		return -1; 
    423           	} */
    424           
    425          
    426           	return 0; 
   \                     mqtt_ping:
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    427           } 
    428           
    429          
    430           /*int mqtt_publish(mqtt_broker_handle_t* broker, const char* topic, const char* msg, UINT8 retain)  
    431           { 
    432           	return mqtt_publish_with_qos(broker, topic, msg, retain, 0, NULL); 
    433           } */
    434           
    435          

   \                                 In section .text, align 2, keep-with-next
    436           UINT8 mqtt_publish_with_qos(mqtt_broker_handle_t* broker, const char* topic, const char* msg, UINT8 retain, UINT8 qos, UINT16* message_id)  
    437           { 
   \                     mqtt_publish_with_qos:
   \   00000000   0xE92D 0x4FF6      PUSH     {R1,R2,R4-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0xB083             SUB      SP,SP,#+12
   \   00000008   0x461D             MOV      R5,R3
    438           	UINT8 fixedHeaderSize = 0; 
    439           	UINT16 remainLen = 0; 
    440              UINT16 packetLen = 0; 
    441           	UINT8 *packet = NULL; 
    442           	UINT16 topiclen = strlen(topic); 
   \   0000000A   0x4608             MOV      R0,R1
   \   0000000C   0x.... 0x....      BL       strlen
   \   00000010   0xB286             UXTH     R6,R0
    443           	UINT16 msglen = strlen(msg); 
   \   00000012   0x9804             LDR      R0,[SP, #+16]
   \   00000014   0x.... 0x....      BL       strlen
   \   00000018   0x4683             MOV      R11,R0
    444              UINT16 var_header_len = 0;  
    445           	UINT8 *var_header = NULL; 
    446           	UINT8 fixed_header[3]; 
    447          
    448          
    449           	UINT8 qos_flag = MQTT_QOS0_FLAG; 
    450           	UINT8 qos_size = 0; // No QoS included 
   \   0000001A   0x980E             LDR      R0,[SP, #+56]
   \   0000001C   0x2400             MOVS     R4,#+0
   \   0000001E   0xF04F 0x0900      MOV      R9,#+0
    451                
    452           	if(qos == 1)  
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD102             BNE.N    ??mqtt_publish_with_qos_0
    453               { 
    454           		qos_size = 2; // 2 bytes for QoS 
   \   00000026   0x2402             MOVS     R4,#+2
    455           		qos_flag = MQTT_QOS1_FLAG; 
   \   00000028   0x46A1             MOV      R9,R4
   \   0000002A   0xE004             B.N      ??mqtt_publish_with_qos_1
    456           	} 
    457           	else if(qos == 2)  
   \                     ??mqtt_publish_with_qos_0:
   \   0000002C   0x2802             CMP      R0,#+2
   \   0000002E   0xBF04             ITT      EQ 
   \   00000030   0x2402             MOVEQ    R4,#+2
   \   00000032   0xF04F 0x0904      MOVEQ    R9,#+4
    458               { 
    459           		qos_size = 2; // 2 bytes for QoS 
    460           		qos_flag = MQTT_QOS2_FLAG; 
    461           	} 
    462           
    463          
    464           	// Variable header 
    465               var_header_len = topiclen+2+qos_size; // Topic size (2 bytes), utf-encoded topic 
   \                     ??mqtt_publish_with_qos_1:
   \   00000036   0x19A0             ADDS     R0,R4,R6
   \   00000038   0x1C80             ADDS     R0,R0,#+2
   \   0000003A   0xFA1F 0xFA80      UXTH     R10,R0
    466               //var_header =(UINT8*)_mem_alloc(var_header_len);
    467               //var_header = (UINT8*)malloc(var_header_len);
    468          	while(1)
    469          	{
    470          		var_header = (UINT8*)gsn_malloc(var_header_len);
   \                     ??mqtt_publish_with_qos_2:
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0xF44F 0x71EB      MOV      R1,#+470
   \   00000044   0x4650             MOV      R0,R10
   \   00000046   0x.... 0x....      BL       GsnDynMemMgmt_Alloc
   \   0000004A   0x0007             MOVS     R7,R0
    471          		if(var_header == NULL)
   \   0000004C   0xD0F7             BEQ.N    ??mqtt_publish_with_qos_2
    472          		  continue;
    473          		else
    474          		{
    475          		  memset(var_header,0,var_header_len);
   \   0000004E   0x4652             MOV      R2,R10
   \   00000050   0x.... 0x....      BL       ??Subroutine8_0
    476          		  
    477          		  break;
    478          		}
    479          	}
    480                 
    481               if (var_header == NULL) 
    482               { 
    483          	     S2w_Printf("\r\n PUBLISH VAILD HEADER is NULL");
    484                   goto error; 
    485               } 
    486           	var_header[0] = topiclen>>8; 
   \                     ??CrossCallReturnLabel_11:
   \   00000054   0x0A30             LSRS     R0,R6,#+8
   \   00000056   0x7038             STRB     R0,[R7, #+0]
    487           	var_header[1] = topiclen&0xFF; 
   \   00000058   0x707E             STRB     R6,[R7, #+1]
    488           	memcpy(var_header+2, topic, topiclen); 
   \   0000005A   0x4632             MOV      R2,R6
   \   0000005C   0x9903             LDR      R1,[SP, #+12]
   \   0000005E   0x1CB8             ADDS     R0,R7,#+2
   \   00000060   0x.... 0x....      BL       memcpy
    489           	if(qos_size)  
   \   00000064   0xF108 0x003C      ADD      R0,R8,#+60
   \   00000068   0xB164             CBZ.N    R4,??mqtt_publish_with_qos_3
    490               { 
    491           		var_header[topiclen+2] = broker->seq>>8; 
   \   0000006A   0x8A82             LDRH     R2,[R0, #+20]
   \   0000006C   0x19F1             ADDS     R1,R6,R7
   \   0000006E   0x0A12             LSRS     R2,R2,#+8
   \   00000070   0x708A             STRB     R2,[R1, #+2]
    492           		var_header[topiclen+3] = broker->seq&0xFF; 
   \   00000072   0x8A82             LDRH     R2,[R0, #+20]
   \   00000074   0x70CA             STRB     R2,[R1, #+3]
   \   00000076   0x990F             LDR      R1,[SP, #+60]
    493           		if(message_id) // Returning message id 
   \   00000078   0xB109             CBZ.N    R1,??mqtt_publish_with_qos_4
    494                   {  
    495           			*message_id = broker->seq; 
   \   0000007A   0x8A82             LDRH     R2,[R0, #+20]
   \   0000007C   0x800A             STRH     R2,[R1, #+0]
    496           		} 
    497           		broker->seq ++;
   \                     ??mqtt_publish_with_qos_4:
   \   0000007E   0x8A81             LDRH     R1,[R0, #+20]
   \   00000080   0x1C49             ADDS     R1,R1,#+1
   \   00000082   0x8281             STRH     R1,[R0, #+20]
    498           	} 
    499                  broker->seq = broker->seq % 128;
    500          
    501           	// Fixed header 
    502           	// the remaining length is one byte for messages up to 127 bytes, then two bytes after that 
    503           	// actually, it can be up to 4 bytes but I'm making the assumption the embedded device will only 
    504           	// need up to two bytes of length (handles up to 16,383 (almost 16k) sized message) 
    505           	fixedHeaderSize = 2;    // Default size = one byte Message Type + one byte Remaining Length 
   \                     ??mqtt_publish_with_qos_3:
   \   00000084   0x2602             MOVS     R6,#+2
   \   00000086   0x7D01             LDRB     R1,[R0, #+20]
   \   00000088   0xF001 0x017F      AND      R1,R1,#0x7F
   \   0000008C   0x8281             STRH     R1,[R0, #+20]
    506               // Message Type, DUP flag, QoS level, Retain 
    507               fixed_header[0] = MQTT_MSG_PUBLISH | qos_flag; 
   \   0000008E   0xF049 0x0030      ORR      R0,R9,#0x30
   \   00000092   0xF88D 0x0004      STRB     R0,[SP, #+4]
    508           	if(retain)  
   \   00000096   0xB12D             CBZ.N    R5,??mqtt_publish_with_qos_5
    509               { 
    510           		fixed_header[0] |= MQTT_RETAIN_FLAG; 
   \   00000098   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000009C   0xF040 0x0001      ORR      R0,R0,#0x1
   \   000000A0   0xF88D 0x0004      STRB     R0,[SP, #+4]
    511               } 
    512                
    513           	remainLen = var_header_len+msglen; 
   \                     ??mqtt_publish_with_qos_5:
   \   000000A4   0xEB0B 0x000A      ADD      R0,R11,R10
   \   000000A8   0xB280             UXTH     R0,R0
    514               // Remaining Length 
    515               if (remainLen <= 127)  
   \   000000AA   0xA901             ADD      R1,SP,#+4
   \   000000AC   0x2880             CMP      R0,#+128
   \   000000AE   0xBFB8             IT       LT 
   \   000000B0   0x7048             STRBLT   R0,[R1, #+1]
    516               { 
    517                   fixed_header[1] = remainLen; 
   \   000000B2   0xDB05             BLT.N    ??mqtt_publish_with_qos_6
    518               }  
    519               else  
    520              { 
    521                   fixedHeaderSize++;          // add an additional byte for Remaining Length 
    522                
    523                   // first byte is remainder (mod) of 128, then set the MSB to indicate more bytes 
    524                   fixed_header[1] = remainLen % 128; 
    525                   fixed_header[1] = fixed_header[1] | 0x80; 
   \   000000B4   0xF040 0x0280      ORR      R2,R0,#0x80
    526                   // second byte is number of 128s 
    527                   fixed_header[2] = remainLen / 128; 
   \   000000B8   0x09C0             LSRS     R0,R0,#+7
   \   000000BA   0x2603             MOVS     R6,#+3
   \   000000BC   0x704A             STRB     R2,[R1, #+1]
   \   000000BE   0x7088             STRB     R0,[R1, #+2]
    528               } 
    529           
    530          
    531               packetLen = fixedHeaderSize+var_header_len+msglen; 
   \                     ??mqtt_publish_with_qos_6:
   \   000000C0   0xEB0A 0x0006      ADD      R0,R10,R6
   \   000000C4   0xEB0B 0x0500      ADD      R5,R11,R0
   \   000000C8   0xB2AD             UXTH     R5,R5
    532               //packet = (UINT8*)_mem_alloc(packetLen);
    533               //packet = (UINT8*)malloc(packetLen);
    534          	 while(1)
    535          	 {
    536               	packet = (UINT8*)gsn_malloc(packetLen);
   \                     ??mqtt_publish_with_qos_7:
   \   000000CA   0x2200             MOVS     R2,#+0
   \   000000CC   0xF44F 0x7106      MOV      R1,#+536
   \   000000D0   0x4628             MOV      R0,R5
   \   000000D2   0x.... 0x....      BL       GsnDynMemMgmt_Alloc
   \   000000D6   0x0004             MOVS     R4,R0
    537          	 	if(packet == NULL)
   \   000000D8   0xD0F7             BEQ.N    ??mqtt_publish_with_qos_7
    538          		  continue;
    539          		else
    540          		{
    541          			memset(packet,0,packetLen);
   \   000000DA   0x462A             MOV      R2,R5
   \   000000DC   0x.... 0x....      BL       ??Subroutine8_0
    542          			break;
    543          		}
    544               }
    545          	  if (packet == NULL) 
    546               { 
    547          		 S2w_Printf("\r\n PUBLISH PACKET is NULL");
    548                   goto error; 
    549               } 
    550           	memcpy(packet, fixed_header, fixedHeaderSize); 
   \                     ??CrossCallReturnLabel_10:
   \   000000E0   0x4632             MOV      R2,R6
   \   000000E2   0xA901             ADD      R1,SP,#+4
   \   000000E4   0x4620             MOV      R0,R4
   \   000000E6   0x.... 0x....      BL       memcpy
    551           	memcpy(packet+fixedHeaderSize, var_header, var_header_len); 
   \   000000EA   0x1936             ADDS     R6,R6,R4
   \   000000EC   0x4652             MOV      R2,R10
   \   000000EE   0x4639             MOV      R1,R7
   \   000000F0   0x4630             MOV      R0,R6
   \   000000F2   0x.... 0x....      BL       memcpy
    552           	memcpy(packet+fixedHeaderSize+var_header_len, msg, msglen); 
   \   000000F6   0x9904             LDR      R1,[SP, #+16]
   \   000000F8   0xFA1F 0xF28B      UXTH     R2,R11
   \   000000FC   0xEB0A 0x0006      ADD      R0,R10,R6
   \   00000100   0x.... 0x....      BL       memcpy
    553           
    554          
    555           	// Send the packet 
    556          	if( AppS2wHal_NetTx(broker->mqtt_cid, broker->mqtt_peerData.ipAddr, broker->mqtt_peerData.port, packet, packetLen) != 0 )
   \   00000104   0x9500             STR      R5,[SP, #+0]
   \   00000106   0xF8B8 0x2002      LDRH     R2,[R8, #+2]
   \   0000010A   0xF898 0x003C      LDRB     R0,[R8, #+60]
   \   0000010E   0x4623             MOV      R3,R4
   \   00000110   0xF108 0x0104      ADD      R1,R8,#+4
   \   00000114   0x.... 0x....      BL       AppS2wHal_NetTx
   \   00000118   0xB938             CBNZ.N   R0,??mqtt_publish_with_qos_8
    557              { 
    558                   goto error; 
    559           	} 
    560          	//broker->send(broker->socket_info,packet,packetLen);
    561              //free(var_header);
    562          	if (var_header != NULL) 
    563               { 
    564                 //free(var_header);
    565          	   gsn_free(var_header);
   \   0000011A   0x4638             MOV      R0,R7
   \   0000011C   0x.... 0x....      BL       GsnDynMemMgmt_Free
    566          	   var_header = NULL;
    567               } 
    568          	//free(packet);
    569          	if (packet != NULL) 
    570               { 
    571                 //free(packet);
    572          	   gsn_free(packet);
   \   00000120   0x4620             MOV      R0,R4
   \   00000122   0x.... 0x....      BL       GsnDynMemMgmt_Free
    573          	   packet = NULL;
    574               } 
    575          	
    576           	return 0; 
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0xE00A             B.N      ??mqtt_publish_with_qos_9
    577           error: 
    578             S2w_Printf("\r\n publish Error");    
   \                     ??mqtt_publish_with_qos_8:
   \   0000012A   0x.... 0x....      ADR.W    R0,`?<Constant "\\r\\n publish Error">`
   \   0000012E   0x.... 0x....      BL       S2w_Printf
    579               if (var_header != NULL) 
    580               { 
    581                 //free(var_header);
    582          	   gsn_free(var_header);
   \   00000132   0x4638             MOV      R0,R7
   \   00000134   0x.... 0x....      BL       GsnDynMemMgmt_Free
    583          	   var_header = NULL;
    584               } 
    585                
    586               if (packet != NULL) 
    587               { 
    588                 //free(packet);
    589          	   gsn_free(packet);
   \   00000138   0x4620             MOV      R0,R4
   \   0000013A   0x.... 0x....      BL       GsnDynMemMgmt_Free
    590          	   packet = NULL;
    591               } 
    592                
    593               return  1; 
   \   0000013E   0x2001             MOVS     R0,#+1
   \                     ??mqtt_publish_with_qos_9:
   \   00000140                      REQUIRE ?Subroutine3
   \   00000140                      ;; // Fall through to label ?Subroutine3
    594           } 
    595           
    596          

   \                                 In section .text, align 2, keep-with-next
    597           int mqtt_pubrel(mqtt_broker_handle_t* broker, UINT16 message_id)  
    598           { 
    599           	UINT8 packet[] =  
    600               { 
    601           		MQTT_MSG_PUBREL | MQTT_QOS1_FLAG, // Message Type, DUP flag, QoS level, Retain 
    602           		0x02, // Remaining length 
    603           		message_id>>8, 
    604           		message_id&0xFF 
    605           	}; 
    606           
    607          
    608           	// Send the packet 
    609           	/*if(broker->send(broker->socket_info, packet, sizeof(packet)) < sizeof(packet))  
    610               { 
    611           		return -1; 
    612           	} */
    613           
    614          
    615           	return 1; 
   \                     mqtt_pubrel:
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
    616           } 
    617           
    618          

   \                                 In section .text, align 2, keep-with-next
    619           int mqtt_subscribe(mqtt_broker_handle_t* broker, const char* topic, UINT16* message_id)  
    620           { 
   \                     mqtt_subscribe:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine6
    621               UINT16    utf_topic_len = 0; 
    622           	UINT8     *utf_topic = NULL;  
    623               UINT16    packetLen = 0; 
    624           	UINT8     *packet = NULL; 
    625           	UINT8     fixed_header[2]; 
    626           	UINT8     var_header[2]; // Message ID 
    627                
    628           	UINT16 topiclen = strlen(topic); 
   \                     ??CrossCallReturnLabel_5:
   \   00000006   0x.... 0x....      BL       ?Subroutine4
    629           
    630          
    631           	// Variable header 
    632           	var_header[0] = broker->seq>>8; 
    633           	var_header[1] = broker->seq&0xFF; 
    634           	if(message_id) // Returning message id 
    635               {  
    636           		*message_id = broker->seq; 
    637           	} 
    638           	broker->seq++; 
    639           
    640          
    641           	// utf topic 
    642               utf_topic_len = topiclen+3;// Topic size (2 bytes), utf-encoded topic, QoS byte 
   \                     ??CrossCallReturnLabel_0:
   \   0000000A   0x1CEE             ADDS     R6,R5,#+3
   \   0000000C   0xB2B6             UXTH     R6,R6
    643               //utf_topic = (UINT8*)_mem_alloc_zero(utf_topic_len);
    644               utf_topic = malloc(utf_topic_len);
   \   0000000E   0x4630             MOV      R0,R6
   \   00000010   0x.... 0x....      BL       malloc
   \   00000014   0x.... 0x....      BL       ?Subroutine8
    645               memset(utf_topic,0,utf_topic_len);  
    646               if (utf_topic == NULL) 
   \                     ??CrossCallReturnLabel_14:
   \   00000018   0xB16F             CBZ.N    R7,??mqtt_subscribe_0
    647               { 
    648                   goto error; 
    649               } 
    650           	utf_topic[0] = topiclen>>8; 
   \   0000001A   0x.... 0x....      BL       ?Subroutine7
    651           	utf_topic[1] = topiclen&0xFF; 
    652           	memcpy(utf_topic+2, topic, topiclen); 
    653           
    654          
    655           	// Fixed header 
    656           	fixed_header[0] = MQTT_MSG_SUBSCRIBE | MQTT_QOS1_FLAG; // Message Type, DUP flag, QoS level, Retain 
   \                     ??CrossCallReturnLabel_7:
   \   0000001E   0x2082             MOVS     R0,#+130
   \   00000020   0x.... 0x....      BL       ?Subroutine5
    657               fixed_header[1] = sizeof(var_header)+utf_topic_len; 
    658           
    659          
    660               packetLen = sizeof(var_header)+sizeof(fixed_header)+utf_topic_len; 
    661               //packet = (UINT8*)_mem_alloc_zero(packetLen); 
    662               packet = malloc(packetLen);
   \                     ??CrossCallReturnLabel_3:
   \   00000024   0x4605             MOV      R5,R0
    663               memset(packet,0,packetLen); 
   \   00000026   0x4622             MOV      R2,R4
   \   00000028   0x.... 0x....      BL       ??Subroutine8_0
    664               if (packet == NULL) 
   \                     ??CrossCallReturnLabel_9:
   \   0000002C   0xB105             CBZ.N    R5,??mqtt_subscribe_1
    665               { 
    666                   goto error; 
    667               } 
    668           	memcpy(packet, fixed_header, sizeof(fixed_header)); 
   \   0000002E   0x....             B.N      ?Subroutine1
    669           	memcpy(packet+sizeof(fixed_header), var_header, sizeof(var_header)); 
    670           	memcpy(packet+sizeof(fixed_header)+sizeof(var_header), utf_topic, utf_topic_len); 
    671           
    672          
    673           	// Send the packet 
    674           	/*if(broker->send(broker->socket_info, packet, packetLen) < packetLen) { 
    675                   goto error; 
    676           	} */
    677           
    678          
    679               //_mem_free(utf_topic);
    680                  free(utf_topic);
    681               //_mem_free(packet);
    682                  free(packet);
    683                
    684           	return 1; 
    685                
    686           error: 
    687               if (utf_topic != NULL) 
    688               { 
    689                   //_mem_free(utf_topic);
    690                 free(utf_topic);
   \                     ??mqtt_subscribe_1:
   \   00000030   0x4638             MOV      R0,R7
   \   00000032   0x.... 0x....      BL       free
    691               } 
    692                
    693               if (packet != NULL) 
    694               { 
    695                   //_mem_free(packet);
    696                 free(packet);
    697               } 
    698                
    699               return  -1; 
   \                     ??mqtt_subscribe_0:
   \   00000036   0x....             B.N      ?Subroutine2
    700           } 

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   0xF04F 0x30FF      MOV      R0,#-1
   \   00000004   0xBDF2             POP      {R1,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7:
   \   00000000   0x0A28             LSRS     R0,R5,#+8
   \   00000002   0x7038             STRB     R0,[R7, #+0]
   \   00000004   0x707D             STRB     R5,[R7, #+1]
   \   00000006   0x462A             MOV      R2,R5
   \   00000008   0x4621             MOV      R1,R4
   \   0000000A   0x1CB8             ADDS     R0,R7,#+2
   \   0000000C   0x.... 0x....      B.W      memcpy

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6:
   \   00000000   0x4606             MOV      R6,R0
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4617             MOV      R7,R2
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      B.W      strlen

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5:
   \   00000000   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   00000004   0x1D34             ADDS     R4,R6,#+4
   \   00000006   0x1CB0             ADDS     R0,R6,#+2
   \   00000008   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   0000000C   0xB2A4             UXTH     R4,R4
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      B.W      malloc

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4:
   \   00000000   0xB285             UXTH     R5,R0
   \   00000002   0xF8B6 0x0050      LDRH     R0,[R6, #+80]
   \   00000006   0x0A00             LSRS     R0,R0,#+8
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000000C   0xF8B6 0x0050      LDRH     R0,[R6, #+80]
   \   00000010   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   00000014   0xB117             CBZ.N    R7,??Subroutine4_0
   \   00000016   0xF8B6 0x0050      LDRH     R0,[R6, #+80]
   \   0000001A   0x8038             STRH     R0,[R7, #+0]
   \                     ??Subroutine4_0:
   \   0000001C   0xF8B6 0x0050      LDRH     R0,[R6, #+80]
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0xF8A6 0x0050      STRH     R0,[R6, #+80]
   \   00000026   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0x2202             MOVS     R2,#+2
   \   00000002   0xF10D 0x0102      ADD      R1,SP,#+2
   \   00000006   0x4628             MOV      R0,R5
   \   00000008   0x.... 0x....      BL       memcpy
   \   0000000C   0x2202             MOVS     R2,#+2
   \   0000000E   0xA900             ADD      R1,SP,#+0
   \   00000010   0x1CA8             ADDS     R0,R5,#+2
   \   00000012   0x.... 0x....      BL       memcpy
   \   00000016   0x4632             MOV      R2,R6
   \   00000018   0x4639             MOV      R1,R7
   \   0000001A   0x1D28             ADDS     R0,R5,#+4
   \   0000001C   0x.... 0x....      BL       memcpy
   \   00000020   0x4638             MOV      R0,R7
   \   00000022   0x.... 0x....      BL       free
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x.... 0x....      BL       free
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xBDF2             POP      {R1,R4-R7,PC}
    701           
    702          

   \                                 In section .text, align 2, keep-with-next
    703           int mqtt_unsubscribe(mqtt_broker_handle_t* broker, const char* topic, UINT16* message_id)  
    704           { 
   \                     mqtt_unsubscribe:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine6
    705               UINT16    packetLen = 0; 
    706           	UINT8     *packet = NULL;     
    707           	UINT8     fixed_header[2]; 
    708           	UINT16    topiclen = strlen(topic); 
   \                     ??CrossCallReturnLabel_4:
   \   00000006   0x.... 0x....      BL       ?Subroutine4
    709               UINT16    utf_topic_len = 0; 
    710           	UINT8     *utf_topic = NULL; 
    711           
    712          
    713           	// Variable header 
    714           	UINT8 var_header[2]; // Message ID 
    715           	var_header[0] = broker->seq>>8; 
    716           	var_header[1] = broker->seq&0xFF; 
    717           	if(message_id) { // Returning message id 
    718           		*message_id = broker->seq; 
    719           	} 
    720           	broker->seq++; 
    721           
    722          
    723           	// utf topic 
    724               utf_topic_len = topiclen+2;         // Topic size (2 bytes), utf-encoded topic 
   \                     ??CrossCallReturnLabel_1:
   \   0000000A   0x1CAE             ADDS     R6,R5,#+2
   \   0000000C   0xB2B6             UXTH     R6,R6
    725               //utf_topic = (UINT8*)_mem_alloc_zero(utf_topic_len); 
    726               utf_topic = malloc(utf_topic_len);
   \   0000000E   0x4630             MOV      R0,R6
   \   00000010   0x.... 0x....      BL       malloc
   \   00000014   0x.... 0x....      BL       ?Subroutine8
    727               memset(utf_topic,0,utf_topic_len);
    728               if (utf_topic == NULL) 
   \                     ??CrossCallReturnLabel_13:
   \   00000018   0xB16F             CBZ.N    R7,??mqtt_unsubscribe_0
    729               { 
    730                   goto error; 
    731               } 
    732                
    733           	utf_topic[0] = topiclen>>8; 
   \   0000001A   0x.... 0x....      BL       ?Subroutine7
    734           	utf_topic[1] = topiclen&0xFF; 
    735           	memcpy(utf_topic+2, topic, topiclen); 
    736           
    737          
    738           	// Fixed header 
    739           	fixed_header[0] = MQTT_MSG_UNSUBSCRIBE | MQTT_QOS1_FLAG; // Message Type, DUP flag, QoS level, Retain 
   \                     ??CrossCallReturnLabel_6:
   \   0000001E   0x20A2             MOVS     R0,#+162
   \   00000020   0x.... 0x....      BL       ?Subroutine5
    740               fixed_header[1] = sizeof(var_header) + utf_topic_len; 
    741           
    742          
    743               packetLen = sizeof(var_header)+sizeof(fixed_header)+utf_topic_len; 
    744           	//packet = (UINT8*)_mem_alloc_zero(packetLen);
    745               packet = malloc(packetLen);
   \                     ??CrossCallReturnLabel_2:
   \   00000024   0x4605             MOV      R5,R0
    746               memset(packet,0,packetLen);
   \   00000026   0x4622             MOV      R2,R4
   \   00000028   0x.... 0x....      BL       ??Subroutine8_0
    747               if (packet == NULL) 
   \                     ??CrossCallReturnLabel_8:
   \   0000002C   0xB105             CBZ.N    R5,??mqtt_unsubscribe_1
    748               { 
    749                   goto error; 
    750               } 
    751           	memcpy(packet, fixed_header, sizeof(fixed_header)); 
   \   0000002E   0x....             B.N      ?Subroutine1
    752           	memcpy(packet+sizeof(fixed_header), var_header, sizeof(var_header)); 
    753           	memcpy(packet+sizeof(fixed_header)+sizeof(var_header), utf_topic, utf_topic_len); 
    754           
    755          
    756           	// Send the packet 
    757           	/*if(broker->send(broker->socket_info, packet, packetLen) < packetLen)  
    758               { 
    759           		goto error;         
    760           	} */
    761           
    762          
    763               //_mem_free(utf_topic);
    764                  free(utf_topic);
    765               //_mem_free(packet);
    766                  free(packet);
    767                
    768           	return 1; 
    769                
    770           error: 
    771               if (utf_topic != NULL) 
    772               { 
    773                   //_mem_free(utf_topic);
    774                 free(utf_topic);
   \                     ??mqtt_unsubscribe_1:
   \   00000030   0x4638             MOV      R0,R7
   \   00000032   0x.... 0x....      BL       free
    775               } 
    776                
    777               if (packet != NULL) 
    778               { 
    779                   //_mem_free(packet);
    780                 free(packet);
    781               } 
    782                
    783               return  -1; 
   \                     ??mqtt_unsubscribe_0:
   \   00000036                      REQUIRE ?Subroutine2
   \   00000036                      ;; // Fall through to label ?Subroutine2
    784           } 

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "\\r\\n CONNECT PACKET is ...">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012 CONNECT PACKET is NULL"
   \              0x20 0x43    
   \              0x4F 0x4E    
   \              0x4E 0x45    
   \              0x43 0x54    
   \              0x20 0x50    
   \              0x41 0x43    
   \              0x4B 0x45    
   \              0x54 0x20    
   \              0x69 0x73    
   \              0x20 0x4E    
   \              0x55 0x4C    
   \              0x4C 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "\\r\\n PUBLISH VAILD HEAD...">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012 PUBLISH VAILD HEADER is NULL"
   \              0x20 0x50    
   \              0x55 0x42    
   \              0x4C 0x49    
   \              0x53 0x48    
   \              0x20 0x56    
   \              0x41 0x49    
   \              0x4C 0x44    
   \              0x20 0x48    
   \              0x45 0x41    
   \              0x44 0x45    
   \              0x52 0x20    
   \              0x69 0x73    
   \              0x20 0x4E    
   \              0x55 0x4C    
   \              0x4C 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "\\r\\n PUBLISH PACKET is ...">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012 PUBLISH PACKET is NULL"
   \              0x20 0x50    
   \              0x55 0x42    
   \              0x4C 0x49    
   \              0x53 0x48    
   \              0x20 0x50    
   \              0x41 0x43    
   \              0x4B 0x45    
   \              0x54 0x20    
   \              0x69 0x73    
   \              0x20 0x4E    
   \              0x55 0x4C    
   \              0x4C 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "emqtt">`:
   \   00000000   0x65 0x6D          DC8 "emqtt"
   \              0x71 0x74    
   \              0x74 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0, 6, 77, 81, 73, 115, 100, 112, 3`:
   \   00000000   0x00 0x06          DC8 0, 6, 77, 81, 73, 115, 100, 112, 3, 0, 0, 0
   \              0x4D 0x51    
   \              0x49 0x73    
   \              0x64 0x70    
   \              0x03 0x00    
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\r\\n connect Error">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012 connect Error"
   \              0x20 0x63    
   \              0x6F 0x6E    
   \              0x6E 0x65    
   \              0x63 0x74    
   \              0x20 0x45    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {224, 0}>`:
   \   00000000   0xE0 0x00          DC8 224, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\r\\n publish Error">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012 publish Error"
   \              0x20 0x70    
   \              0x75 0x62    
   \              0x6C 0x69    
   \              0x73 0x68    
   \              0x20 0x45    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    785          
    786          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   memcpy
         8   -> __aeabi_memcpy
       8   memset
         8   -> __aeabi_memset
      56   mqtt_connect
        56   -> AppS2wHal_NetTx
        56   -> GsnDynMemMgmt_Alloc
        56   -> GsnDynMemMgmt_Free
        56   -> S2w_Printf
        56   -> memcpy
        56   -> memset
        56   -> strlen
      16   mqtt_disconnect
        16   -> AppS2wHal_NetTx
      16   mqtt_init
        16   -> __aeabi_memcpy
        16   -> memcpy
        16   -> strlen
      16   mqtt_init_auth
         0   -> memcpy
        16   -> memcpy
        16   -> strlen
       0   mqtt_num_rem_len_bytes
       8   mqtt_parse_msg_id
         8   -> mqtt_num_rem_len_bytes
      24   mqtt_parse_pub_msg_ptr
        24   -> mqtt_num_rem_len_bytes
        24   -> mqtt_parse_rem_len
      16   mqtt_parse_pub_topic
        16   -> memcpy
        16   -> mqtt_parse_pub_topic_ptr
      16   mqtt_parse_pub_topic_ptr
        16   -> mqtt_num_rem_len_bytes
      16   mqtt_parse_publish_msg
        16   -> memcpy
        16   -> mqtt_parse_pub_msg_ptr
       8   mqtt_parse_rem_len
       0   mqtt_ping
      56   mqtt_publish_with_qos
        56   -> AppS2wHal_NetTx
        56   -> GsnDynMemMgmt_Alloc
        56   -> GsnDynMemMgmt_Free
        56   -> S2w_Printf
        56   -> memcpy
        56   -> memset
        56   -> strlen
       0   mqtt_pubrel
       0   mqtt_set_alive
      24   mqtt_subscribe
        24   -> free
        24   -> malloc
        24   -> memcpy
        24   -> memset
        24   -> strlen
      24   mqtt_unsubscribe
        24   -> free
        24   -> malloc
        24   -> memcpy
        24   -> memset
        24   -> strlen


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      28  ?<Constant "\r\n CONNECT PACKET is ...">
      28  ?<Constant "\r\n PUBLISH PACKET is ...">
      32  ?<Constant "\r\n PUBLISH VAILD HEAD...">
      20  ?<Constant "\r\n connect Error">
      20  ?<Constant "\r\n publish Error">
       8  ?<Constant "emqtt">
      12  ?<Constant {0, 6, 77, 81, 73, 115, 100, 112, 3
       2  ?<Constant {224, 0}>
      16  ?Subroutine0
      48  ?Subroutine1
       6  ?Subroutine2
       6  ?Subroutine3
      40  ?Subroutine4
      20  ?Subroutine5
      12  ?Subroutine6
      16  ?Subroutine7
      10  ?Subroutine8
      10  ?Subroutine9
      12  memcpy
      20  memset
     356  mqtt_connect
      38  mqtt_disconnect
      58  mqtt_init
      64  mqtt_init_auth
      30  mqtt_num_rem_len_bytes
      74  mqtt_parse_msg_id
      72  mqtt_parse_pub_msg_ptr
      20  mqtt_parse_pub_topic
      46  mqtt_parse_pub_topic_ptr
      18  mqtt_parse_publish_msg
      34  mqtt_parse_rem_len
       4  mqtt_ping
     320  mqtt_publish_with_qos
       4  mqtt_pubrel
       6  mqtt_set_alive
      56  mqtt_subscribe
      54  mqtt_unsubscribe

 
    88 bytes in section .rodata
 1 532 bytes in section .text
 
 1 500 bytes of CODE  memory (+ 32 bytes shared)
    88 bytes of CONST memory

Errors: none
Warnings: none
