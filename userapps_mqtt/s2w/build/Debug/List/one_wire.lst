###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      19/Nov/2015  15:23:21 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\src\one_wire\one_wire.c                       #
#    Command line =  E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\src\one_wire\one_wire.c -D                    #
#                    TX_ENABLE_IAR_LIBRARY_SUPPORT -D IAR -D FIXED_ROM_BUILD  #
#                    -D RUN_ALL_FROM_FLASH -D TM_USE_HTTPD -D S2W_DNS_CLIENT  #
#                    -D NX_INCLUDE_USER_DEFINE_FILE -D S2W_WEB_FS_AVAILABLE   #
#                    -D S2W_EXTFLASH_DRIVER_TEST -D S2W_PWM_SUPPORT -D        #
#                    S2W_MEM_ACCESS -D S2W_FORCE_UART_PORT -D                 #
#                    S2W_EXT_FLASH_FWUP_PUSH_METHOD -D                        #
#                    S2W_NCM_SUPPORT_ENABLE -D S2W_SECURITY_ENTERPRISE_PEAP_V #
#                    0_AVAILABLE -D S2W_EXT_FLASH_FWUP_PULL_METHOD -D         #
#                    S2W_SECURITY_ENTERPRISE_TLS_AVAILABLE -D                 #
#                    S2W_DNS_SERVER_ENABLE -D ADK_OTAFU -D S2W_GSLINK_RAW -D  #
#                    S2W_GSLINK_XML -D S2W_SECURITY_ENTERPRISE_PEAP_V1_AVAILA #
#                    BLE -D S2W_PING_TRACE -D S2W_RF_TEST -D                  #
#                    S2W_SSL_CLIENT_SUPPORT -D S2W_DEFAULT_UART_PARITY=0 -D   #
#                    S2W_DHCP_SERVER_ENABLE -D S2W_SECURITY_WPS_ENABLE -D     #
#                    ADK_PROV_CONFIG_LIMITED_AP -D S2W_WEB_SERVER -D          #
#                    ADK_PROV -D S2W_DEFAULT_UART_SW_FLOW=0 -D                #
#                    S2W_FILE_UPLOAD_API -D S2W_COAP_SUPPORT -D               #
#                    S2W_HTTPD_SSLCERT_UPLOAD -D                              #
#                    S2W_DEFAULT_UART_STOP_BITS=0 -D S2W_FACT_IMAGE_REQ -D    #
#                    S2W_DEFAULT_UART_BAUD=9600 -D S2W_ASYNC_MSG -D           #
#                    S2W_HTTPS_SUPPORT -D S2W_DEFAULT_UART_HW_FLOW=0 -D       #
#                    S2W_SECURITY_ENTERPRISE_FAST_GTC_AVAILABLE -D            #
#                    S2W_WEB_PROV -D S2W_UNASSOC_TXRX_SUPPORT -D S2W_SNTP -D  #
#                    S2W_UART_ENABLE -D S2W_GSLINK_XMLNESTED_PARSER -D        #
#                    S2W_GSLINK -D S2W_SECURITY_ENTERPRISE_TTLS_AVAILABLE -D  #
#                    S2W_ADC_SUPPORT -D S2W_HTTPC_SUPPORT -D                  #
#                    S2W_SECURITY_ENTERPRISE_FAST_MSCHAPV2_AVAILABLE -D       #
#                    S2W_SSL_SERVER_SUPPORT -D ADK_PROV_CONFIG_CLIENT -D      #
#                    S2W_DEFAULT_UART_BITS_PER_CHAR=3 -D S2W_MDNS_ENABLE -lC  #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\Debug\List\ -lA                         #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\Debug\List\ --diag_suppress             #
#                    Pa050,Pe231,Pe177 -o E:\Gainspan\gs2011mxx_SDK_s2w_tls_t #
#                    lslp_5.1.5_GA\userapps_mqtt\s2w\build\Debug\Obj\         #
#                    --debug --endian=little --cpu=Cortex-M3 -e --fpu=None    #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA #
#                    \userapps_mqtt\s2w\build\..\..\..\geps\inc\ -I           #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\core\ -I              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\drivers\ -I           #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\modules\ -I           #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\rtos\ -I              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\netx\ -I              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\netx\netx_bsd_layer\  #
#                    -I E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\user #
#                    apps_mqtt\s2w\build\..\..\..\geps\inc\main\ -I           #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\fs\ -I                #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\fs\hcc\src\ -I        #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\security\src\ -I      #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\security\hw_engine_if #
#                    \ -I E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\us #
#                    erapps_mqtt\s2w\build\..\..\..\geps\inc\security\wpa_if\ #
#                     -I E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\use #
#                    rapps_mqtt\s2w\build\..\..\..\userlib\ncm\inc\ -I        #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\userlib\ -I                    #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\ctx\ -I                          #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\ -I                              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\main\ -I                         #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\hal\ -I                          #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\parser\ -I                       #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\config\ -I                       #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\ -I                              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\adk\otafu\inc\ -I              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\adk\provisioning\inc\ -I       #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\mqtt\ -I                         #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\mqtt\ -I                         #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\one_wire\ -I                     #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\one_wire\ -I                     #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\linked_list\ -I                  #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\linked_list\ -I                  #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\mqtt_main\ -I                    #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\mqtt_main\ -I                    #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\mqtt_log\ -I                     #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\mqtt_log\ -Ohz --use_c++_inline  #
#                    -I "C:\Program Files (x86)\IAR Systems\Embedded          #
#                    Workbench 6.5\arm\CMSIS\Include\"                        #
#    List file    =  E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\Debug\List\one_wire.lst                 #
#    Object file  =  E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\Debug\Obj\one_wire.o                    #
#                                                                             #
#                                                                             #
###############################################################################

E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapps_mqtt\s2w\src\one_wire\one_wire.c
      1          #include <stdio.h>
      2          #include <stdint.h> 
      3          #include "time.h"
      4          #include "gsn_includes.h"
      5          
      6          #include "one_wire/one_wire.h"
      7          
      8          
      9          

   \                                 In section .text, align 2, keep-with-next
     10          void delay(int useconds)
     11          {
     12            for( int i =0 ; i < (useconds*20) ; i++){}
   \                     delay:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xE000             B.N      ??delay_0
   \                     ??delay_1:
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   \                     ??delay_0:
   \   00000006   0x2214             MOVS     R2,#+20
   \   00000008   0x4342             MULS     R2,R2,R0
   \   0000000A   0x4291             CMP      R1,R2
   \   0000000C   0xDBFA             BLT.N    ??delay_1
     13          }
   \   0000000E   0x4770             BX       LR               ;; return
     14          
     15          

   \                                 In section .text, align 2, keep-with-next
     16          UINT8 crc8(UINT8 *data_in, UINT32 number_of_bytes_to_read)
     17          {
   \                     crc8:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
     18          	UINT8  crc_val;
     19          	UINT32 loop_count;
     20          	UINT8  bit_counter;
     21          	UINT8  data;
     22          	UINT8  feedback_bit;
     23          
     24          	crc_val = CRC8INIT;
   \   00000002   0x2200             MOVS     R2,#+0
     25          
     26          	for (loop_count = 0; loop_count != number_of_bytes_to_read; loop_count++)
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0xE011             B.N      ??crc8_0
     27          	{
     28          		data = data_in[loop_count];
   \                     ??crc8_1:
   \   00000008   0x5C1C             LDRB     R4,[R3, R0]
     29          
     30          		bit_counter = 8;
   \   0000000A   0x2508             MOVS     R5,#+8
     31          		do {
     32          			feedback_bit = (crc_val ^ data) & 0x01;
   \                     ??crc8_2:
   \   0000000C   0xEA84 0x0602      EOR      R6,R4,R2
   \   00000010   0xF016 0x0601      ANDS     R6,R6,#0x1
     33          
     34          			if (feedback_bit == 0x01) {
   \   00000014   0xBF18             IT       NE 
   \   00000016   0xF082 0x0218      EORNE    R2,R2,#0x18
     35          				crc_val = crc_val ^ CRC8POLY;
     36          			}
     37          			crc_val = (crc_val >> 1) & 0x7F;
   \   0000001A   0x05D2             LSLS     R2,R2,#+23
   \   0000001C   0x0E12             LSRS     R2,R2,#+24
     38          			if (feedback_bit == 0x01) {
   \   0000001E   0xB10E             CBZ.N    R6,??crc8_3
     39          				crc_val = crc_val | 0x80;
   \   00000020   0xF042 0x0280      ORR      R2,R2,#0x80
     40          			}
     41          
     42          			data = data >> 1;
   \                     ??crc8_3:
   \   00000024   0x0864             LSRS     R4,R4,#+1
     43          			bit_counter--;
     44          
     45          		} while (bit_counter > 0);
   \   00000026   0x1E6D             SUBS     R5,R5,#+1
   \   00000028   0xD1F0             BNE.N    ??crc8_2
     46          	}
   \   0000002A   0x1C5B             ADDS     R3,R3,#+1
   \                     ??crc8_0:
   \   0000002C   0x428B             CMP      R3,R1
   \   0000002E   0xD1EB             BNE.N    ??crc8_1
     47          
     48          	return crc_val;
   \   00000030   0x4610             MOV      R0,R2
   \   00000032   0xBD70             POP      {R4-R6,PC}       ;; return
     49          }
     50          
     51          
     52          

   \                                 In section .text, align 2, keep-with-next
     53          VOID DS18B20_set(UINT8 pin, unsigned resolution)
     54          {
   \                     DS18B20_set:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
     55              //GsnIoMux_Sel(pin, GSN_IOMUX_GPIO_4_AGPIO_4);
     56              GsnIoMux_PullDownDisable(pin);
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      BL       _tx_thread_interrupt_control
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0x....             LDR.N    R1,??DataTable12  ;; 0x40160200
   \   00000010   0x2D20             CMP      R5,#+32
   \   00000012   0xD204             BCS.N    ??DS18B20_set_0
   \   00000014   0x680B             LDR      R3,[R1, #+0]
   \   00000016   0x40AA             LSLS     R2,R2,R5
   \   00000018   0x431A             ORRS     R2,R2,R3
   \   0000001A   0x600A             STR      R2,[R1, #+0]
   \   0000001C   0xE004             B.N      ??DS18B20_set_1
   \                     ??DS18B20_set_0:
   \   0000001E   0x3D20             SUBS     R5,R5,#+32
   \   00000020   0x684B             LDR      R3,[R1, #+4]
   \   00000022   0x40AA             LSLS     R2,R2,R5
   \   00000024   0x431A             ORRS     R2,R2,R3
   \   00000026   0x604A             STR      R2,[R1, #+4]
   \                     ??DS18B20_set_1:
   \   00000028   0x.... 0x....      BL       _tx_thread_interrupt_control
     57              SetResolution(resolution);
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000032   0x....             B.N      SetResolution
     58          }
     59           
     60           
     61          // Reset 1-wire interface.

   \                                 In section .text, align 2, keep-with-next
     62          unsigned Reset() {
   \                     Reset:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
     63              LONG64 bit_value;
     64              GsnGpio_Init(GPIO_BITMAP, ~GPIO_BITMAP);
   \   00000004   0x.... 0x....      BL       ?Subroutine0
     65              GsnGpio_OutClear(GPIO_BITMAP); 
   \                     ??CrossCallReturnLabel_2:
   \   00000008   0x.... 0x....      BL       ?Subroutine2
     66              //delay(13000);
     67              delay(H);
   \                     ??CrossCallReturnLabel_10:
   \   0000000C   0xF44F 0x70F0      MOV      R0,#+480
   \   00000010   0x.... 0x....      BL       delay
     68              GsnGpio_Init(GPIO_BITMAP, GPIO_BITMAP);
   \   00000014   0x.... 0x....      BL       ?Subroutine1
     69              //delay(5000);
     70              delay(I);
   \                     ??CrossCallReturnLabel_6:
   \   00000018   0x205A             MOVS     R0,#+90
   \   0000001A   0x.... 0x....      BL       delay
     71              GsnGpio_Read(&bit_value, GPIO_BITMAP);
   \   0000001E   0x2210             MOVS     R2,#+16
   \   00000020   0x2300             MOVS     R3,#+0
   \   00000022   0xA800             ADD      R0,SP,#+0
   \   00000024   0x.... 0x....      BL       GsnGpio_Read
     72              delay(J);
   \   00000028   0x2037             MOVS     R0,#+55
   \   0000002A   0x.... 0x....      BL       delay
     73              return (bit_value & 1);
   \   0000002E   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \   00000032   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000036   0xBD0E             POP      {R1-R3,PC}       ;; return
     74          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   0x2010             MOVS     R0,#+16
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      B.W      GsnGpio_OutClear

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0x2300             MOVS     R3,#+0
   \   00000002   0x2210             MOVS     R2,#+16
   \   00000004   0x2010             MOVS     R0,#+16
   \   00000006   0x4619             MOV      R1,R3
   \   00000008   0x.... 0x....      B.W      GsnGpio_Init

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0xF06F 0x0210      MVN      R2,#+16
   \   00000004   0xF04F 0x33FF      MOV      R3,#-1
   \   00000008   0x2010             MOVS     R0,#+16
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x.... 0x....      B.W      GsnGpio_Init
     75           
     76          // Write bit to 1-wire.

   \                                 In section .text, align 2, keep-with-next
     77          void WriteBit(unsigned bit) {
   \                     WriteBit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
     78              GsnGpio_Init(GPIO_BITMAP, ~GPIO_BITMAP);
   \   00000004   0x.... 0x....      BL       ?Subroutine0
     79              if (bit) {
   \                     ??CrossCallReturnLabel_1:
   \   00000008   0xB144             CBZ.N    R4,??WriteBit_0
     80                  GsnGpio_OutClear(GPIO_BITMAP); 
   \   0000000A   0x.... 0x....      BL       ?Subroutine2
     81                  //delay(350);
     82                  delay(A);
   \                     ??CrossCallReturnLabel_9:
   \   0000000E   0x2008             MOVS     R0,#+8
   \   00000010   0x.... 0x....      BL       delay
     83                  GsnGpio_Init(GPIO_BITMAP, GPIO_BITMAP);
   \   00000014   0x.... 0x....      BL       ?Subroutine1
     84                  //delay(1200);
     85                  delay(B);
   \                     ??CrossCallReturnLabel_5:
   \   00000018   0x203E             MOVS     R0,#+62
   \   0000001A   0xE007             B.N      ??WriteBit_1
     86              } else {
     87                  GsnGpio_OutClear(GPIO_BITMAP);
   \                     ??WriteBit_0:
   \   0000001C   0x.... 0x....      BL       ?Subroutine2
     88                  //delay(2000);
     89                  delay(C);
   \                     ??CrossCallReturnLabel_8:
   \   00000020   0x203C             MOVS     R0,#+60
   \   00000022   0x.... 0x....      BL       delay
     90                  GsnGpio_Init(GPIO_BITMAP, GPIO_BITMAP);
   \   00000026   0x.... 0x....      BL       ?Subroutine1
     91                  //delay(600);
     92                  delay(D);
   \                     ??CrossCallReturnLabel_4:
   \   0000002A   0x200A             MOVS     R0,#+10
   \                     ??WriteBit_1:
   \   0000002C   0x.... 0x....      BL       delay
     93              }
     94              delay(20);
   \   00000030   0xE8BD 0x4010      POP      {R4,LR}
   \   00000034   0x2014             MOVS     R0,#+20
   \   00000036   0x....             B.N      delay
     95          }
     96          

   \                                 In section .bss, align 1
     97          UINT8 readed_bit;
   \                     readed_bit:
   \   00000000                      DS8 1
     98          

   \                                 In section .text, align 2, keep-with-next
     99          VOID
    100          read_bit(UINT8 gpioNum, void *pCtx)
    101          {
    102            readed_bit = 0;
   \                     read_bit:
   \   00000000   0x....             LDR.N    R0,??DataTable12_1
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x7001             STRB     R1,[R0, #+0]
    103          }
   \   00000006   0x4770             BX       LR               ;; return
    104          
    105          // Read bit from 1-wire.

   \                                 In section .text, align 2, keep-with-next
    106          unsigned ReadBit() {
   \                     ReadBit:
   \   00000000   0xB510             PUSH     {R4,LR}
    107              LONG64 bit_value;
    108              readed_bit = 1;
   \   00000002   0x....             LDR.N    R4,??DataTable12_1
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x7020             STRB     R0,[R4, #+0]
    109              GsnGpio_Init(GPIO_BITMAP, ~GPIO_BITMAP);  
   \   00000008   0x.... 0x....      BL       ?Subroutine0
    110              GsnGpio_OutClear(GPIO_BITMAP);
   \                     ??CrossCallReturnLabel_0:
   \   0000000C   0x.... 0x....      BL       ?Subroutine2
    111              delay(A);
   \                     ??CrossCallReturnLabel_7:
   \   00000010   0x2008             MOVS     R0,#+8
   \   00000012   0x.... 0x....      BL       delay
    112              //delay(100);
    113              GsnGpio_Init(GPIO_BITMAP, GPIO_BITMAP);
   \   00000016   0x.... 0x....      BL       ?Subroutine1
    114              GsnGpio_IntCbRegister(GPIO, read_bit, NULL);
   \                     ??CrossCallReturnLabel_3:
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x....             LDR.N    R1,??DataTable12_2
   \   0000001E   0x2004             MOVS     R0,#+4
   \   00000020   0x.... 0x....      BL       GsnGpio_IntCbRegister
    115              GsnGpio_PEIntEnable(GPIO_BITMAP);
   \   00000024   0x2010             MOVS     R0,#+16
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x.... 0x....      BL       GsnGpio_PEIntEnable
    116              delay(4);
   \   0000002C   0x2004             MOVS     R0,#+4
   \   0000002E   0x.... 0x....      BL       delay
    117              //delay(200);
    118              GsnGpio_PEIntDisable(GPIO_BITMAP);
   \   00000032   0x2010             MOVS     R0,#+16
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x.... 0x....      BL       GsnGpio_PEIntDisable
    119              //GsnGpio_Read(&bit_value, GPIO_BITMAP);
    120              delay(F);
   \   0000003A   0x2037             MOVS     R0,#+55
   \   0000003C   0x.... 0x....      BL       delay
    121              //delay(450);
    122              //return (bit_value & 1);
    123              return readed_bit;
   \   00000040   0x7820             LDRB     R0,[R4, #+0]
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
    124          }
    125           
    126          // Write byte to 1-wire.

   \                                 In section .text, align 2, keep-with-next
    127          void WriteByte(unsigned byte) {
   \                     WriteByte:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    128              for (unsigned bit = 0; bit < 8; ++bit) {
   \   00000004   0x2508             MOVS     R5,#+8
    129                  WriteBit(byte & 0x01); // lsb to msb
   \                     ??WriteByte_0:
   \   00000006   0xF004 0x0001      AND      R0,R4,#0x1
   \   0000000A   0x.... 0x....      BL       WriteBit
    130                  byte >>= 1;    // right shift by 1-bit
   \   0000000E   0x0864             LSRS     R4,R4,#+1
    131              }
   \   00000010   0x1E6D             SUBS     R5,R5,#+1
   \   00000012   0xD1F8             BNE.N    ??WriteByte_0
    132          }
   \   00000014   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    133           
    134          // Read byte from 1-wire.

   \                                 In section .text, align 2, keep-with-next
    135          unsigned ReadByte() {
   \                     ReadByte:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    136              unsigned byte = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    137              for (unsigned bit = 0; bit < 8; ++bit) {
   \   00000004   0x2500             MOVS     R5,#+0
    138                  byte |= (ReadBit() << bit);    // Reads lsb to msb
   \                     ??ReadByte_0:
   \   00000006   0x.... 0x....      BL       ReadBit
   \   0000000A   0x40A8             LSLS     R0,R0,R5
   \   0000000C   0x4304             ORRS     R4,R0,R4
    139              }
   \   0000000E   0x1C6D             ADDS     R5,R5,#+1
   \   00000010   0x2D08             CMP      R5,#+8
   \   00000012   0xD3F8             BCC.N    ??ReadByte_0
    140              return byte;
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    141          }
    142           
    143          // Set number of bits in the conversion.

   \                                 In section .text, align 2, keep-with-next
    144          unsigned SetResolution(unsigned resolution) {
   \                     SetResolution:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    145              if (Reset() != 0)
   \   00000004   0x.... 0x....      BL       Reset
   \   00000008   0xB108             CBZ.N    R0,??SetResolution_0
    146              {
    147                  return 1;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xBD10             POP      {R4,PC}
    148              }
    149              else {
    150                  WriteByte(SKIP_ROM);            // Skip ROM
   \                     ??SetResolution_0:
   \   0000000E   0x20CC             MOVS     R0,#+204
   \   00000010   0x.... 0x....      BL       WriteByte
    151                  WriteByte(WRITE_SCRATCHPAD);    // WRITE_SCRATCHPAD
   \   00000014   0x204E             MOVS     R0,#+78
   \   00000016   0x.... 0x....      BL       WriteByte
    152                  WriteByte(0x7f);                // Alarm TH
   \   0000001A   0x207F             MOVS     R0,#+127
   \   0000001C   0x.... 0x....      BL       WriteByte
    153                  WriteByte(0x80);                // Alarm TL
   \   00000020   0x2080             MOVS     R0,#+128
   \   00000022   0x.... 0x....      BL       WriteByte
    154                  WriteByte(resolution);          // 0xx11111 xx=resolution (9-12 bits)
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       WriteByte
    155              }
    156              return 0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    157          }
    158           
    159          // Trigger a temperature conversion but don't read the temperature.

   \                                 In section .text, align 2, keep-with-next
    160          unsigned DoConversion(UINT8 *id) {
   \                     DoConversion:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    161              
    162              UINT8 i;
    163             
    164              if (Reset() != 0)
   \   00000004   0x.... 0x....      BL       Reset
   \   00000008   0xB108             CBZ.N    R0,??DoConversion_0
    165              {
    166                  return 1;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}
    167              }
    168              else {
    169                  //WriteByte(SKIP_ROM);            // Skip ROM
    170                  WriteByte( MATCH_ROM );            // to a single device
   \                     ??DoConversion_0:
   \   0000000E   0x2055             MOVS     R0,#+85
   \   00000010   0x.... 0x....      BL       WriteByte
    171                  i = 8;
   \   00000014   0x2508             MOVS     R5,#+8
    172                  do {
    173                      WriteByte( *id );
   \                     ??DoConversion_1:
   \   00000016   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   0000001A   0x.... 0x....      BL       WriteByte
    174                      ++id;
    175                  } while ( --i );
   \   0000001E   0x1E6D             SUBS     R5,R5,#+1
   \   00000020   0xD1F9             BNE.N    ??DoConversion_1
    176                  WriteByte(CONVERT);             // Convert
   \   00000022   0x2044             MOVS     R0,#+68
   \   00000024   0x.... 0x....      BL       WriteByte
    177                  while (ReadBit() == 0); // wait for conversion to complete
   \                     ??DoConversion_2:
   \   00000028   0x.... 0x....      BL       ReadBit
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD0FB             BEQ.N    ??DoConversion_2
    178              }
    179              return 0;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    180          }
    181           
    182          // Do Conversion and get temperature as s8.4 sign-extended to 16-bits.

   \                                 In section .text, align 2, keep-with-next
    183          float RawTemperature(UINT8 *id) {
   \                     RawTemperature:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
    184              // Perform the temperature conversion.
    185              UINT8 i,j;
    186              ScratchPad_t SCRATCH_PAD;
    187              UINT8 sp[9];
    188              float temp_result = 0.0;
    189              UINT8 sub_zero, cel, cel_frac_bits;
    190              UINT16 devicelsius;
    191              
    192              if (DoConversion(id) != 0)
   \   00000006   0x.... 0x....      BL       DoConversion
   \   0000000A   0xB9F0             CBNZ.N   R0,??RawTemperature_0
    193              {
    194                  return INVALID_TEMPERATURE;
    195              }
    196              // Read the temperature back.
    197              if (Reset() != 0)
   \   0000000C   0x.... 0x....      BL       Reset
   \   00000010   0xB9D8             CBNZ.N   R0,??RawTemperature_0
    198              {
    199                  return INVALID_TEMPERATURE;
    200              }
    201              else {
    202                  //WriteByte(SKIP_ROM);    // Skip ROM
    203                  WriteByte( MATCH_ROM );            // to a single device
   \   00000012   0x2055             MOVS     R0,#+85
   \   00000014   0x.... 0x....      BL       WriteByte
    204                  i = 8;
   \   00000018   0x2508             MOVS     R5,#+8
    205                  do {
    206                      WriteByte( *id );
   \                     ??RawTemperature_1:
   \   0000001A   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   0000001E   0x.... 0x....      BL       WriteByte
    207                      ++id;
    208                  } while ( --i );
   \   00000022   0x1E6D             SUBS     R5,R5,#+1
   \   00000024   0xD1F9             BNE.N    ??RawTemperature_1
    209                  WriteByte(READ_SCRATCHPAD);    // Read Scrachpad
   \   00000026   0x20BE             MOVS     R0,#+190
   \   00000028   0x.... 0x....      BL       WriteByte
    210                  for(j=0;j<9;j++)
   \   0000002C   0x2400             MOVS     R4,#+0
    211                  {
    212                    //SCRATCH_PAD.scratchpad[j] = ReadByte();
    213                    sp[j] = ReadByte();
   \                     ??RawTemperature_2:
   \   0000002E   0x.... 0x....      BL       ReadByte
   \   00000032   0xA901             ADD      R1,SP,#+4
   \   00000034   0x5460             STRB     R0,[R4, R1]
    214                  }
   \   00000036   0x1C64             ADDS     R4,R4,#+1
   \   00000038   0x2C09             CMP      R4,#+9
   \   0000003A   0xDBF8             BLT.N    ??RawTemperature_2
    215                  // Terminate read as we only want temperature
    216                  Reset();
   \   0000003C   0x.... 0x....      BL       Reset
    217                  // Ensure correct sign-extension.
    218              }
    219          
    220              if(crc8(&sp[0],9))
   \   00000040   0x2109             MOVS     R1,#+9
   \   00000042   0xA801             ADD      R0,SP,#+4
   \   00000044   0x.... 0x....      BL       crc8
   \   00000048   0xB108             CBZ.N    R0,??RawTemperature_3
    221              {
    222                  return INVALID_TEMPERATURE;
   \                     ??RawTemperature_0:
   \   0000004A   0x....             LDR.N    R0,??DataTable12_3  ;; 0xc61c4000
   \   0000004C   0xE022             B.N      ??RawTemperature_4
    223              }
    224                
    225              meas_to_cel(sp, &sub_zero, &cel, &cel_frac_bits);
   \                     ??RawTemperature_3:
   \   0000004E   0xF10D 0x0301      ADD      R3,SP,#+1
   \   00000052   0xF10D 0x0202      ADD      R2,SP,#+2
   \   00000056   0xA900             ADD      R1,SP,#+0
   \   00000058   0xA801             ADD      R0,SP,#+4
   \   0000005A   0x.... 0x....      BL       meas_to_cel
    226              devicelsius = temp_to_decicel(sub_zero,cel,cel_frac_bits);
    227              temp_result = devicelsius ;
    228              temp_result = temp_result / 10.0;
   \   0000005E   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   00000062   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   00000066   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000006A   0x.... 0x....      BL       temp_to_decicel
   \   0000006E   0x.... 0x....      BL       __aeabi_ui2f
   \   00000072   0x....             LDR.N    R1,??DataTable12_4  ;; 0x41200000
   \   00000074   0x.... 0x....      BL       __aeabi_fdiv
    229              temp_result = temp_result * ((sub_zero == 1)? -1.0 : 1.0) ;
   \   00000078   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000007C   0x2901             CMP      R1,#+1
   \   0000007E   0xBF0C             ITE      EQ 
   \   00000080   0x....             LDREQ.N  R5,??DataTable12_5  ;; 0xbff00000
   \   00000082   0x....             LDRNE.N  R5,??DataTable12_6  ;; 0x3ff00000
    230              return temp_result;
   \   00000084   0x.... 0x....      BL       __aeabi_f2d
   \   00000088   0x2200             MOVS     R2,#+0
   \   0000008A   0x462B             MOV      R3,R5
   \   0000008C   0x.... 0x....      BL       __aeabi_dmul
   \   00000090   0x.... 0x....      BL       __aeabi_d2f
   \                     ??RawTemperature_4:
   \   00000094   0xB005             ADD      SP,SP,#+20
   \   00000096   0xBD30             POP      {R4,R5,PC}       ;; return
    231          }
    232          

   \                                 In section .text, align 2, keep-with-next
    233          UINT8 meas_to_cel( UINT8 *sp, UINT8* subzero, UINT8* cel, UINT8* cel_frac_bits)
    234          {
   \                     meas_to_cel:
   \   00000000   0xB510             PUSH     {R4,LR}
    235            UINT16 meas;
    236            UINT8 i;
    237            
    238            meas = sp[0]; //LSB
    239            meas |= ((UINT16)sp[1])<<8; //MSB
   \   00000002   0x7804             LDRB     R4,[R0, #+0]
   \   00000004   0x7840             LDRB     R0,[R0, #+1]
   \   00000006   0xEA44 0x2000      ORR      R0,R4,R0, LSL #+8
    240            
    241            if( meas & 0x8000)
   \   0000000A   0x0404             LSLS     R4,R0,#+16
   \   0000000C   0xD506             BPL.N    ??meas_to_cel_0
    242            {
    243              *subzero = 1;   // mark negative
    244              meas ^= 0xffff; // convert to positive => twos complement
    245              meas++;
   \   0000000E   0xF480 0x407F      EOR      R0,R0,#0xFF00
   \   00000012   0xF080 0x00FF      EOR      R0,R0,#0xFF
   \   00000016   0x2401             MOVS     R4,#+1
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   \   0000001A   0xE000             B.N      ??meas_to_cel_1
    246            }
    247            else
    248              *subzero = 0;
   \                     ??meas_to_cel_0:
   \   0000001C   0x2400             MOVS     R4,#+0
   \                     ??meas_to_cel_1:
   \   0000001E   0x700C             STRB     R4,[R1, #+0]
    249            
    250            *cel = (UINT8)(meas >>4);
   \   00000020   0xB280             UXTH     R0,R0
   \   00000022   0x0901             LSRS     R1,R0,#+4
   \   00000024   0x7011             STRB     R1,[R2, #+0]
    251            *cel_frac_bits = (UINT8)(meas & 0x000f);
   \   00000026   0xF000 0x000F      AND      R0,R0,#0xF
   \   0000002A   0x7018             STRB     R0,[R3, #+0]
    252            
    253            return 0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    254          }
    255          

   \                                 In section .text, align 2, keep-with-next
    256          UINT16 temp_to_decicel(UINT8 subzero, UINT8 cel,
    257                                           UINT8 cel_frac_bits) {
   \                     temp_to_decicel:
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
    258              UINT16 h;
    259              UINT8  i;
    260              UINT8 need_rounding[] = { 1, 3, 4, 6, 9, 11, 12, 14 };
   \   00000002   0x.... 0x....      ADR.W    R4,`?<Constant {1, 3, 4, 6, 9, 11, 12, 14}>`
   \   00000006   0xCC60             LDM      R4!,{R5,R6}
   \   00000008   0xAB00             ADD      R3,SP,#+0
    261           
    262              h = cel_frac_bits*DS18X20_FRACCONV/1000;
    263              h += cel*10;
   \   0000000A   0xF44F 0x747A      MOV      R4,#+1000
   \   0000000E   0xC360             STM      R3!,{R5,R6}
   \   00000010   0xF240 0x2371      MOVW     R3,#+625
   \   00000014   0x4353             MULS     R3,R3,R2
   \   00000016   0xFB93 0xF3F4      SDIV     R3,R3,R4
   \   0000001A   0xB29B             UXTH     R3,R3
   \   0000001C   0x240A             MOVS     R4,#+10
   \   0000001E   0xFB04 0x3101      MLA      R1,R4,R1,R3
    264              if (!subzero) {
   \   00000022   0xB948             CBNZ.N   R0,??temp_to_decicel_0
    265                  for (i=0; i<sizeof(need_rounding); i++) {
    266                      if ( cel_frac_bits == need_rounding[i] ) {
   \                     ??temp_to_decicel_1:
   \   00000024   0xAB00             ADD      R3,SP,#+0
   \   00000026   0x5CC3             LDRB     R3,[R0, R3]
   \   00000028   0x429A             CMP      R2,R3
   \   0000002A   0xD101             BNE.N    ??temp_to_decicel_2
    267                          h++;
   \   0000002C   0x1C49             ADDS     R1,R1,#+1
    268                          break;
   \   0000002E   0xE003             B.N      ??temp_to_decicel_0
    269                      }
    270                  }
   \                     ??temp_to_decicel_2:
   \   00000030   0x1C40             ADDS     R0,R0,#+1
   \   00000032   0xB2C0             UXTB     R0,R0
   \   00000034   0x2808             CMP      R0,#+8
   \   00000036   0xD3F5             BCC.N    ??temp_to_decicel_1
    271              }
    272              return h;
   \                     ??temp_to_decicel_0:
   \   00000038   0xB288             UXTH     R0,R1
   \   0000003A   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    273          }
    274           
    275          // Read temperature in floating point format.

   \                                 In section .text, align 2, keep-with-next
    276          float GetTemperature(DS18B20_Sensor_t *id) {
   \                     GetTemperature:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    277              float temperature = RawTemperature(id->ROM_CODE.rom);
   \   00000004   0xE000             B.N      ??GetTemperature_0
    278              while(temperature == INVALID_TEMPERATURE)
    279              {
    280                temperature = RawTemperature(id->ROM_CODE.rom);
   \                     ??GetTemperature_1:
   \   00000006   0x4620             MOV      R0,R4
   \                     ??GetTemperature_0:
   \   00000008   0x.... 0x....      BL       RawTemperature
    281              }
   \   0000000C   0x....             LDR.N    R1,??DataTable12_3  ;; 0xc61c4000
   \   0000000E   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000012   0xD0F8             BEQ.N    ??GetTemperature_1
    282              id->Temperature = temperature;
   \   00000014   0x60A0             STR      R0,[R4, #+8]
    283              return 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    284          }
    285           
    286          // Read back DS18B20 ROM.

   \                                 In section .text, align 2, keep-with-next
    287          int ReadROM(ROM_Code_t *ROM_Code) {
   \                     ReadROM:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    288              if (Reset() != 0)
   \   00000004   0x.... 0x....      BL       Reset
   \   00000008   0xB108             CBZ.N    R0,??ReadROM_0
    289                  return 1;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}
    290              else {
    291                  WriteByte(READ_ROM);    // Read ROM
   \                     ??ReadROM_0:
   \   0000000E   0x2033             MOVS     R0,#+51
   \   00000010   0x.... 0x....      BL       WriteByte
    292                  for (unsigned i = 0; i < 8; ++i) {
   \   00000014   0x2500             MOVS     R5,#+0
    293                      ROM_Code->rom[i] = ReadByte();
   \                     ??ReadROM_1:
   \   00000016   0x.... 0x....      BL       ReadByte
   \   0000001A   0x5528             STRB     R0,[R5, R4]
    294                  }
   \   0000001C   0x1C6D             ADDS     R5,R5,#+1
   \   0000001E   0x2D08             CMP      R5,#+8
   \   00000020   0xD3F9             BCC.N    ??ReadROM_1
    295              }
    296              return 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    297          }
    298          

   \                                 In section .text, align 2, keep-with-next
    299          UINT8 Search_sensor(UINT8 *nSensors, DS18B20_Sensor_t *SensorIDs)
    300          {
   \                     Search_sensor:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x4604             MOV      R4,R0
    301            UINT8 i;
    302            UINT8 id[ROM_CODE_SIZE];
    303            UINT8 diff;
    304            
    305            diff = 0xff;
   \   00000008   0x20FF             MOVS     R0,#+255
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000000E   0x460D             MOV      R5,R1
    306            for(*nSensors = 0 ; (diff != 0x00) && (*nSensors < MAXIMUM_SENSOR_COUNT) ; )
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x7020             STRB     R0,[R4, #+0]
   \   00000014   0x260C             MOVS     R6,#+12
   \   00000016   0x.... 0x....      ADR.W    R7,`?<Constant "\\r\\n Bus Error">`
   \   0000001A   0x.... 0x....      ADR.W    R8,`?<Constant "\\r\\nNo Sensor found">`
   \   0000001E   0xE002             B.N      ??Search_sensor_0
    307            {
    308              find_sensor(&diff,&id[0]);
    309              if(diff == 0x01)
    310              {
    311                S2w_Printf("\r\nNo Sensor found");
   \                     ??Search_sensor_1:
   \   00000020   0x4640             MOV      R0,R8
   \                     ??Search_sensor_2:
   \   00000022   0x.... 0x....      BL       S2w_Printf
    312                continue;
    313              }
   \                     ??Search_sensor_0:
   \   00000026   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002A   0xB320             CBZ.N    R0,??Search_sensor_3
   \   0000002C   0x7820             LDRB     R0,[R4, #+0]
   \   0000002E   0x2810             CMP      R0,#+16
   \   00000030   0xDA21             BGE.N    ??Search_sensor_3
   \   00000032   0xA901             ADD      R1,SP,#+4
   \   00000034   0xA800             ADD      R0,SP,#+0
   \   00000036   0x.... 0x....      BL       find_sensor
   \   0000003A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xD0EE             BEQ.N    ??Search_sensor_1
    314              if(diff == 0xfe)
   \   00000042   0x28FE             CMP      R0,#+254
   \   00000044   0xBF08             IT       EQ 
   \   00000046   0x4638             MOVEQ    R0,R7
    315              {
    316                S2w_Printf("\r\n Bus Error");
   \   00000048   0xD0EB             BEQ.N    ??Search_sensor_2
    317                continue;
    318              }
    319              for(i=0 ; i< ROM_CODE_SIZE ; i++)
   \   0000004A   0x2000             MOVS     R0,#+0
    320                (SensorIDs+(*nSensors))->ROM_CODE.rom[i] = id[i];
   \                     ??Search_sensor_4:
   \   0000004C   0x7821             LDRB     R1,[R4, #+0]
   \   0000004E   0xAA01             ADD      R2,SP,#+4
   \   00000050   0xFB06 0x5101      MLA      R1,R6,R1,R5
   \   00000054   0x5C82             LDRB     R2,[R0, R2]
   \   00000056   0x5442             STRB     R2,[R0, R1]
   \   00000058   0x1C40             ADDS     R0,R0,#+1
   \   0000005A   0x2808             CMP      R0,#+8
   \   0000005C   0xDBF6             BLT.N    ??Search_sensor_4
    321              
    322              if(crc8((SensorIDs+(*nSensors))->ROM_CODE.rom,8) != 0)
   \   0000005E   0x7820             LDRB     R0,[R4, #+0]
   \   00000060   0x2108             MOVS     R1,#+8
   \   00000062   0xFB06 0x5000      MLA      R0,R6,R0,R5
   \   00000066   0x.... 0x....      BL       crc8
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD1DB             BNE.N    ??Search_sensor_0
    323                continue;
    324              else
    325                (*nSensors)++;
   \   0000006E   0x7820             LDRB     R0,[R4, #+0]
   \   00000070   0x1C40             ADDS     R0,R0,#+1
   \   00000072   0x7020             STRB     R0,[R4, #+0]
   \   00000074   0xE7D7             B.N      ??Search_sensor_0
    326              
    327            }
    328            return 0;
   \                     ??Search_sensor_3:
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xB004             ADD      SP,SP,#+16
   \   0000007A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    329          }
    330          

   \                                 In section .text, align 2, keep-with-next
    331          UINT8 find_sensor(UINT8 *diff, UINT8 id[]) {
   \                     find_sensor:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    332              for (;;) 
    333              {
    334                  *diff = rom_search( *diff, &id[0] );
   \                     ??find_sensor_0:
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x4629             MOV      R1,R5
   \   0000000A   0x.... 0x....      BL       rom_search
   \   0000000E   0x7020             STRB     R0,[R4, #+0]
    335                  if ( *diff==0x01)
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xBF18             IT       NE 
   \   00000014   0x28FE             CMPNE    R0,#+254
    336                      return 1;
    337                  if ( *diff==0xFE )
   \   00000016   0xD101             BNE.N    ??find_sensor_1
    338                      return 1;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}
    339                  if ( *diff == 0x00 )
   \                     ??find_sensor_1:
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xBF1C             ITT      NE 
   \   00000020   0x7828             LDRBNE   R0,[R5, #+0]
   \   00000022   0x2828             CMPNE    R0,#+40
    340                      return 0 ;
    341                  if ( id[0] == 0x28 ) 
   \   00000024   0xD1EF             BNE.N    ??find_sensor_0
    342                      return 0 ;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    343              }
    344          
    345          }
    346          

   \                                 In section .text, align 2, keep-with-next
    347          UINT8 rom_search( UINT8 diff, UINT8 id[] ) {
   \                     rom_search:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x460D             MOV      R5,R1
    348              UINT8 i, j, next_diff;
    349              UINT8 b;
    350           
    351              if ( Reset() )
   \   00000008   0x.... 0x....      BL       Reset
   \   0000000C   0xB108             CBZ.N    R0,??rom_search_0
    352                  return 1;    // error, no device found
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE02D             B.N      ??rom_search_1
    353              WriteByte( SEARCH_ROM );            // ROM search command
   \                     ??rom_search_0:
   \   00000012   0x20F0             MOVS     R0,#+240
   \   00000014   0x.... 0x....      BL       WriteByte
    354              next_diff = 0x00;            // unchanged on last device
   \   00000018   0xF04F 0x0900      MOV      R9,#+0
    355              i = 8 * 8;                    // 8 bytes
   \   0000001C   0x2740             MOVS     R7,#+64
    356              do {
    357                  j = 8;                                // 8 bits
   \                     ??rom_search_2:
   \   0000001E   0x2408             MOVS     R4,#+8
    358                  do {
    359                      b = ReadBit();                // read bit
   \                     ??rom_search_3:
   \   00000020   0x.... 0x....      BL       ReadBit
   \   00000024   0xB2C6             UXTB     R6,R0
    360                      if ( ReadBit() ) {            // read complement bit
   \   00000026   0x.... 0x....      BL       ReadBit
   \   0000002A   0xB110             CBZ.N    R0,??rom_search_4
    361                          if ( b )                    // 11
   \   0000002C   0xB166             CBZ.N    R6,??rom_search_5
    362                              return 0xFE;        // data error
   \   0000002E   0x20FE             MOVS     R0,#+254
   \   00000030   0xE01D             B.N      ??rom_search_1
    363                      } else {
    364                          if ( !b ) {                    // 00 = 2 devices
   \                     ??rom_search_4:
   \   00000032   0xB94E             CBNZ.N   R6,??rom_search_5
    365                              if ( diff > i || ((*id & 1) && diff != i) ) {
   \   00000034   0xB2FF             UXTB     R7,R7
   \   00000036   0x4547             CMP      R7,R8
   \   00000038   0xD304             BCC.N    ??rom_search_6
   \   0000003A   0x7828             LDRB     R0,[R5, #+0]
   \   0000003C   0x07C0             LSLS     R0,R0,#+31
   \   0000003E   0xD503             BPL.N    ??rom_search_5
   \   00000040   0x45B8             CMP      R8,R7
   \   00000042   0xD001             BEQ.N    ??rom_search_5
    366                                  b = 1;                // now 1
   \                     ??rom_search_6:
   \   00000044   0x2601             MOVS     R6,#+1
    367                                  next_diff = i;        // next pass 0
   \   00000046   0x46B9             MOV      R9,R7
    368                              }
    369                          }
    370                      }
    371                      WriteBit( b );                 // write bit
   \                     ??rom_search_5:
   \   00000048   0x4630             MOV      R0,R6
   \   0000004A   0x.... 0x....      BL       WriteBit
    372                      *id >>= 1;
   \   0000004E   0x7828             LDRB     R0,[R5, #+0]
   \   00000050   0x0840             LSRS     R0,R0,#+1
    373                      if ( b ) 
   \   00000052   0xB10E             CBZ.N    R6,??rom_search_7
    374                          *id |= 0x80;            // store bit
   \   00000054   0xF040 0x0080      ORR      R0,R0,#0x80
   \                     ??rom_search_7:
   \   00000058   0x7028             STRB     R0,[R5, #+0]
    375                      --i;
   \   0000005A   0x1E7F             SUBS     R7,R7,#+1
    376                  } while ( --j );
   \   0000005C   0x1E60             SUBS     R0,R4,#+1
   \   0000005E   0xB2C4             UXTB     R4,R0
   \   00000060   0x2C00             CMP      R4,#+0
   \   00000062   0xD1DD             BNE.N    ??rom_search_3
    377                  id++;                                // next byte
   \   00000064   0x1C6D             ADDS     R5,R5,#+1
    378              } while ( i );
   \   00000066   0xB2FF             UXTB     R7,R7
   \   00000068   0x2F00             CMP      R7,#+0
   \   0000006A   0xD1D8             BNE.N    ??rom_search_2
    379              return next_diff;                // to continue search
   \   0000006C   0x4648             MOV      R0,R9
   \                     ??rom_search_1:
   \   0000006E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    380          }
    381          

   \                                 In section .text, align 2, keep-with-next
    382          UINT8
    383          temp_sensor_search(UINT8* nSensors, DS18B20_Sensor_t *temp_sensor)
    384          {
   \                     temp_sensor_search:
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    385            DS18B20_Sensor_t *temp_sensor_pointer = temp_sensor;
    386            DS18B20_set(4,RES_12_BIT);
   \   00000008   0x217F             MOVS     R1,#+127
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0x.... 0x....      BL       DS18B20_set
    387            Search_sensor(nSensors, temp_sensor_pointer);
   \   00000010   0x4629             MOV      R1,R5
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       Search_sensor
    388            
    389            S2w_Printf("\r\n ==================Sensor Info================================");
   \   00000018   0x.... 0x....      ADR.W    R0,`?<Constant "\\r\\n ==================...">`
   \   0000001C   0x.... 0x....      BL       S2w_Printf
    390            for(UINT8 i=0;i<(*nSensors);i++)
   \   00000020   0x2600             MOVS     R6,#+0
   \   00000022   0x.... 0x....      ADR.W    R11,`?<Constant "\\r\\n ==================...">_1`
   \   00000026   0x.... 0x....      ADR.W    R8,`?<Constant "\\r\\n CRC code : 0x%X">`
   \   0000002A   0x.... 0x....      ADR.W    R9,`?<Constant "\\r\\n Serial Code : %02X...">`
   \   0000002E   0x.... 0x....      ADR.W    R10,`?<Constant "\\r\\n Family Code : 0x%X">`
   \   00000032   0xE01C             B.N      ??temp_sensor_search_0
    391            {
    392              S2w_Printf("\r\n Family Code : 0x%X",temp_sensor[i].ROM_CODE.BYTES.familyCode);
   \                     ??temp_sensor_search_1:
   \   00000034   0x200C             MOVS     R0,#+12
   \   00000036   0xFB00 0xF706      MUL      R7,R0,R6
   \   0000003A   0x4650             MOV      R0,R10
   \   0000003C   0x5D79             LDRB     R1,[R7, R5]
   \   0000003E   0x.... 0x....      BL       S2w_Printf
    393              S2w_Printf("\r\n Serial Code : %02X:%02X:%02X:%02X:%02X:%02X",
    394                         temp_sensor[i].ROM_CODE.BYTES.serialNo[5],
    395                         temp_sensor[i].ROM_CODE.BYTES.serialNo[4],
    396                         temp_sensor[i].ROM_CODE.BYTES.serialNo[3],
    397                         temp_sensor[i].ROM_CODE.BYTES.serialNo[2],
    398                         temp_sensor[i].ROM_CODE.BYTES.serialNo[1],
    399                         temp_sensor[i].ROM_CODE.BYTES.serialNo[0]);
   \   00000042   0x1978             ADDS     R0,R7,R5
   \   00000044   0x7841             LDRB     R1,[R0, #+1]
   \   00000046   0x9102             STR      R1,[SP, #+8]
   \   00000048   0x7881             LDRB     R1,[R0, #+2]
   \   0000004A   0x9101             STR      R1,[SP, #+4]
   \   0000004C   0x78C1             LDRB     R1,[R0, #+3]
   \   0000004E   0x9100             STR      R1,[SP, #+0]
   \   00000050   0x7903             LDRB     R3,[R0, #+4]
   \   00000052   0x7942             LDRB     R2,[R0, #+5]
   \   00000054   0x7981             LDRB     R1,[R0, #+6]
   \   00000056   0x4648             MOV      R0,R9
   \   00000058   0x.... 0x....      BL       S2w_Printf
    400              S2w_Printf("\r\n CRC code : 0x%X",temp_sensor[0].ROM_CODE.BYTES.CRC);
   \   0000005C   0x79E9             LDRB     R1,[R5, #+7]
   \   0000005E   0x4640             MOV      R0,R8
   \   00000060   0x.... 0x....      BL       S2w_Printf
    401              S2w_Printf("\r\n ===========================================================");
   \   00000064   0x4658             MOV      R0,R11
   \   00000066   0x.... 0x....      BL       S2w_Printf
    402            }
   \   0000006A   0x1C76             ADDS     R6,R6,#+1
   \   0000006C   0xB2F6             UXTB     R6,R6
   \                     ??temp_sensor_search_0:
   \   0000006E   0x7820             LDRB     R0,[R4, #+0]
   \   00000070   0x4286             CMP      R6,R0
   \   00000072   0xDBDF             BLT.N    ??temp_sensor_search_1
    403            return 0;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    404          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x40160200         DC32     0x40160200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x........         DC32     readed_bit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x........         DC32     read_bit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0xC61C4000         DC32     0xc61c4000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x41200000         DC32     0x41200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0xBFF00000         DC32     0xbff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {1, 3, 4, 6, 9, 11, 12, 14}>`:
   \   00000000   0x01 0x03          DC8 1, 3, 4, 6, 9, 11, 12, 14
   \              0x04 0x06    
   \              0x09 0x0B    
   \              0x0C 0x0E    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\r\\nNo Sensor found">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012No Sensor found"
   \              0x4E 0x6F    
   \              0x20 0x53    
   \              0x65 0x6E    
   \              0x73 0x6F    
   \              0x72 0x20    
   \              0x66 0x6F    
   \              0x75 0x6E    
   \              0x64 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\r\\n Bus Error">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012 Bus Error"
   \              0x20 0x42    
   \              0x75 0x73    
   \              0x20 0x45    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\r\\n ==================...">`:
   \   00000000   0x0D 0x0A          DC8 0DH, 0AH, 20H, 3DH, 3DH, 3DH, 3DH, 3DH
   \              0x20 0x3D    
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \   00000008   0x3D 0x3D          DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \   00000010   0x3D 0x3D          DC8 3DH, 3DH, 3DH, 3DH, 3DH, 53H, 65H, 6EH
   \              0x3D 0x3D    
   \              0x3D 0x53    
   \              0x65 0x6E    
   \   00000018   0x73 0x6F          DC8 73H, 6FH, 72H, 20H, 49H, 6EH, 66H, 6FH
   \              0x72 0x20    
   \              0x49 0x6E    
   \              0x66 0x6F    
   \   00000020   0x3D 0x3D          DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \   00000028   0x3D 0x3D          DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \   00000030   0x3D 0x3D          DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \   00000038   0x3D 0x3D          DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \   00000040   0x00               DC8 0
   \   00000041   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\r\\n Family Code : 0x%X">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012 Family Code : 0x%X"
   \              0x20 0x46    
   \              0x61 0x6D    
   \              0x69 0x6C    
   \              0x79 0x20    
   \              0x43 0x6F    
   \              0x64 0x65    
   \              0x20 0x3A    
   \              0x20 0x30    
   \              0x78 0x25    
   \              0x58 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\r\\n Serial Code : %02X...">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012 Serial Code : %02X:%02X:%02X:%02X:%02X:%02X"
   \              0x20 0x53    
   \              0x65 0x72    
   \              0x69 0x61    
   \              0x6C 0x20    
   \              0x43 0x6F    
   \              0x64 0x65    
   \              0x20 0x3A    
   \              0x20 0x25    
   \              0x30 0x32    
   \              0x58 0x3A    
   \              0x25 0x30    
   \              0x32 0x58    
   \              0x3A 0x25    
   \              0x30 0x32    
   \              0x58 0x3A    
   \              0x25 0x30    
   \              0x32 0x58    
   \              0x3A 0x25    
   \              0x30 0x32    
   \              0x58 0x3A    
   \              0x25 0x30    
   \              0x32 0x58    
   \              0x00         
   \   0000002F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\r\\n CRC code : 0x%X">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012 CRC code : 0x%X"
   \              0x20 0x43    
   \              0x52 0x43    
   \              0x20 0x63    
   \              0x6F 0x64    
   \              0x65 0x20    
   \              0x3A 0x20    
   \              0x30 0x78    
   \              0x25 0x58    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\r\\n ==================...">_1`:
   \   00000000   0x0D 0x0A          DC8 0DH, 0AH, 20H, 3DH, 3DH, 3DH, 3DH, 3DH
   \              0x20 0x3D    
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \   00000008   0x3D 0x3D          DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \   00000010   0x3D 0x3D          DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \   00000018   0x3D 0x3D          DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \   00000020   0x3D 0x3D          DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \   00000028   0x3D 0x3D          DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \   00000030   0x3D 0x3D          DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \   00000038   0x3D 0x3D          DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 0
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \              0x00         
   \   0000003F   0x00               DC8 0
    405          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   DS18B20_set
         0   -> SetResolution
        16   -> _tx_thread_interrupt_control
      16   DoConversion
        16   -> ReadBit
        16   -> Reset
        16   -> WriteByte
       8   GetTemperature
         8   -> RawTemperature
         8   -> __aeabi_cfcmpeq
      32   RawTemperature
        32   -> DoConversion
        32   -> ReadByte
        32   -> Reset
        32   -> WriteByte
        32   -> __aeabi_d2f
        32   -> __aeabi_dmul
        32   -> __aeabi_f2d
        32   -> __aeabi_fdiv
        32   -> __aeabi_ui2f
        32   -> crc8
        32   -> meas_to_cel
        32   -> temp_to_decicel
       8   ReadBit
         8   -> GsnGpio_Init
         8   -> GsnGpio_IntCbRegister
         8   -> GsnGpio_OutClear
         8   -> GsnGpio_PEIntDisable
         8   -> GsnGpio_PEIntEnable
         8   -> delay
      16   ReadByte
        16   -> ReadBit
      16   ReadROM
        16   -> ReadByte
        16   -> Reset
        16   -> WriteByte
      16   Reset
        16   -> GsnGpio_Init
        16   -> GsnGpio_OutClear
        16   -> GsnGpio_Read
        16   -> delay
      40   Search_sensor
        40   -> S2w_Printf
        40   -> crc8
        40   -> find_sensor
       8   SetResolution
         8   -> Reset
         8   -> WriteByte
       8   WriteBit
         8   -> GsnGpio_Init
         8   -> GsnGpio_OutClear
         0   -> delay
         8   -> delay
      16   WriteByte
        16   -> WriteBit
      16   crc8
       0   delay
      16   find_sensor
        16   -> rom_search
       8   meas_to_cel
       0   read_bit
      32   rom_search
        32   -> ReadBit
        32   -> Reset
        32   -> WriteBit
        32   -> WriteByte
      48   temp_sensor_search
        48   -> DS18B20_set
        48   -> S2w_Printf
        48   -> Search_sensor
      24   temp_to_decicel


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      68  ?<Constant "\r\n ==================...">
      64  ?<Constant "\r\n ==================...">_1
      16  ?<Constant "\r\n Bus Error">
      20  ?<Constant "\r\n CRC code : 0x%X">
      24  ?<Constant "\r\n Family Code : 0x%X">
      48  ?<Constant "\r\n Serial Code : %02X...">
      20  ?<Constant "\r\nNo Sensor found">
       8  ?<Constant {1, 3, 4, 6, 9, 11, 12, 14}>
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
      16  ?Subroutine0
      12  ?Subroutine1
       8  ?Subroutine2
      52  DS18B20_set
      52  DoConversion
      26  GetTemperature
     152  RawTemperature
      68  ReadBit
      24  ReadByte
      38  ReadROM
      56  Reset
     126  Search_sensor
      48  SetResolution
      56  WriteBit
      22  WriteByte
      52  crc8
      16  delay
      42  find_sensor
      48  meas_to_cel
       8  read_bit
       1  readed_bit
     114  rom_search
     122  temp_sensor_search
      60  temp_to_decicel

 
     1 byte  in section .bss
 1 514 bytes in section .text
 
 1 514 bytes of CODE memory
     1 byte  of DATA memory

Errors: none
Warnings: none
