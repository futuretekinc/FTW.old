###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      19/Nov/2015  15:23:23 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\src\hal\s2w_fs_if.c                           #
#    Command line =  E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\src\hal\s2w_fs_if.c -D                        #
#                    TX_ENABLE_IAR_LIBRARY_SUPPORT -D IAR -D FIXED_ROM_BUILD  #
#                    -D RUN_ALL_FROM_FLASH -D TM_USE_HTTPD -D S2W_DNS_CLIENT  #
#                    -D NX_INCLUDE_USER_DEFINE_FILE -D S2W_WEB_FS_AVAILABLE   #
#                    -D S2W_EXTFLASH_DRIVER_TEST -D S2W_PWM_SUPPORT -D        #
#                    S2W_MEM_ACCESS -D S2W_FORCE_UART_PORT -D                 #
#                    S2W_EXT_FLASH_FWUP_PUSH_METHOD -D                        #
#                    S2W_NCM_SUPPORT_ENABLE -D S2W_SECURITY_ENTERPRISE_PEAP_V #
#                    0_AVAILABLE -D S2W_EXT_FLASH_FWUP_PULL_METHOD -D         #
#                    S2W_SECURITY_ENTERPRISE_TLS_AVAILABLE -D                 #
#                    S2W_DNS_SERVER_ENABLE -D ADK_OTAFU -D S2W_GSLINK_RAW -D  #
#                    S2W_GSLINK_XML -D S2W_SECURITY_ENTERPRISE_PEAP_V1_AVAILA #
#                    BLE -D S2W_PING_TRACE -D S2W_RF_TEST -D                  #
#                    S2W_SSL_CLIENT_SUPPORT -D S2W_DEFAULT_UART_PARITY=0 -D   #
#                    S2W_DHCP_SERVER_ENABLE -D S2W_SECURITY_WPS_ENABLE -D     #
#                    ADK_PROV_CONFIG_LIMITED_AP -D S2W_WEB_SERVER -D          #
#                    ADK_PROV -D S2W_DEFAULT_UART_SW_FLOW=0 -D                #
#                    S2W_FILE_UPLOAD_API -D S2W_COAP_SUPPORT -D               #
#                    S2W_HTTPD_SSLCERT_UPLOAD -D                              #
#                    S2W_DEFAULT_UART_STOP_BITS=0 -D S2W_FACT_IMAGE_REQ -D    #
#                    S2W_DEFAULT_UART_BAUD=9600 -D S2W_ASYNC_MSG -D           #
#                    S2W_HTTPS_SUPPORT -D S2W_DEFAULT_UART_HW_FLOW=0 -D       #
#                    S2W_SECURITY_ENTERPRISE_FAST_GTC_AVAILABLE -D            #
#                    S2W_WEB_PROV -D S2W_UNASSOC_TXRX_SUPPORT -D S2W_SNTP -D  #
#                    S2W_UART_ENABLE -D S2W_GSLINK_XMLNESTED_PARSER -D        #
#                    S2W_GSLINK -D S2W_SECURITY_ENTERPRISE_TTLS_AVAILABLE -D  #
#                    S2W_ADC_SUPPORT -D S2W_HTTPC_SUPPORT -D                  #
#                    S2W_SECURITY_ENTERPRISE_FAST_MSCHAPV2_AVAILABLE -D       #
#                    S2W_SSL_SERVER_SUPPORT -D ADK_PROV_CONFIG_CLIENT -D      #
#                    S2W_DEFAULT_UART_BITS_PER_CHAR=3 -D S2W_MDNS_ENABLE -lC  #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\Debug\List\ -lA                         #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\Debug\List\ --diag_suppress             #
#                    Pa050,Pe231,Pe177 -o E:\Gainspan\gs2011mxx_SDK_s2w_tls_t #
#                    lslp_5.1.5_GA\userapps_mqtt\s2w\build\Debug\Obj\         #
#                    --debug --endian=little --cpu=Cortex-M3 -e --fpu=None    #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA #
#                    \userapps_mqtt\s2w\build\..\..\..\geps\inc\ -I           #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\core\ -I              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\drivers\ -I           #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\modules\ -I           #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\rtos\ -I              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\netx\ -I              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\netx\netx_bsd_layer\  #
#                    -I E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\user #
#                    apps_mqtt\s2w\build\..\..\..\geps\inc\main\ -I           #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\fs\ -I                #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\fs\hcc\src\ -I        #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\security\src\ -I      #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\security\hw_engine_if #
#                    \ -I E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\us #
#                    erapps_mqtt\s2w\build\..\..\..\geps\inc\security\wpa_if\ #
#                     -I E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\use #
#                    rapps_mqtt\s2w\build\..\..\..\userlib\ncm\inc\ -I        #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\userlib\ -I                    #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\ctx\ -I                          #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\ -I                              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\main\ -I                         #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\hal\ -I                          #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\parser\ -I                       #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\config\ -I                       #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\ -I                              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\adk\otafu\inc\ -I              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\adk\provisioning\inc\ -I       #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\mqtt\ -I                         #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\mqtt\ -I                         #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\one_wire\ -I                     #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\one_wire\ -I                     #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\linked_list\ -I                  #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\linked_list\ -I                  #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\mqtt_main\ -I                    #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\mqtt_main\ -I                    #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\mqtt_log\ -I                     #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\mqtt_log\ -Ohz --use_c++_inline  #
#                    -I "C:\Program Files (x86)\IAR Systems\Embedded          #
#                    Workbench 6.5\arm\CMSIS\Include\"                        #
#    List file    =  E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\Debug\List\s2w_fs_if.lst                #
#    Object file  =  E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\Debug\Obj\s2w_fs_if.o                   #
#                                                                             #
#                                                                             #
###############################################################################

E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapps_mqtt\s2w\src\hal\s2w_fs_if.c
      1          #ifndef _N25Q_32MB_3V_65NM_C_
      2          #define _N25Q_32MB_3V_65NM_C_
      3          
      4          #include "gsn_includes.h"

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp void *memcpy(void *, void const *, size_t)
   \                     memcpy:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x.... 0x....      BL       __aeabi_memcpy
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4
   \   __interwork __softfp void GsnFlashIf_PioReq()
   \                     GsnFlashIf_PioReq:
   \   00000000   0x4803             LDR.N    R0,??GsnFlashIf_PioReq_0  ;; 0x400e0410
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x6001             STR      R1,[R0, #+0]
   \                     ??GsnFlashIf_PioReq_1:
   \   00000006   0x6841             LDR      R1,[R0, #+4]
   \   00000008   0x07C9             LSLS     R1,R1,#+31
   \   0000000A   0xD5FC             BPL.N    ??GsnFlashIf_PioReq_1
   \   0000000C   0x4770             BX       LR               ;; return
   \   0000000E   0xBF00             Nop      
   \                     ??GsnFlashIf_PioReq_0:
   \   00000010   0x400E0410         DC32     0x400e0410

   \                                 In section .text, align 4
   \   __interwork __softfp void GsnFlashIf_PioRelease()
   \                     GsnFlashIf_PioRelease:
   \   00000000   0x4803             LDR.N    R0,??GsnFlashIf_PioRelease_0  ;; 0x400e0410
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x6001             STR      R1,[R0, #+0]
   \                     ??GsnFlashIf_PioRelease_1:
   \   00000006   0x6841             LDR      R1,[R0, #+4]
   \   00000008   0x07C9             LSLS     R1,R1,#+31
   \   0000000A   0xD4FC             BMI.N    ??GsnFlashIf_PioRelease_1
   \   0000000C   0x4770             BX       LR               ;; return
   \   0000000E   0xBF00             Nop      
   \                     ??GsnFlashIf_PioRelease_0:
   \   00000010   0x400E0410         DC32     0x400e0410
      5          #include "hal/s2w_fs_if.h"
      6          #include "drivers/dma/gsn_dma.h"
      7          #include "main/gsn_br_flashldr.h"
      8          
      9          #include "drivers/reg/gsn_reg_dma_spec.h"
     10          #include "drivers/reg/gsn_reg_dma_op.h"
     11          #include "app_defines_builder.h"
     12          #include "modules/fwup/gsn_fwup.h"
     13          
     14          
     15          /*  physical  */
     16          /*  64x128k blocks  */
     17          
     18          #define BLOCKSIZE      0x1000 /*  4K - size of file storage blocks  */
     19          #define BLOCKSTART     0x32       /*  logical number of first file storage block  */
     20          #define MAXBLOCKS      14      /*  number of logical blocks for file storage  */
     21          
     22          #define DESCSIZE       0x1000  /*  4k descriptor block size  */
     23          #define DESCBLOCKSTART 0x30        /*  logical number of first descriptor block  */
     24          #define DESCBLOCKS     2        /*  number of descriptor blocks  */
     25          #define DESCCACHE      0x400  /*  1k assigned to write cache for descriptor  */
     26          
     27          #define SECTORSIZE     0x400   /* 1k */
     28          #define SECTORPERBLOCK ( BLOCKSIZE / SECTORSIZE )
     29          
     30          
     31          #ifdef S2W_WEB_FS_AVAILABLE
     32          #define BLOCKSIZE_1      0x1000 /*  4K - size of file storage blocks  */
     33          #define BLOCKSTART_1     0x2       /*  logical number of first file storage block  */
     34          #define MAXBLOCKS_1      14      /*  number of logical blocks for file storage  */
     35          
     36          #define DESCSIZE_1       0x1000  /*  4k descriptor block size  */
     37          #define DESCBLOCKSTART_1 0x0        /*  logical number of first descriptor block  */
     38          #define DESCBLOCKS_1     2        /*  number of descriptor blocks  */
     39          #define DESCCACHE_1      0x0  /*  1k assigned to write cache for descriptor  */
     40          
     41          #ifndef S2W_WEB_IMAGE_SECTOR_SIZE
     42          #define SECTORSIZE_1     0x200   /* 512 */
     43          #else
     44          #define SECTORSIZE_1     S2W_WEB_IMAGE_SECTOR_SIZE   /*From builder */
     45          #endif
     46          
     47          #define SECTORPERBLOCK_1 ( BLOCKSIZE_1 / SECTORSIZE_1 )
     48          #endif
     49          
     50          extern GSN_OSAL_BYTE_POOL_T romFreeMemPool;
     51          //static int dmaDoneFlag = 0;

   \                                 In section .bss, align 4
     52          UINT32 webFsOffset;
   \                     webFsOffset:
   \   00000000                      DS8 4
     53          /* Please check maximum storeable file and used sector number in FSmem.exe */
     54          
     55          #ifdef CONFIG_FROM_SUPERBLOCK
     56          

   \                                 In section .bss, align 4
     57          UINT32 block_start, desc_block_start, max_blocks;
   \                     block_start:
   \   00000000                      DS8 4
   \                     desc_block_start:
   \   00000004                      DS8 4
   \                     max_blocks:
   \   00000008                      DS8 4

   \                                 In section .text, align 2, keep-with-next
     58          UINT32 s2w_config_fs()
     59          {
   \                     s2w_config_fs:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
     60          	GSN_BRFLASHLDR_SUPERBLOCK_T superBlock;
     61          
     62          	GsnFlashCache_BlkFetch(GSN_FWUP_SUPER_BLOCK_ADDR, (UINT32)&superBlock, sizeof(superBlock), NULL);
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x2234             MOVS     R2,#+52
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0xF44F 0x5080      MOV      R0,#+4096
   \   0000000E   0x.... 0x....      BL       GsnFlashCache_BlkFetch
     63          
     64              if (strncmp((const char*)superBlock.flok, "flok", 4) != 0)
   \   00000012   0x2204             MOVS     R2,#+4
   \   00000014   0x.... 0x....      ADR.W    R1,`?<Constant "flok">`
   \   00000018   0xA800             ADD      R0,SP,#+0
   \   0000001A   0x.... 0x....      BL       strncmp
   \   0000001E   0xB108             CBZ.N    R0,??s2w_config_fs_0
     65              {
     66                  return 1;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE00A             B.N      ??s2w_config_fs_1
     67              }
     68              desc_block_start = superBlock.fsAddress / BLOCKSIZE;
   \                     ??s2w_config_fs_0:
   \   00000024   0x9809             LDR      R0,[SP, #+36]
   \   00000026   0x....             LDR.N    R1,??DataTable5
   \   00000028   0x0B00             LSRS     R0,R0,#+12
   \   0000002A   0x6048             STR      R0,[R1, #+4]
     69              block_start = desc_block_start + DESCBLOCKS;
   \   0000002C   0x1C80             ADDS     R0,R0,#+2
   \   0000002E   0x6008             STR      R0,[R1, #+0]
     70              max_blocks = superBlock.fsSize / BLOCKSIZE;
     71          	max_blocks = max_blocks - DESCBLOCKS;
   \   00000030   0x980A             LDR      R0,[SP, #+40]
   \   00000032   0x0B00             LSRS     R0,R0,#+12
   \   00000034   0x1E80             SUBS     R0,R0,#+2
   \   00000036   0x6088             STR      R0,[R1, #+8]
     72              return 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \                     ??s2w_config_fs_1:
   \   0000003A   0xB00D             ADD      SP,SP,#+52
   \   0000003C   0xBD00             POP      {PC}             ;; return
     73          }
     74          #endif
     75          

   \                                 In section .text, align 2, keep-with-next
     76          void dmaDoneCb(void *ctx, int channelId)
     77          {
     78          #if 0
     79          	dmaDoneFlag = 1;
     80          #endif
     81          }
   \                     dmaDoneCb:
   \   00000000   0x4770             BX       LR               ;; return
     82          
     83          

   \                                 In section .text, align 2, keep-with-next
     84          static long GetBlockAddr ( long block, long relsector )
     85          {
     86          	return ((BLOCKSIZE * block) + (relsector * SECTORSIZE));
   \                     GetBlockAddr:
   \   00000000   0x0289             LSLS     R1,R1,#+10
   \   00000002   0xEB01 0x3000      ADD      R0,R1,R0, LSL #+12
   \   00000006   0x4770             BX       LR               ;; return
     87          }
     88          
     89          

   \                                 In section .text, align 2, keep-with-next
     90          static int EraseFlash ( long block )
     91          {
   \                     EraseFlash:
   \   00000000   0xB510             PUSH     {R4,LR}
     92          	long  addr = GetBlockAddr( block, 0 );
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      BL       GetBlockAddr
   \   00000008   0x....             B.N      ?Subroutine0
     93              GsnFlashIf_PioReq();
     94          	GsnFlashIf_FlashErase(addr, BLOCKSIZE, TRUE);
     95              GsnFlashIf_PioRelease();
     96          	return 0;
     97          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x.... 0x....      BL       GsnFlashIf_PioReq
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xF44F 0x5180      MOV      R1,#+4096
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       GsnFlashIf_FlashErase
   \   00000012   0x.... 0x....      BL       GsnFlashIf_PioRelease
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
     98          

   \                                 In section .text, align 2, keep-with-next
     99          static int WriteFlash ( void * data, long block, long relsector, long size, long relpos )
    100          {
   \                     WriteFlash:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine6
    101          	long  addr = GetBlockAddr( block, relsector ) + relpos;
   \                     ??CrossCallReturnLabel_6:
   \   00000006   0x.... 0x....      BL       GetBlockAddr
   \   0000000A   0x1836             ADDS     R6,R6,R0
    102          	
    103          	GsnFlashIf_PioReq();
   \   0000000C   0x.... 0x....      BL       GsnFlashIf_PioReq
    104          	if((addr & 0xff))
   \   00000010   0x0630             LSLS     R0,R6,#+24
   \   00000012   0xD00D             BEQ.N    ??WriteFlash_0
    105          	{
    106          		/* work around for bug */
    107          		int remBytes = 	0x100 - (addr & 0xff);
   \   00000014   0xB2F0             UXTB     R0,R6
   \   00000016   0xF5C0 0x7780      RSB      R7,R0,#+256
    108          		if(remBytes < size)
   \   0000001A   0x42AF             CMP      R7,R5
   \   0000001C   0xDA08             BGE.N    ??WriteFlash_0
    109          		{
    110          			GsnFlashIf_FlashProgram(addr, remBytes, data, TRUE);
   \   0000001E   0x2301             MOVS     R3,#+1
   \   00000020   0x4622             MOV      R2,R4
   \   00000022   0x4639             MOV      R1,R7
   \   00000024   0x4630             MOV      R0,R6
   \   00000026   0x.... 0x....      BL       GsnFlashIf_FlashProgram
    111          			size -= remBytes;
   \   0000002A   0x1BED             SUBS     R5,R5,R7
    112          			addr = addr + remBytes;
   \   0000002C   0x19BE             ADDS     R6,R7,R6
    113          			data = (char*)data + remBytes;
   \   0000002E   0x193C             ADDS     R4,R7,R4
    114          		}
    115          	}
    116          	GsnFlashIf_FlashProgram(addr, size, data, TRUE);
   \                     ??WriteFlash_0:
   \   00000030   0x2301             MOVS     R3,#+1
   \   00000032   0x4622             MOV      R2,R4
   \   00000034   0x4629             MOV      R1,R5
   \   00000036   0x4630             MOV      R0,R6
   \   00000038   0x.... 0x....      BL       GsnFlashIf_FlashProgram
    117          	GsnFlashIf_PioRelease();
   \   0000003C   0x.... 0x....      BL       GsnFlashIf_PioRelease
    118              if(size & 3)
   \   00000040   0xF015 0x0F03      TST      R5,#0x3
   \   00000044   0xBF0C             ITE      EQ 
   \   00000046   0xF014 0x0003      ANDSEQ   R0,R4,#0x3
    119              {
    120                  return 0;
    121              }
    122          	if((int)data & 0x3)
   \   0000004A   0x2000             MOVNE    R0,#+0
    123          	{
    124          		return 0;
    125          	}
    126          	return 0;
   \   0000004C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    127          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6:
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x4608             MOV      R0,R1
   \   00000004   0x9E06             LDR      R6,[SP, #+24]
   \   00000006   0x4611             MOV      R1,R2
   \   00000008   0x461D             MOV      R5,R3
   \   0000000A   0x4770             BX       LR
    128          

   \                                 In section .text, align 2, keep-with-next
    129          static int VerifyFlash ( void * data, long block, long relsector, long size, long relpos )
    130          {
   \                     VerifyFlash:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x.... 0x....      BL       ?Subroutine7
    131          #if 1
    132          	long  addr = GetBlockAddr( block, relsector ) + relpos;
   \                     ??CrossCallReturnLabel_8:
   \   00000008   0x.... 0x....      BL       GetBlockAddr
   \   0000000C   0x....             B.N      ?Subroutine1
    133          	UINT8 *pBuf, *pScr, *pDst;
    134          	UINT32 index;
    135          	pBuf = MALLOC(size);
    136          	GsnFlashCache_BlkFetch(addr, (UINT32)pBuf, size, NULL);
    137          	pScr = data;
    138          	pDst = pBuf;
    139          	for(index = 0; index < size; index++)
    140          	{
    141          		if( *pScr++ != *pDst++)
    142          		{
    143          			FREE(pBuf);
    144          			return 1;
    145          		}
    146          	}
    147          	FREE(pBuf);
    148          #endif	
    149          	return 0;
    150          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0x4606             MOV      R6,R0
   \   00000002   0x4620             MOV      R0,R4
   \   00000004   0x.... 0x....      BL       MALLOC
   \   00000008   0x4605             MOV      R5,R0
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0x4622             MOV      R2,R4
   \   0000000E   0x4629             MOV      R1,R5
   \   00000010   0x19B8             ADDS     R0,R7,R6
   \   00000012   0x.... 0x....      BL       GsnFlashCache_BlkFetch
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0xE000             B.N      ??Subroutine1_0
   \                     ??Subroutine1_1:
   \   0000001C   0x1C49             ADDS     R1,R1,#+1
   \                     ??Subroutine1_0:
   \   0000001E   0x42A1             CMP      R1,R4
   \   00000020   0xD20A             BCS.N    ??Subroutine1_2
   \   00000022   0xF818 0x2B01      LDRB     R2,[R8], #+1
   \   00000026   0xF810 0x3B01      LDRB     R3,[R0], #+1
   \   0000002A   0x429A             CMP      R2,R3
   \   0000002C   0xD0F6             BEQ.N    ??Subroutine1_1
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0x.... 0x....      BL       FREE
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xE003             B.N      ??Subroutine1_3
   \                     ??Subroutine1_2:
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x.... 0x....      BL       FREE
   \   0000003E   0x2000             MOVS     R0,#+0
   \                     ??Subroutine1_3:
   \   00000040   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7:
   \   00000000   0x4680             MOV      R8,R0
   \   00000002   0x4608             MOV      R0,R1
   \   00000004   0x9F06             LDR      R7,[SP, #+24]
   \   00000006   0x4611             MOV      R1,R2
   \   00000008   0x461C             MOV      R4,R3
   \   0000000A   0x4770             BX       LR
    151          

   \                                 In section .text, align 2, keep-with-next
    152          static int ReadFlash ( void * data, long block, long blockrel, long datalen )
    153          {
   \                     ReadFlash:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4608             MOV      R0,R1
   \   00000008   0xB082             SUB      SP,SP,#+8
   \   0000000A   0x4615             MOV      R5,R2
   \   0000000C   0x461E             MOV      R6,R3
    154          	long  addr = GetBlockAddr( block, 0 ) + blockrel;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x.... 0x....      BL       GetBlockAddr
   \   00000014   0x....             B.N      ?Subroutine2
    155          #if 1	
    156          	void *pActData;
    157          	int remBytes/*, index*/;
    158          	//long actDLen = datalen;
    159          	pActData = data;
    160          	//GSN_DMA_T GsnDma;
    161          	//GSN_DMA_CHANNEL_CONFIG_T ptChannelConfig;
    162          	if((int)data & 0x3)
    163          	{
    164          		remBytes = (4 - (int)data &0x3);
    165          		data = (char *)data + remBytes;
    166          		datalen -= remBytes;
    167          	}
    168          	
    169          	GsnFlashCache_BlkFetch(addr, (UINT32)data, datalen, NULL);
    170          #if 0	
    171          	if(data != pActData)
    172          	{
    173          		unsigned int lastData;
    174          		char *pTmp;
    175          		
    176          		GsnDma_Open (&GsnDma, NULL, 1);
    177          		ptChannelConfig.channelBitField.dmaCycleType   = GSN_DMACYCLE_MSG_ALTERNATE ;
    178          	    ptChannelConfig.channelBitField.nextUserBurst  = 1;
    179          	    ptChannelConfig.channelBitField.nMinusOne      = 0;
    180          	    ptChannelConfig.channelBitField.rPower         = GSN_ARBITRATION_1024_DMATRANSFER;
    181          	    ptChannelConfig.channelBitField.srcPrtCntl     = 7;
    182          	    ptChannelConfig.channelBitField.destPrtCntl    = 7;
    183          	    ptChannelConfig.channelBitField.srcSize        = GSN_DMA_BYTE_SRC_SIZE;
    184          	    ptChannelConfig.channelBitField.srcInc         = GSN_DMA_BYTE_SRC_INC;
    185          	    ptChannelConfig.channelBitField.destSize       = GSN_DMA_BYTE_DEST_SIZE;
    186          	    ptChannelConfig.channelBitField.destInc        = GSN_DMA_BYTE_DEST_INC;
    187          
    188                  GsnDma_CallBackRegister((GSN_DMA_T *)(&GsnDma),
    189          	                                        (DMACALLBACK_FP)dmaDoneCb,NULL ,
    190          	                                                    0);
    191          	                                                    
    192          	    GsnDma_CycleControl(&GsnDma,&ptChannelConfig, 0,
    193          	    	datalen, data, pActData);
    194                      
    195          	    GsnDma_ChannelEnable(&GsnDma, 0);
    196          
    197          	    GsnDma_Enable(&GsnDma);
    198          	    while (!dmaDoneFlag)
    199                  {
    200                      GsnDma_ChannelSoftwareRequest(&GsnDma,0);
    201                  }
    202                  dmaDoneFlag = 0;
    203          	    addr = addr + datalen;
    204          	    data = (char *)pActData + datalen;
    205          		GsnFlashCache_BlkFetch(addr, (UINT32)&lastData, 4, NULL);
    206          		index = (int)pActData & 0x3;
    207          		pTmp = (char *)&lastData;
    208          		while (remBytes >= index)
    209          		{
    210          			*(char *) data = *(pTmp + index);
    211          			index++;
    212          			data = (char *)data + 1;
    213          		}
    214          		//GsnDma_Disable(&GsnDma);
    215          	    DMA_CPAC_SET(GsnDma.pReg,1); 
    216          		GsnDma_Close(&GsnDma);
    217          	 }
    218          #else	 
    219          	if(data != pActData)
    220          	{
    221          		char lastData[4];
    222          		char *pTmp;
    223          		memcpy(pActData, data, datalen);
    224          		addr = addr + datalen;
    225          		data = (char *)pActData + datalen;
    226          		GsnFlashCache_BlkFetch(addr, (UINT32)lastData, 4, NULL);
    227          								
    228          		pTmp = (char *)lastData;
    229          		while (remBytes)
    230          		{
    231          						*(char *) data = *pTmp++;
    232          						remBytes--;
    233          						data = (char *)data + 1;
    234          		}
    235          	}
    236          #endif	
    237          #else
    238          	GsnFlashIf_PioReq();
    239          	GsnFlashIf_FlashRead(addr, datalen, data);
    240          	GsnFlashIf_PioRelease();
    241          #endif
    242          	return 0;
    243          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   0x182D             ADDS     R5,R5,R0
   \   00000002   0x46A0             MOV      R8,R4
   \   00000004   0xF014 0x0003      ANDS     R0,R4,#0x3
   \   00000008   0xD005             BEQ.N    ??Subroutine2_0
   \   0000000A   0xF1C4 0x0004      RSB      R0,R4,#+4
   \   0000000E   0xF000 0x0703      AND      R7,R0,#0x3
   \   00000012   0x193C             ADDS     R4,R7,R4
   \   00000014   0x1BF6             SUBS     R6,R6,R7
   \                     ??Subroutine2_0:
   \   00000016   0x2300             MOVS     R3,#+0
   \   00000018   0x4632             MOV      R2,R6
   \   0000001A   0x4621             MOV      R1,R4
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0x.... 0x....      BL       GsnFlashCache_BlkFetch
   \   00000022   0x4544             CMP      R4,R8
   \   00000024   0xD015             BEQ.N    ??Subroutine2_1
   \   00000026   0x4632             MOV      R2,R6
   \   00000028   0x4621             MOV      R1,R4
   \   0000002A   0x4640             MOV      R0,R8
   \   0000002C   0x.... 0x....      BL       memcpy
   \   00000030   0xEB06 0x0408      ADD      R4,R6,R8
   \   00000034   0x2300             MOVS     R3,#+0
   \   00000036   0x2204             MOVS     R2,#+4
   \   00000038   0xA900             ADD      R1,SP,#+0
   \   0000003A   0x1970             ADDS     R0,R6,R5
   \   0000003C   0x.... 0x....      BL       GsnFlashCache_BlkFetch
   \   00000040   0xA800             ADD      R0,SP,#+0
   \   00000042   0xE004             B.N      ??Subroutine2_2
   \                     ??Subroutine2_3:
   \   00000044   0xF810 0x1B01      LDRB     R1,[R0], #+1
   \   00000048   0xF804 0x1B01      STRB     R1,[R4], #+1
   \   0000004C   0x1E7F             SUBS     R7,R7,#+1
   \                     ??Subroutine2_2:
   \   0000004E   0x2F00             CMP      R7,#+0
   \   00000050   0xD1F8             BNE.N    ??Subroutine2_3
   \                     ??Subroutine2_1:
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    244          

   \                                 In section .text, align 2, keep-with-next
    245          int BlockCopy( long destblock, long soublock )
    246          {
   \                     BlockCopy:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x460C             MOV      R4,R1
    247          	long  destAddr = GetBlockAddr( destblock, 0 );
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x.... 0x....      BL       GetBlockAddr
   \   0000000C   0x4680             MOV      R8,R0
    248          	long  souAddr = GetBlockAddr( soublock, 0 );
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       GetBlockAddr
   \   00000016   0x4604             MOV      R4,R0
    249          	UINT8 *pBuf, count;
    250          	int index, copySize = BLOCKSIZE << 1;
   \   00000018   0xF44F 0x5600      MOV      R6,#+8192
    251          	do
    252          	{
    253          		copySize = copySize >> 1;
   \                     ??BlockCopy_0:
   \   0000001C   0x1076             ASRS     R6,R6,#+1
    254          		pBuf = MALLOC(copySize);
   \   0000001E   0x4630             MOV      R0,R6
   \   00000020   0x.... 0x....      BL       MALLOC
   \   00000024   0xEA5F 0x0900      MOVS     R9,R0
    255          	}while((pBuf == NULL) && copySize);
   \   00000028   0xD102             BNE.N    ??BlockCopy_1
   \   0000002A   0x2E00             CMP      R6,#+0
   \   0000002C   0xD1F6             BNE.N    ??BlockCopy_0
   \   0000002E   0xE000             B.N      ??BlockCopy_2
    256          	if(copySize == 0)
   \                     ??BlockCopy_1:
   \   00000030   0xB90E             CBNZ.N   R6,??BlockCopy_3
    257          	{
    258          		return 1;
   \                     ??BlockCopy_2:
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE01A             B.N      ??BlockCopy_4
    259          	}
    260          	count = BLOCKSIZE / copySize;
   \                     ??BlockCopy_3:
   \   00000036   0x.... 0x....      BL       ?Subroutine3
    261          	
    262          	GsnFlashIf_PioReq();
    263          	GsnFlashIf_FlashSectorErase(destAddr, TRUE);
   \                     ??CrossCallReturnLabel_1:
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x4640             MOV      R0,R8
   \   0000003E   0x.... 0x....      BL       GsnFlashIf_FlashSectorErase
    264          	GsnFlashIf_PioRelease();
   \   00000042   0x.... 0x....      BL       GsnFlashIf_PioRelease
    265          	
    266          	for(index = 0; index < count; index++)
   \   00000046   0x2700             MOVS     R7,#+0
   \   00000048   0xE00A             B.N      ??BlockCopy_5
    267          	{
    268          		GsnFlashCache_BlkFetch(souAddr, (UINT32)pBuf, copySize, NULL);
   \                     ??BlockCopy_6:
   \   0000004A   0x.... 0x....      BL       ?Subroutine4
    269          		GsnFlashIf_PioReq();
   \                     ??CrossCallReturnLabel_3:
   \   0000004E   0x.... 0x....      BL       GsnFlashIf_PioReq
    270          		GsnFlashIf_FlashProgram(destAddr, copySize, pBuf, TRUE);
   \   00000052   0x.... 0x....      BL       ?Subroutine5
    271          		GsnFlashIf_PioRelease();
   \                     ??CrossCallReturnLabel_5:
   \   00000056   0x.... 0x....      BL       GsnFlashIf_PioRelease
    272          		souAddr += copySize;
   \   0000005A   0x1934             ADDS     R4,R6,R4
    273          		destAddr += copySize;
   \   0000005C   0x44B0             ADD      R8,R6,R8
    274          	}
   \   0000005E   0x1C7F             ADDS     R7,R7,#+1
   \                     ??BlockCopy_5:
   \   00000060   0x42AF             CMP      R7,R5
   \   00000062   0xDBF2             BLT.N    ??BlockCopy_6
    275          	FREE(pBuf);
   \   00000064   0x4648             MOV      R0,R9
   \   00000066   0x.... 0x....      BL       FREE
    276          	return 0;
   \   0000006A   0x2000             MOVS     R0,#+0
   \                     ??BlockCopy_4:
   \   0000006C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    277          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5:
   \   00000000   0x2301             MOVS     R3,#+1
   \   00000002   0x464A             MOV      R2,R9
   \   00000004   0x4631             MOV      R1,R6
   \   00000006   0x4640             MOV      R0,R8
   \   00000008   0x.... 0x....      B.W      GsnFlashIf_FlashProgram

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4:
   \   00000000   0x2300             MOVS     R3,#+0
   \   00000002   0x4632             MOV      R2,R6
   \   00000004   0x4649             MOV      R1,R9
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      B.W      GsnFlashCache_BlkFetch

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   0xF44F 0x5080      MOV      R0,#+4096
   \   00000004   0xFB90 0xF5F6      SDIV     R5,R0,R6
   \   00000008   0xB2ED             UXTB     R5,R5
   \   0000000A   0x.... 0x....      B.W      GsnFlashIf_PioReq
    278          
    279          

   \                                 In section .text, align 2, keep-with-next
    280          int fs_phy_nor_n25q_32mb_3v_65nm( FS_FLASH * flash )
    281          {
    282          	flash->ReadFlash = ReadFlash;       /* read content */
   \                     fs_phy_nor_n25q_32mb_3v_65nm:
   \   00000000   0x....             LDR.N    R1,??DataTable5_1
   \   00000002   0x6301             STR      R1,[R0, #+48]
    283          	flash->EraseFlash = EraseFlash;     /* erase a block */
   \   00000004   0x....             LDR.N    R1,??DataTable5_2
   \   00000006   0x6341             STR      R1,[R0, #+52]
    284            	flash->WriteFlash = WriteFlash;     /* write content */
   \   00000008   0x....             LDR.N    R1,??DataTable5_3
   \   0000000A   0x6381             STR      R1,[R0, #+56]
    285            	flash->VerifyFlash = VerifyFlash;   /* verify content */
   \   0000000C   0x....             LDR.N    R1,??DataTable5_4
   \   0000000E   0x63C1             STR      R1,[R0, #+60]
    286            	flash->BlockCopy = BlockCopy;
   \   00000010   0x....             LDR.N    R1,??DataTable5_5
   \   00000012   0x64C1             STR      R1,[R0, #+76]
    287          #ifdef CONFIG_FROM_SUPERBLOCK
    288            	flash->descblockstart = desc_block_start;
   \   00000014   0x....             LDR.N    R1,??DataTable5
   \   00000016   0x684A             LDR      R2,[R1, #+4]
   \   00000018   0x6182             STR      R2,[R0, #+24]
    289              flash->blockstart = block_start;
   \   0000001A   0x680B             LDR      R3,[R1, #+0]
   \   0000001C   0x6103             STR      R3,[R0, #+16]
    290              flash->maxblock = max_blocks;
    291              flash->descblockend = desc_block_start + DESCBLOCKS - 1;
    292          #else
    293              flash->descblockstart = DESCBLOCKSTART;
    294            	flash->blockstart = BLOCKSTART;     /* where 1st block starts */
    295            	flash->maxblock = MAXBLOCKS;
    296          	flash->descblockend = DESCBLOCKSTART + DESCBLOCKS - 1; /*  num of last desc block  */
    297          #endif
    298          
    299              flash->blocksize = BLOCKSIZE;
    300              flash->sectorsize = SECTORSIZE;
    301              flash->sectorperblock = SECTORPERBLOCK;
   \   0000001E   0x2304             MOVS     R3,#+4
   \   00000020   0x6889             LDR      R1,[R1, #+8]
   \   00000022   0x6001             STR      R1,[R0, #+0]
   \   00000024   0x1C51             ADDS     R1,R2,#+1
   \   00000026   0x61C1             STR      R1,[R0, #+28]
   \   00000028   0xF44F 0x6280      MOV      R2,#+1024
   \   0000002C   0xF44F 0x5180      MOV      R1,#+4096
   \   00000030   0x6041             STR      R1,[R0, #+4]
   \   00000032   0x6082             STR      R2,[R0, #+8]
   \   00000034   0x60C3             STR      R3,[R0, #+12]
    302              flash->descsize = DESCSIZE;         
   \   00000036   0x6141             STR      R1,[R0, #+20]
    303              flash->cacheddescsize = DESCCACHE;                     /*  size of write cache in descriptor  */
   \   00000038   0x6242             STR      R2,[R0, #+36]
    304              return 0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x4770             BX       LR               ;; return
    305          }
    306          
    307          #ifdef S2W_WEB_FS_AVAILABLE
    308          

   \                                 In section .bss, align 4
    309          UINT32 block_start_1, desc_block_start_1, max_blocks_1;
   \                     block_start_1:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     desc_block_start_1:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     max_blocks_1:
   \   00000000                      DS8 4
    310          

   \                                 In section .text, align 2, keep-with-next
    311          void s2w_config_web_fs(UINT32 fsAddress, UINT32 fsSize)
    312          {
    313          	//desc_block_start_1 = fsAddress / BLOCKSIZE_1;
    314              //block_start_1 = desc_block_start_1 + DESCBLOCKS_1;
    315              max_blocks_1 = fsSize / BLOCKSIZE_1;
    316              max_blocks_1 = max_blocks_1 - DESCBLOCKS_1;
   \                     s2w_config_web_fs:
   \   00000000   0x0B08             LSRS     R0,R1,#+12
   \   00000002   0x....             LDR.N    R1,??DataTable5_6
   \   00000004   0x1E80             SUBS     R0,R0,#+2
   \   00000006   0x6008             STR      R0,[R1, #+0]
    317          }
   \   00000008   0x4770             BX       LR               ;; return
    318          

   \                                 In section .text, align 2, keep-with-next
    319          static long GetBlockAddr_1 ( long block, long relsector )
    320          {
    321          	return (webFsOffset + (BLOCKSIZE_1 * block) + (relsector * SECTORSIZE_1));
   \                     GetBlockAddr_1:
   \   00000000   0x....             LDR.N    R2,??DataTable5_7
   \   00000002   0x6812             LDR      R2,[R2, #+0]
   \   00000004   0xEB02 0x3000      ADD      R0,R2,R0, LSL #+12
   \   00000008   0xEB00 0x2041      ADD      R0,R0,R1, LSL #+9
   \   0000000C   0x4770             BX       LR               ;; return
    322          }
    323          

   \                                 In section .text, align 2, keep-with-next
    324          static int EraseFlash_1 ( long block )
    325          {
   \                     EraseFlash_1:
   \   00000000   0xB510             PUSH     {R4,LR}
    326          	long  addr = GetBlockAddr_1( block, 0 );
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      BL       GetBlockAddr_1
   \   00000008                      REQUIRE ?Subroutine0
   \   00000008                      ;; // Fall through to label ?Subroutine0
    327              GsnFlashIf_PioReq();
    328          	GsnFlashIf_FlashErase(addr, BLOCKSIZE_1, TRUE);
    329              GsnFlashIf_PioRelease();
    330          	return 0;
    331          }
    332          

   \                                 In section .text, align 2, keep-with-next
    333          static int WriteFlash_1 ( void * data, long block, long relsector, long size, long relpos )
    334          {
   \                     WriteFlash_1:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine6
    335          	long  addr = GetBlockAddr_1( block, relsector ) + relpos;
   \                     ??CrossCallReturnLabel_7:
   \   00000006   0x.... 0x....      BL       GetBlockAddr_1
   \   0000000A   0x4607             MOV      R7,R0
    336          	
    337          	GsnFlashIf_PioReq();
   \   0000000C   0x.... 0x....      BL       GsnFlashIf_PioReq
    338          #if 0	
    339          	if((addr & 0xff))
    340          	{
    341          		/* work around for bug */
    342          		int remBytes = 	0x100 - (addr & 0xff);
    343          		if(remBytes < size)
    344          		{
    345          			GsnFlashIf_FlashProgram(addr, remBytes, data, TRUE);
    346          			size -= remBytes;
    347          			addr = addr + remBytes;
    348          			data = (char*)data + remBytes;
    349          		}
    350          	}
    351          #endif	
    352          	GsnFlashIf_FlashProgram(addr, size, data, TRUE);
   \   00000010   0x2301             MOVS     R3,#+1
   \   00000012   0x4622             MOV      R2,R4
   \   00000014   0x4629             MOV      R1,R5
   \   00000016   0x19F0             ADDS     R0,R6,R7
   \   00000018   0x.... 0x....      BL       GsnFlashIf_FlashProgram
    353          	GsnFlashIf_PioRelease();
   \   0000001C   0x.... 0x....      BL       GsnFlashIf_PioRelease
    354              if(size & 3)
   \   00000020   0xF015 0x0F03      TST      R5,#0x3
   \   00000024   0xBF0C             ITE      EQ 
   \   00000026   0xF014 0x0003      ANDSEQ   R0,R4,#0x3
    355              {
    356                  return 0;
    357              }
    358          	if((int)data & 0x3)
   \   0000002A   0x2000             MOVNE    R0,#+0
    359          	{
    360          		return 0;
    361          	}
    362          	return 0;
   \   0000002C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    363          }
    364          

   \                                 In section .text, align 2, keep-with-next
    365          static int VerifyFlash_1 ( void * data, long block, long relsector, long size, long relpos )
    366          {
   \                     VerifyFlash_1:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x.... 0x....      BL       ?Subroutine7
    367          #if 1
    368          	long  addr = GetBlockAddr_1( block, relsector ) + relpos;
   \                     ??CrossCallReturnLabel_9:
   \   00000008   0x.... 0x....      BL       GetBlockAddr_1
   \   0000000C                      REQUIRE ?Subroutine1
   \   0000000C                      ;; // Fall through to label ?Subroutine1
    369          	UINT8 *pBuf, *pScr, *pDst;
    370          	UINT32 index;
    371          	pBuf = MALLOC(size);
    372          	GsnFlashCache_BlkFetch(addr, (UINT32)pBuf, size, NULL);
    373          	pScr = data;
    374          	pDst = pBuf;
    375          	for(index = 0; index < size; index++)
    376          	{
    377          		if( *pScr++ != *pDst++)
    378          		{
    379          			FREE(pBuf);
    380          			return 1;
    381          		}
    382          	}
    383          	FREE(pBuf);
    384          #endif	
    385          	return 0;
    386          }
    387          

   \                                 In section .text, align 2, keep-with-next
    388          static int ReadFlash_1 ( void * data, long block, long blockrel, long datalen )
    389          {
   \                     ReadFlash_1:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4608             MOV      R0,R1
   \   00000008   0xB082             SUB      SP,SP,#+8
   \   0000000A   0x4615             MOV      R5,R2
   \   0000000C   0x461E             MOV      R6,R3
    390          	long  addr = GetBlockAddr_1( block, 0 ) + blockrel;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x.... 0x....      BL       GetBlockAddr_1
   \   00000014                      REQUIRE ?Subroutine2
   \   00000014                      ;; // Fall through to label ?Subroutine2
    391          #if 1       
    392          	void *pActData;
    393          	int remBytes;
    394          	//long actDLen = datalen;
    395          	pActData = data;
    396          	//GSN_DMA_T GsnDma;
    397          	//GSN_DMA_CHANNEL_CONFIG_T ptChannelConfig;
    398          	if((int)data & 0x3)
    399          	{
    400          					remBytes = (4 - (int)data &0x3);
    401          					data = (char *)data + remBytes;
    402          					datalen -= remBytes;
    403          	}
    404          	
    405          	GsnFlashCache_BlkFetch(addr, (UINT32)data, datalen, NULL);
    406          #if 0       
    407          	if(data != pActData)
    408          	{
    409          					unsigned int lastData;
    410          					char *pTmp;
    411          					
    412          					GsnDma_Open (&GsnDma, NULL, 1);
    413          					ptChannelConfig.channelBitField.dmaCycleType   = GSN_DMACYCLE_MSG_ALTERNATE ;
    414          		ptChannelConfig.channelBitField.nextUserBurst  = 1;
    415          		ptChannelConfig.channelBitField.nMinusOne	   = 0;
    416          		ptChannelConfig.channelBitField.rPower		   = GSN_ARBITRATION_1024_DMATRANSFER;
    417          		ptChannelConfig.channelBitField.srcPrtCntl	   = 7;
    418          		ptChannelConfig.channelBitField.destPrtCntl    = 7;
    419          		ptChannelConfig.channelBitField.srcSize 	   = GSN_DMA_BYTE_SRC_SIZE;
    420          		ptChannelConfig.channelBitField.srcInc		   = GSN_DMA_BYTE_SRC_INC;
    421          		ptChannelConfig.channelBitField.destSize	   = GSN_DMA_BYTE_DEST_SIZE;
    422          		ptChannelConfig.channelBitField.destInc 	   = GSN_DMA_BYTE_DEST_INC;
    423          
    424          		GsnDma_CallBackRegister((GSN_DMA_T *)(&GsnDma),
    425          														(DMACALLBACK_FP)dmaDoneCb,NULL ,
    426          																	0);
    427          																	
    428          		GsnDma_CycleControl(&GsnDma,&ptChannelConfig, 0,
    429          					datalen, data, pActData);
    430          
    431          		GsnDma_ChannelEnable(&GsnDma, 0);
    432          
    433          		GsnDma_Enable(&GsnDma);
    434          		while (!dmaDoneFlag)
    435          		{
    436          			GsnDma_ChannelSoftwareRequest(&GsnDma,0);
    437          		}
    438          		dmaDoneFlag = 0;
    439          		addr = addr + datalen;
    440          		data = (char *)pActData + datalen;
    441          		GsnFlashCache_BlkFetch(addr, (UINT32)&lastData, 4, NULL);
    442          		index = (int)pActData & 0x3;
    443          		pTmp = (char *)&lastData;
    444          		while (remBytes >= index)
    445          		{
    446          						*(char *) data = *(pTmp + index);
    447          						index++;
    448          						data = (char *)data + 1;
    449          		}
    450          		//GsnDma_Disable(&GsnDma);
    451          		DMA_CPAC_SET(GsnDma.pReg,1); 
    452          		GsnDma_Close(&GsnDma);
    453          	}
    454          #else     
    455          	if(data != pActData)
    456          	{
    457          		char lastData[4];
    458          		char *pTmp;
    459          		memcpy(pActData, data, datalen);
    460          		addr = addr + datalen;
    461          		data = (char *)pActData + datalen;
    462          		GsnFlashCache_BlkFetch(addr, (UINT32)lastData, 4, NULL);
    463          								
    464          		pTmp = (char *)lastData;
    465          		while (remBytes)
    466          		{
    467          						*(char *) data = *pTmp++;
    468          						remBytes--;
    469          						data = (char *)data + 1;
    470          		}
    471          	}
    472          #endif   
    473          #else
    474          	GsnFlashIf_PioReq();
    475          	GsnFlashIf_FlashRead(addr, datalen, data);
    476          	GsnFlashIf_PioRelease();
    477          #endif
    478          	return 0;
    479          }
    480          
    481          

   \                                 In section .text, align 2, keep-with-next
    482          int BlockCopy_1( long destblock, long soublock )
    483          {
   \                     BlockCopy_1:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x460C             MOV      R4,R1
    484          	long  destAddr = GetBlockAddr_1( destblock, 0 );
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x.... 0x....      BL       GetBlockAddr_1
   \   0000000C   0x4680             MOV      R8,R0
    485          	long  souAddr = GetBlockAddr_1( soublock, 0 );
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       GetBlockAddr_1
   \   00000016   0x4604             MOV      R4,R0
    486          	UINT8 *pBuf, count;
    487          	int index, copySize = BLOCKSIZE_1 << 1;
   \   00000018   0xF44F 0x5600      MOV      R6,#+8192
    488          	do
    489          	{
    490          		copySize = copySize >> 1;
   \                     ??BlockCopy_1_0:
   \   0000001C   0x1076             ASRS     R6,R6,#+1
    491          		pBuf = MALLOC(copySize);
   \   0000001E   0x4630             MOV      R0,R6
   \   00000020   0x.... 0x....      BL       MALLOC
   \   00000024   0xEA5F 0x0900      MOVS     R9,R0
    492          	}while((pBuf == NULL) && copySize);
   \   00000028   0xD102             BNE.N    ??BlockCopy_1_1
   \   0000002A   0x2E00             CMP      R6,#+0
   \   0000002C   0xD1F6             BNE.N    ??BlockCopy_1_0
   \   0000002E   0xE000             B.N      ??BlockCopy_1_2
    493          	if(copySize == 0)
   \                     ??BlockCopy_1_1:
   \   00000030   0xB90E             CBNZ.N   R6,??BlockCopy_1_3
    494          	{
    495          		return 1;
   \                     ??BlockCopy_1_2:
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE01A             B.N      ??BlockCopy_1_4
    496          	}
    497          	count = BLOCKSIZE_1 / copySize;
   \                     ??BlockCopy_1_3:
   \   00000036   0x.... 0x....      BL       ?Subroutine3
    498          	
    499          	GsnFlashIf_PioReq();
    500          	GsnFlashIf_FlashSectorErase(destAddr, TRUE);
   \                     ??CrossCallReturnLabel_0:
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x4640             MOV      R0,R8
   \   0000003E   0x.... 0x....      BL       GsnFlashIf_FlashSectorErase
    501          	GsnFlashIf_PioRelease();
   \   00000042   0x.... 0x....      BL       GsnFlashIf_PioRelease
    502          	
    503          	for(index = 0; index < count; index++)
   \   00000046   0x2700             MOVS     R7,#+0
   \   00000048   0xE00A             B.N      ??BlockCopy_1_5
    504          	{
    505          		GsnFlashCache_BlkFetch(souAddr, (UINT32)pBuf, copySize, NULL);
   \                     ??BlockCopy_1_6:
   \   0000004A   0x.... 0x....      BL       ?Subroutine4
    506          		GsnFlashIf_PioReq();
   \                     ??CrossCallReturnLabel_2:
   \   0000004E   0x.... 0x....      BL       GsnFlashIf_PioReq
    507          		GsnFlashIf_FlashProgram(destAddr, copySize, pBuf, TRUE);
   \   00000052   0x.... 0x....      BL       ?Subroutine5
    508          		GsnFlashIf_PioRelease();
   \                     ??CrossCallReturnLabel_4:
   \   00000056   0x.... 0x....      BL       GsnFlashIf_PioRelease
    509          		souAddr += copySize;
   \   0000005A   0x1934             ADDS     R4,R6,R4
    510          		destAddr += copySize;
   \   0000005C   0x44B0             ADD      R8,R6,R8
    511          	}
   \   0000005E   0x1C7F             ADDS     R7,R7,#+1
   \                     ??BlockCopy_1_5:
   \   00000060   0x42AF             CMP      R7,R5
   \   00000062   0xDBF2             BLT.N    ??BlockCopy_1_6
    512          	GsnOsal_ByteRelease(pBuf);
   \   00000064   0x4648             MOV      R0,R9
   \   00000066   0x.... 0x....      BL       _tx_byte_release
    513          	return 0;
   \   0000006A   0x2000             MOVS     R0,#+0
   \                     ??BlockCopy_1_4:
   \   0000006C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    514          }
    515          

   \                                 In section .text, align 2, keep-with-next
    516          int fs_phy_nor_n25q_32mb_3v_65nm_1( FS_FLASH * flash )
    517          {
    518          	flash->ReadFlash = ReadFlash_1;       /* read content */
   \                     fs_phy_nor_n25q_32mb_3v_65nm_1:
   \   00000000   0x....             LDR.N    R1,??DataTable5_8
   \   00000002   0x6301             STR      R1,[R0, #+48]
    519          	flash->EraseFlash = EraseFlash_1;     /* erase a block */
    520            	flash->WriteFlash = WriteFlash_1;     /* write content */
    521            	flash->VerifyFlash = VerifyFlash_1;   /* verify content */
    522            	flash->BlockCopy = BlockCopy_1;
    523          
    524          	//flash->maxblock = MAXBLOCKS_1;
    525          	flash->maxblock = max_blocks_1;
    526          	flash->blocksize = BLOCKSIZE_1;
    527          	flash->sectorsize = SECTORSIZE_1;
   \   00000004   0xF44F 0x7200      MOV      R2,#+512
   \   00000008   0x....             LDR.N    R1,??DataTable5_9
   \   0000000A   0x6341             STR      R1,[R0, #+52]
   \   0000000C   0x....             LDR.N    R1,??DataTable5_10
   \   0000000E   0x6381             STR      R1,[R0, #+56]
   \   00000010   0x....             LDR.N    R1,??DataTable5_11
   \   00000012   0x63C1             STR      R1,[R0, #+60]
   \   00000014   0x....             LDR.N    R1,??DataTable5_12
   \   00000016   0x64C1             STR      R1,[R0, #+76]
   \   00000018   0x....             LDR.N    R1,??DataTable5_6
   \   0000001A   0x6809             LDR      R1,[R1, #+0]
   \   0000001C   0x6001             STR      R1,[R0, #+0]
   \   0000001E   0xF44F 0x5180      MOV      R1,#+4096
   \   00000022   0x6041             STR      R1,[R0, #+4]
   \   00000024   0x6082             STR      R2,[R0, #+8]
    528          	flash->sectorperblock = SECTORPERBLOCK_1;
   \   00000026   0x2208             MOVS     R2,#+8
   \   00000028   0x60C2             STR      R2,[R0, #+12]
    529          	flash->blockstart = BLOCKSTART_1;     /* where 1st block starts */
   \   0000002A   0x2202             MOVS     R2,#+2
   \   0000002C   0x6102             STR      R2,[R0, #+16]
    530          	//flash->blockstart = block_start_1;
    531          	flash->descsize = DESCSIZE_1;         /* 128K      */
   \   0000002E   0x6141             STR      R1,[R0, #+20]
    532          	flash->descblockstart = DESCBLOCKSTART_1;
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x6181             STR      R1,[R0, #+24]
    533          	//flash->descblockstart = desc_block_start_1;
    534          	flash->descblockend = DESCBLOCKSTART_1 + DESCBLOCKS_1 - 1; /*  num of last desc block  */
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x61C1             STR      R1,[R0, #+28]
    535          	//flash->descblockend = desc_block_start_1 + DESCBLOCKS_1 - 1;
    536          	flash->cacheddescsize = DESCCACHE_1;                     /*  size of write cache in descriptor  */
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x6241             STR      R1,[R0, #+36]
    537          	return 0;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x4770             BX       LR               ;; return
    538          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     block_start

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     ReadFlash

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     EraseFlash

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     WriteFlash

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     VerifyFlash

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     BlockCopy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     max_blocks_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     webFsOffset

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x........         DC32     ReadFlash_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x........         DC32     EraseFlash_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x........         DC32     WriteFlash_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x........         DC32     VerifyFlash_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x........         DC32     BlockCopy_1

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "flok">`:
   \   00000000   0x66 0x6C          DC8 "flok"
   \              0x6F 0x6B    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    539          
    540          #endif
    541          
    542          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   BlockCopy
        32   -> FREE
        32   -> GetBlockAddr
        32   -> GsnFlashCache_BlkFetch
        32   -> GsnFlashIf_FlashProgram
        32   -> GsnFlashIf_FlashSectorErase
        32   -> GsnFlashIf_PioRelease
        32   -> GsnFlashIf_PioReq
        32   -> MALLOC
      32   BlockCopy_1
        32   -> GetBlockAddr_1
        32   -> GsnFlashCache_BlkFetch
        32   -> GsnFlashIf_FlashProgram
        32   -> GsnFlashIf_FlashSectorErase
        32   -> GsnFlashIf_PioRelease
        32   -> GsnFlashIf_PioReq
        32   -> MALLOC
        32   -> _tx_byte_release
       8   EraseFlash
         8   -> GetBlockAddr
         8   -> GsnFlashIf_FlashErase
         8   -> GsnFlashIf_PioRelease
         8   -> GsnFlashIf_PioReq
       8   EraseFlash_1
         8   -> GetBlockAddr_1
         8   -> GsnFlashIf_FlashErase
         8   -> GsnFlashIf_PioRelease
         8   -> GsnFlashIf_PioReq
       0   GetBlockAddr
       0   GetBlockAddr_1
       0   GsnFlashIf_PioRelease
       0   GsnFlashIf_PioReq
      32   ReadFlash
        32   -> GetBlockAddr
        32   -> GsnFlashCache_BlkFetch
        32   -> memcpy
      32   ReadFlash_1
        32   -> GetBlockAddr_1
        32   -> GsnFlashCache_BlkFetch
        32   -> memcpy
      24   VerifyFlash
        24   -> FREE
        24   -> GetBlockAddr
        24   -> GsnFlashCache_BlkFetch
        24   -> MALLOC
      24   VerifyFlash_1
        24   -> FREE
        24   -> GetBlockAddr_1
        24   -> GsnFlashCache_BlkFetch
        24   -> MALLOC
      24   WriteFlash
        24   -> GetBlockAddr
        24   -> GsnFlashIf_FlashProgram
        24   -> GsnFlashIf_PioRelease
        24   -> GsnFlashIf_PioReq
      24   WriteFlash_1
        24   -> GetBlockAddr_1
        24   -> GsnFlashIf_FlashProgram
        24   -> GsnFlashIf_PioRelease
        24   -> GsnFlashIf_PioReq
       0   dmaDoneCb
       0   fs_phy_nor_n25q_32mb_3v_65nm
       0   fs_phy_nor_n25q_32mb_3v_65nm_1
       8   memcpy
         8   -> __aeabi_memcpy
      56   s2w_config_fs
        56   -> GsnFlashCache_BlkFetch
        56   -> strncmp
       0   s2w_config_web_fs


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant "flok">
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
      26  ?Subroutine0
      68  ?Subroutine1
      88  ?Subroutine2
      14  ?Subroutine3
      12  ?Subroutine4
      12  ?Subroutine5
      12  ?Subroutine6
      12  ?Subroutine7
     112  BlockCopy
     112  BlockCopy_1
      10  EraseFlash
       8  EraseFlash_1
       8  GetBlockAddr
      14  GetBlockAddr_1
      20  GsnFlashIf_PioRelease
      20  GsnFlashIf_PioReq
      22  ReadFlash
      20  ReadFlash_1
      14  VerifyFlash
      12  VerifyFlash_1
      78  WriteFlash
      46  WriteFlash_1
      12  block_start
          desc_block_start
          max_blocks
       4  block_start_1
       4  desc_block_start_1
       2  dmaDoneCb
      62  fs_phy_nor_n25q_32mb_3v_65nm
      64  fs_phy_nor_n25q_32mb_3v_65nm_1
       4  max_blocks_1
      12  memcpy
      62  s2w_config_fs
      10  s2w_config_web_fs
       4  webFsOffset

 
    28 bytes in section .bss
 1 012 bytes in section .text
 
 960 bytes of CODE memory (+ 52 bytes shared)
  28 bytes of DATA memory

Errors: none
Warnings: none
