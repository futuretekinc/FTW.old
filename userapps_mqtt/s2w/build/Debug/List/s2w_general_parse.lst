###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      19/Nov/2015  15:13:24 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\src\parser\s2w_general_parse.c                #
#    Command line =  E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\src\parser\s2w_general_parse.c -D             #
#                    TX_ENABLE_IAR_LIBRARY_SUPPORT -D IAR -D FIXED_ROM_BUILD  #
#                    -D RUN_ALL_FROM_FLASH -D TM_USE_HTTPD -D S2W_DNS_CLIENT  #
#                    -D NX_INCLUDE_USER_DEFINE_FILE -D S2W_WEB_FS_AVAILABLE   #
#                    -D S2W_EXTFLASH_DRIVER_TEST -D S2W_PWM_SUPPORT -D        #
#                    S2W_MEM_ACCESS -D S2W_FORCE_UART_PORT -D                 #
#                    S2W_EXT_FLASH_FWUP_PUSH_METHOD -D                        #
#                    S2W_NCM_SUPPORT_ENABLE -D S2W_SECURITY_ENTERPRISE_PEAP_V #
#                    0_AVAILABLE -D S2W_EXT_FLASH_FWUP_PULL_METHOD -D         #
#                    S2W_SECURITY_ENTERPRISE_TLS_AVAILABLE -D                 #
#                    S2W_DNS_SERVER_ENABLE -D ADK_OTAFU -D S2W_GSLINK_RAW -D  #
#                    S2W_GSLINK_XML -D S2W_SECURITY_ENTERPRISE_PEAP_V1_AVAILA #
#                    BLE -D S2W_PING_TRACE -D S2W_RF_TEST -D                  #
#                    S2W_SSL_CLIENT_SUPPORT -D S2W_DEFAULT_UART_PARITY=0 -D   #
#                    S2W_DHCP_SERVER_ENABLE -D S2W_SECURITY_WPS_ENABLE -D     #
#                    ADK_PROV_CONFIG_LIMITED_AP -D S2W_WEB_SERVER -D          #
#                    ADK_PROV -D S2W_DEFAULT_UART_SW_FLOW=0 -D                #
#                    S2W_FILE_UPLOAD_API -D S2W_COAP_SUPPORT -D               #
#                    S2W_HTTPD_SSLCERT_UPLOAD -D                              #
#                    S2W_DEFAULT_UART_STOP_BITS=0 -D S2W_FACT_IMAGE_REQ -D    #
#                    S2W_DEFAULT_UART_BAUD=9600 -D S2W_ASYNC_MSG -D           #
#                    S2W_HTTPS_SUPPORT -D S2W_DEFAULT_UART_HW_FLOW=0 -D       #
#                    S2W_SECURITY_ENTERPRISE_FAST_GTC_AVAILABLE -D            #
#                    S2W_WEB_PROV -D S2W_UNASSOC_TXRX_SUPPORT -D S2W_SNTP -D  #
#                    S2W_UART_ENABLE -D S2W_GSLINK_XMLNESTED_PARSER -D        #
#                    S2W_GSLINK -D S2W_SECURITY_ENTERPRISE_TTLS_AVAILABLE -D  #
#                    S2W_ADC_SUPPORT -D S2W_HTTPC_SUPPORT -D                  #
#                    S2W_SECURITY_ENTERPRISE_FAST_MSCHAPV2_AVAILABLE -D       #
#                    S2W_SSL_SERVER_SUPPORT -D ADK_PROV_CONFIG_CLIENT -D      #
#                    S2W_DEFAULT_UART_BITS_PER_CHAR=3 -D S2W_MDNS_ENABLE -lC  #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\Debug\List\ -lA                         #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\Debug\List\ --diag_suppress             #
#                    Pa050,Pe231,Pe177 -o E:\Gainspan\gs2011mxx_SDK_s2w_tls_t #
#                    lslp_5.1.5_GA\userapps_mqtt\s2w\build\Debug\Obj\         #
#                    --debug --endian=little --cpu=Cortex-M3 -e --fpu=None    #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA #
#                    \userapps_mqtt\s2w\build\..\..\..\geps\inc\ -I           #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\core\ -I              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\drivers\ -I           #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\modules\ -I           #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\rtos\ -I              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\netx\ -I              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\netx\netx_bsd_layer\  #
#                    -I E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\user #
#                    apps_mqtt\s2w\build\..\..\..\geps\inc\main\ -I           #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\fs\ -I                #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\fs\hcc\src\ -I        #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\security\src\ -I      #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\geps\inc\security\hw_engine_if #
#                    \ -I E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\us #
#                    erapps_mqtt\s2w\build\..\..\..\geps\inc\security\wpa_if\ #
#                     -I E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\use #
#                    rapps_mqtt\s2w\build\..\..\..\userlib\ncm\inc\ -I        #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\userlib\ -I                    #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\ctx\ -I                          #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\ -I                              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\main\ -I                         #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\hal\ -I                          #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\parser\ -I                       #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\config\ -I                       #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\ -I                              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\adk\otafu\inc\ -I              #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\..\..\adk\provisioning\inc\ -I       #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\mqtt\ -I                         #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\mqtt\ -I                         #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\one_wire\ -I                     #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\one_wire\ -I                     #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\linked_list\ -I                  #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\linked_list\ -I                  #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\mqtt_main\ -I                    #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\mqtt_main\ -I                    #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\inc\mqtt_log\ -I                     #
#                    E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\..\src\mqtt_log\ -Ohz --use_c++_inline  #
#                    -I "C:\Program Files (x86)\IAR Systems\Embedded          #
#                    Workbench 6.5\arm\CMSIS\Include\"                        #
#    List file    =  E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\Debug\List\s2w_general_parse.lst        #
#    Object file  =  E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapp #
#                    s_mqtt\s2w\build\Debug\Obj\s2w_general_parse.o           #
#                                                                             #
#                                                                             #
###############################################################################

E:\Gainspan\gs2011mxx_SDK_s2w_tls_tlslp_5.1.5_GA\userapps_mqtt\s2w\src\parser\s2w_general_parse.c
      1          /*****************************************************************
      2           *
      3          *               COPYRIGHT (c) 2009-2010 GainSpan Corporation
      4          *                         All Rights Reserved
      5          *
      6          * The source code contained or described herein and all documents
      7          * related to the source code ("Material") are owned by GainSpan
      8          * Corporation or its licensors.  Title to the Material remains
      9          * with GainSpan Corporation or its suppliers and licensors.
     10          *
     11          * The Material is protected by worldwide copyright and trade secret
     12          * laws and treaty provisions. No part of the Material may be used,
     13          * copied, reproduced, modified, published, uploaded, posted, transmitted,
     14          * distributed, or disclosed in any way except in accordance with the
     15          * applicable license agreement.
     16          *
     17          * No license under any patent, copyright, trade secret or other
     18          * intellectual property right is granted to or conferred upon you by
     19          * disclosure or delivery of the Materials, either expressly, by
     20          * implication, inducement, estoppel, except in accordance with the
     21          * applicable license agreement.
     22          *
     23          * Unless otherwise agreed by GainSpan in writing, you may not remove or
     24          * alter this notice or any other notice embedded in Materials by GainSpan
     25          * or GainSpan's suppliers or licensors in any way.
     26          *
     27          * $RCSfile: s2w_general_parse.c,v $
     28          *
     29          * Description : s2w parser file
     30          ******************************************************************/
     31          
     32          
     33          /*****************************************************************
     34            * File Inclusions
     35            *****************************************************************/
     36          
     37          #include <ctype.h>

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp int isdigit(int)
   \                     isdigit:
   \   00000000   0x3830             SUBS     R0,R0,#+48
   \   00000002   0x280A             CMP      R0,#+10
   \   00000004   0x4180             SBCS     R0,R0,R0
   \   00000006   0x0FC0             LSRS     R0,R0,#+31
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp int isxdigit(int)
   \                     isxdigit:
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0xF1A0 0x0161      SUB      R1,R0,#+97
   \   00000006   0x2906             CMP      R1,#+6
   \   00000008   0xBF24             ITT      CS 
   \   0000000A   0xF1A0 0x0141      SUBCS    R1,R0,#+65
   \   0000000E   0x2906             CMPCS    R1,#+6
   \   00000010   0xD302             BCC.N    ??isxdigit_0
   \   00000012   0x.... 0x....      BL       isdigit
   \   00000016   0xB100             CBZ.N    R0,??isxdigit_1
   \                     ??isxdigit_0:
   \   00000018   0x2001             MOVS     R0,#+1
   \                     ??isxdigit_1:
   \   0000001A   0xB2C0             UXTB     R0,R0
   \   0000001C   0xBD02             POP      {R1,PC}          ;; return
     38          #include <string.h>

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp void *memcpy(void *, void const *, size_t)
   \                     memcpy:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x.... 0x....      BL       __aeabi_memcpy
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp void *memset(void *, int, size_t)
   \                     memset:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4610             MOV      R0,R2
   \   00000006   0x460A             MOV      R2,R1
   \   00000008   0x4601             MOV      R1,R0
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       __aeabi_memset
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
     39          #include "gsn_includes.h"
     40          #include "hal/s2w.h"
     41          #include "hal/s2w_types.h"
     42          #include "parser/s2w_parse.h"
     43          #include "parser/s2w_process.h"
     44          #include "main/app_main_ctx.h"
     45          //#include "config\app_ncm_config.h"
     46          
     47          extern S2W_PROFILE_T s2wCurrent;
     48          extern APP_MAIN_CTX_T *s2wappMainTaskCtxt;
     49          
     50          /**
     51           ******************************************************************************
     52           * @file s2w_general_parse.c
     53           * @brief S2W Application command process routines.
     54           *      This file contains the s2w application specific implimentation for
     55           *      command processing.
     56          ******************************************************************************/
     57          
     58          /*****************************************************************************
     59            *  Private Variables
     60            *****************************************************************************/
     61          
     62           /*****************************************************************************
     63            *  Public Variables
     64            *****************************************************************************/
     65          
     66          
     67          /*****************************************************************************
     68            *  Private Functions
     69            *****************************************************************************/
     70          PRIVATE UINT8
     71          AppS2wParse_Number(UINT8 *ptr, UINT32 *val, UINT8 hex);
     72          
     73          PUBLIC UINT8
     74          AppS2wParse_ToHex(UINT8 c);
     75          
     76          PRIVATE UINT32
     77          AppS2wParse_KeyValueGet(UINT8 *str, UINT8 *key);
     78          
     79          PRIVATE UINT32
     80          AppS2wParse_PskValueGet(UINT8 *str, UINT8 *key);
     81          
     82          
     83          /*****************************************************************************
     84            *  Public Functions
     85            *****************************************************************************/
     86          
     87          /**
     88           ************************************************************************
     89           * @ingroup S2w-Application
     90           * @brief Returns a pointer to the next parameter in the string.
     91           *        This function finds the next parameter of the string by checking the
     92           *        ',' character.
     93           * @param temp - IN Point to a char pointer which must initially point
     94           *                  to the string to be parsed.  This will be modified.
     95           * @return Pointer to the next parameter.
     96           ************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     97          PUBLIC UINT8 *
     98          AppS2wParse_NextParamGet(UINT8 **temp)
     99          {
   \                     AppS2wParse_NextParamGet:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
    100              char *str = (char *)*temp;
    101              char prev = '\0';
   \   00000006   0xF04F 0x0900      MOV      R9,#+0
   \   0000000A   0x6825             LDR      R5,[R4, #+0]
    102              int quoted = 0;
    103              int done = 0;
    104              char *p;
    105          
    106              if (!*str)
   \   0000000C   0x7828             LDRB     R0,[R5, #+0]
   \   0000000E   0x2700             MOVS     R7,#+0
   \   00000010   0x46C8             MOV      R8,R9
   \   00000012   0xB358             CBZ.N    R0,??AppS2wParse_NextParamGet_0
    107              {
    108                  return NULL;
    109              }
    110          
    111              p = str;
   \   00000014   0x462E             MOV      R6,R5
   \   00000016   0xE000             B.N      ??AppS2wParse_NextParamGet_1
    112              while (isspace(*p))
    113              {
    114                  p++;
   \                     ??AppS2wParse_NextParamGet_2:
   \   00000018   0x1C76             ADDS     R6,R6,#+1
    115              }
   \                     ??AppS2wParse_NextParamGet_1:
   \   0000001A   0x7830             LDRB     R0,[R6, #+0]
   \   0000001C   0x.... 0x....      BL       isspace
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD1F9             BNE.N    ??AppS2wParse_NextParamGet_2
    116          
    117              if (*p == '"')
   \   00000024   0x7830             LDRB     R0,[R6, #+0]
   \   00000026   0x2822             CMP      R0,#+34
   \   00000028   0xBF04             ITT      EQ 
   \   0000002A   0x2701             MOVEQ    R7,#+1
   \   0000002C   0x1C75             ADDEQ    R5,R6,#+1
    118              {
    119                  quoted = 1;
    120                  str = p + 1;
    121              }
    122          
    123              for (p = str; *p; p++)
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0xE005             B.N      ??AppS2wParse_NextParamGet_3
    124              {
    125                  if (*p == ',' && (!quoted || done))
    126                  {
    127                      break;
    128                  }
    129                  else if (*p == '"' && quoted && prev != '\\')
    130                  {
    131                      if (done)
    132                      {
    133                          /* Misquoted parameter */
    134                          return NULL;
    135                      }
    136          
    137                      prev = *p = '\0';
   \                     ??AppS2wParse_NextParamGet_4:
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x7001             STRB     R1,[R0, #+0]
    138                      done = 1;
   \   00000036   0xF04F 0x0801      MOV      R8,#+1
    139                  }
    140          
    141                  prev = *p;
   \                     ??AppS2wParse_NextParamGet_5:
   \   0000003A   0xF810 0x9B01      LDRB     R9,[R0], #+1
   \                     ??AppS2wParse_NextParamGet_3:
   \   0000003E   0x7801             LDRB     R1,[R0, #+0]
   \   00000040   0xB129             CBZ.N    R1,??AppS2wParse_NextParamGet_6
   \   00000042   0x292C             CMP      R1,#+44
   \   00000044   0xD108             BNE.N    ??AppS2wParse_NextParamGet_7
   \   00000046   0xF088 0x0201      EOR      R2,R8,#0x1
   \   0000004A   0x4217             TST      R7,R2
   \   0000004C   0xD1F5             BNE.N    ??AppS2wParse_NextParamGet_5
    142              }
    143          
    144              if (*p)
   \                     ??AppS2wParse_NextParamGet_6:
   \   0000004E   0xB179             CBZ.N    R1,??AppS2wParse_NextParamGet_8
    145              {
    146                  *p = '\0';
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0xF800 0x1B01      STRB     R1,[R0], #+1
    147                  *temp = (UINT8 *) (p + 1);
   \   00000056   0xE00B             B.N      ??AppS2wParse_NextParamGet_8
    148              }
   \                     ??AppS2wParse_NextParamGet_7:
   \   00000058   0x2922             CMP      R1,#+34
   \   0000005A   0xD1EE             BNE.N    ??AppS2wParse_NextParamGet_5
   \   0000005C   0x2F00             CMP      R7,#+0
   \   0000005E   0xBF18             IT       NE 
   \   00000060   0xF1B9 0x0F5C      CMPNE    R9,#+92
   \   00000064   0xD0E9             BEQ.N    ??AppS2wParse_NextParamGet_5
   \   00000066   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000006A   0xD0E2             BEQ.N    ??AppS2wParse_NextParamGet_4
   \                     ??AppS2wParse_NextParamGet_0:
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xE001             B.N      ??AppS2wParse_NextParamGet_9
    149              else
    150              {
    151                  *temp = (UINT8 *) p;
   \                     ??AppS2wParse_NextParamGet_8:
   \   00000070   0x6020             STR      R0,[R4, #+0]
    152              }
    153          
    154              return (UINT8 *) str;
   \   00000072   0x4628             MOV      R0,R5
   \                     ??AppS2wParse_NextParamGet_9:
   \   00000074   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    155          }
    156          
    157          
    158          
    159          /**
    160           ************************************************************************
    161           * @ingroup S2w-Application
    162           * @brief Convert the ASCII string to integer value.
    163           *        This function convert the string to integer.
    164           * @param ptr- IN ASCII string.
    165           * @param val Pointer to a variable to hold the resulting value.
    166           * @return S2W_SUCCESS on success, S2W_EINVAL if the parameter is invalid.
    167           ************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    168          PUBLIC UINT8
    169          AppS2wParse_Int(UINT8 *ptr, UINT32 *val)
    170          {
    171              return AppS2wParse_Number(ptr, val, 0);
   \                     AppS2wParse_Int:
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x....             B.N      AppS2wParse_Number
    172          }
    173          
    174          
    175          
    176          /**
    177           ************************************************************************
    178           * @ingroup S2w-Application
    179           * @brief Convert the ASCII string to hexadecimal value.
    180           * @param ptr ASCII string.
    181           * @param val Pointer to a variable to hold the resulting value.
    182           * @return S2W_SUCCESS on success, S2W_EINVAL if the parameter is invalid.
    183           ************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    184          PUBLIC UINT8
    185          AppS2wParse_Hex(UINT8 *ptr, UINT32 *val)
    186          {
    187              return AppS2wParse_Number(ptr, val, 1);
   \                     AppS2wParse_Hex:
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0x....             B.N      AppS2wParse_Number
    188          }
    189          
    190          
    191          
    192          /**
    193           ************************************************************************
    194           * @ingroup S2w-Application
    195           * @brief Parse the command parameter value and convert to boolean.
    196           * @param ptr Pointer which points to string to be parsed.
    197           * @param val Pointer to hold the value.
    198           * @return S2W_SUCCESS on success, S2W_EINVAL if the parameter is invalid.
    199           ************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    200          PUBLIC UINT8
    201          AppS2wParse_Boolean(UINT8 *ptr, UINT8 *val)
    202          {
   \                     AppS2wParse_Boolean:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0xE000             B.N      ??AppS2wParse_Boolean_0
    203              while (isspace(*ptr))
    204              {
    205                  ptr++;
   \                     ??AppS2wParse_Boolean_1:
   \   00000008   0x1C64             ADDS     R4,R4,#+1
    206              }
   \                     ??AppS2wParse_Boolean_0:
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       isspace
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD1F9             BNE.N    ??AppS2wParse_Boolean_1
    207          
    208              if ((*ptr != '0' && *ptr != '1') || *(ptr + 1) != '\0')
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0x2830             CMP      R0,#+48
   \   00000018   0xBF18             IT       NE 
   \   0000001A   0x2831             CMPNE    R0,#+49
   \   0000001C   0xD101             BNE.N    ??AppS2wParse_Boolean_2
   \   0000001E   0x7861             LDRB     R1,[R4, #+1]
   \   00000020   0xB109             CBZ.N    R1,??AppS2wParse_Boolean_3
    209              {
    210                  return S2W_EINVAL;
   \                     ??AppS2wParse_Boolean_2:
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}
    211              }
    212          
    213              *val = (*ptr == '1');
   \                     ??AppS2wParse_Boolean_3:
   \   00000026   0x2831             CMP      R0,#+49
   \   00000028   0xBF0C             ITE      EQ 
   \   0000002A   0x2001             MOVEQ    R0,#+1
   \   0000002C   0x2000             MOVNE    R0,#+0
   \   0000002E   0x7028             STRB     R0,[R5, #+0]
    214              return S2W_SUCCESS;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    215          }
    216          
    217          
    218          
    219          /**
    220           ************************************************************************
    221           * @ingroup S2w-Application
    222           * @brief Parse the input string, convert the dotted IP string to IP address.
    223           * @param p Pointer which points to string to be parsed.
    224           * @param ip Pointer to the buffer which holds the IP address.
    225           * @return S2W_SUCCESS on success, S2W_EINVAL on failure.
    226           ************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    227          PUBLIC UINT8
    228          AppS2wParse_Ip(UINT8 *p, UINT8 *ip)
    229          {
   \                     AppS2wParse_Ip:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x4688             MOV      R8,R1
    230              UINT32 val;
    231              int digits;
    232              int quad;
    233          
    234              memset(ip, 0, 4);
   \   00000008   0x2204             MOVS     R2,#+4
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x4640             MOV      R0,R8
   \   0000000E   0x.... 0x....      BL       memset
   \   00000012   0xE000             B.N      ??AppS2wParse_Ip_0
    235          
    236              while (isspace(*p))
    237              {
    238                  p++;
   \                     ??AppS2wParse_Ip_1:
   \   00000014   0x1C6D             ADDS     R5,R5,#+1
    239              }
   \                     ??AppS2wParse_Ip_0:
   \   00000016   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_3:
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD1FA             BNE.N    ??AppS2wParse_Ip_1
    240          
    241              for (quad = 0; quad < 4; quad++)
   \   0000001E   0x2600             MOVS     R6,#+0
    242              {
    243                  val = 0;
   \                     ??AppS2wParse_Ip_2:
   \   00000020   0x2700             MOVS     R7,#+0
    244                  digits = 0;
   \   00000022   0x2400             MOVS     R4,#+0
   \   00000024   0xE006             B.N      ??AppS2wParse_Ip_3
    245          
    246                  while (*p)
    247                  {
    248                      if (!isdigit(*p))
    249                      {
    250                          break;
    251                      }
    252          
    253                      val = val * 10 + (*p - '0');
   \                     ??AppS2wParse_Ip_4:
   \   00000026   0xF815 0x1B01      LDRB     R1,[R5], #+1
   \   0000002A   0x200A             MOVS     R0,#+10
   \   0000002C   0x3930             SUBS     R1,R1,#+48
   \   0000002E   0xFB00 0x1707      MLA      R7,R0,R7,R1
    254          
    255                      p++;
    256                      digits++;
   \   00000032   0x1C64             ADDS     R4,R4,#+1
   \                     ??AppS2wParse_Ip_3:
   \   00000034   0x7828             LDRB     R0,[R5, #+0]
   \   00000036   0xB118             CBZ.N    R0,??AppS2wParse_Ip_5
   \   00000038   0x.... 0x....      BL       isdigit
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD1F2             BNE.N    ??AppS2wParse_Ip_4
    257                  }
    258          
    259                  if (!digits || val > 255 || (quad < 3 && *p != '.'))
   \                     ??AppS2wParse_Ip_5:
   \   00000040   0xB1B4             CBZ.N    R4,??AppS2wParse_Ip_6
   \   00000042   0x2FFF             CMP      R7,#+255
   \   00000044   0xD814             BHI.N    ??AppS2wParse_Ip_6
   \   00000046   0x2E03             CMP      R6,#+3
   \   00000048   0xDA02             BGE.N    ??AppS2wParse_Ip_7
   \   0000004A   0x7828             LDRB     R0,[R5, #+0]
   \   0000004C   0x282E             CMP      R0,#+46
   \   0000004E   0xD10F             BNE.N    ??AppS2wParse_Ip_6
    260                  {
    261                      return S2W_EINVAL;
    262                  }
    263          
    264                  ip[quad] = val;
   \                     ??AppS2wParse_Ip_7:
   \   00000050   0xF806 0x7008      STRB     R7,[R6, R8]
    265          
    266                  if (quad < 3)
   \   00000054   0x2E03             CMP      R6,#+3
   \   00000056   0xBFB8             IT       LT 
   \   00000058   0x1C6D             ADDLT    R5,R5,#+1
    267                  {
    268                      p++;
    269                  }
    270              }
   \   0000005A   0x1C76             ADDS     R6,R6,#+1
   \   0000005C   0x2E04             CMP      R6,#+4
   \   0000005E   0xDBDF             BLT.N    ??AppS2wParse_Ip_2
    271          
    272              while (isspace(*p))
   \                     ??AppS2wParse_Ip_8:
   \   00000060   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_2:
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xBF18             IT       NE 
   \   00000068   0x1C6D             ADDNE    R5,R5,#+1
   \   0000006A   0xD1F9             BNE.N    ??AppS2wParse_Ip_8
    273              {
    274                  p++;
    275              }
    276          
    277              if (*p)
   \   0000006C   0x7828             LDRB     R0,[R5, #+0]
   \   0000006E   0xB100             CBZ.N    R0,??AppS2wParse_Ip_9
    278              {
    279                  return S2W_EINVAL;
   \                     ??AppS2wParse_Ip_6:
   \   00000070   0x2002             MOVS     R0,#+2
    280              }
    281          
    282              return S2W_SUCCESS;
   \                     ??AppS2wParse_Ip_9:
   \   00000072   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    283          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0x7828             LDRB     R0,[R5, #+0]
   \   00000002   0x.... 0x....      B.W      isspace
    284          
    285          /**
    286           ************************************************************************
    287           * @ingroup S2w-Application
    288           * @brief Parse the command parameter value and convert to MAC Address.
    289           * @param s Pointer which points to string to be parsed.
    290           * @param mac_addr Pointer to hold buffer which holds the resulting mac address.
    291           *
    292           * @return S2W_SUCCESS on success, S2W_EINVAL if the address is invalid.
    293           ************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    294          PUBLIC UINT8
    295          AppS2wParse_Mac(UINT8 *s, UINT8 *mac_addr)
    296          {
   \                     AppS2wParse_Mac:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    297              UINT32 i, val;
    298             // UINT8 dummy[6]={0x00,0x00,0x00,0x00,0x00,0x00}; // 0 mac
    299             // UINT8 dummy1[6]={0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}; // broadcast mac
    300              memset(mac_addr, 0, S2W_MAC_ADDR_SIZE);
   \   00000008   0x2206             MOVS     R2,#+6
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x4628             MOV      R0,R5
   \   0000000E   0x.... 0x....      BL       memset
    301          
    302              for (i = 0; *s != '\0' && i < 7; i++, s++)
   \   00000012   0x2600             MOVS     R6,#+0
   \                     ??AppS2wParse_Mac_0:
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0xB310             CBZ.N    R0,??AppS2wParse_Mac_1
   \   00000018   0x2E07             CMP      R6,#+7
   \   0000001A   0xD220             BCS.N    ??AppS2wParse_Mac_1
    303              {
    304                  int digits = 0;
   \   0000001C   0x2700             MOVS     R7,#+0
    305          
    306                  val = 0;
   \   0000001E   0x46B8             MOV      R8,R7
   \   00000020   0xE009             B.N      ??AppS2wParse_Mac_2
    307                  while (*s != ':' && *s != '\0' && *s != ' ')
    308                  {
    309                      if (!isxdigit(*s))
   \                     ??AppS2wParse_Mac_3:
   \   00000022   0x.... 0x....      BL       isxdigit
   \   00000026   0xB1F0             CBZ.N    R0,??AppS2wParse_Mac_4
    310                      {
    311                          return S2W_EINVAL;
    312                      }
    313          
    314                      val = val * 16 + AppS2wParse_ToHex(*s);
   \   00000028   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   0000002C   0x.... 0x....      BL       AppS2wParse_ToHex
   \   00000030   0xEB00 0x1808      ADD      R8,R0,R8, LSL #+4
    315                      s++;
    316                      digits++;
   \   00000034   0x1C7F             ADDS     R7,R7,#+1
    317                  }
   \                     ??AppS2wParse_Mac_2:
   \   00000036   0x7821             LDRB     R1,[R4, #+0]
   \   00000038   0x4608             MOV      R0,R1
   \   0000003A   0x283A             CMP      R0,#+58
   \   0000003C   0xBF18             IT       NE 
   \   0000003E   0x2900             CMPNE    R1,#+0
   \   00000040   0xBF18             IT       NE 
   \   00000042   0x2820             CMPNE    R0,#+32
   \   00000044   0xD1ED             BNE.N    ??AppS2wParse_Mac_3
    318          
    319                  if (!digits || digits > 2)
   \   00000046   0xB177             CBZ.N    R7,??AppS2wParse_Mac_4
   \   00000048   0x2F03             CMP      R7,#+3
   \   0000004A   0xDA0C             BGE.N    ??AppS2wParse_Mac_4
    320                  {
    321                      return S2W_EINVAL;
    322                  }
    323          
    324                  if(i<6)
   \   0000004C   0x2E06             CMP      R6,#+6
   \   0000004E   0xBF38             IT       CC 
   \   00000050   0xF806 0x8005      STRBCC   R8,[R6, R5]
    325                  {
    326                  mac_addr[i] = val;
    327              }
    328                  if(*s == '\0')
   \   00000054   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   00000058   0x1C76             ADDS     R6,R6,#+1
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD1DA             BNE.N    ??AppS2wParse_Mac_0
    329          		{
    330          			i++;
    331          			break;
    332          		}
    333              }
    334          //    if((memcmp(mac_addr,dummy,6)== 0) || (memcmp(mac_addr,dummy1,6) == 0))
    335          //    {
    336          //        return S2W_EINVAL;
    337          //    }
    338              return i == 6 ? S2W_SUCCESS : S2W_EINVAL;
   \                     ??AppS2wParse_Mac_1:
   \   0000005E   0x2E06             CMP      R6,#+6
   \   00000060   0xBF08             IT       EQ 
   \   00000062   0x2000             MOVEQ    R0,#+0
   \   00000064   0xD000             BEQ.N    ??AppS2wParse_Mac_5
   \                     ??AppS2wParse_Mac_4:
   \   00000066   0x2002             MOVS     R0,#+2
   \                     ??AppS2wParse_Mac_5:
   \   00000068   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    339          }
    340          
    341          /**
    342           ************************************************************************
    343           * @ingroup S2w-Application
    344           * @brief Parse the IP address and port number from the user input string.
    345           * @param temp Pointer to a char pointer which must initially point
    346           *            to the string to be parsed.
    347           * @param peer_data Pointer to structure which holds the IP address and port
    348           *          number.
    349           *
    350           * @return S2W_SUCCESS on success, S2W_EINVAL if the parameter is invalid.
    351           ************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    352          PUBLIC UINT8
    353          AppS2wParse_AddrPort(UINT8 **temp, S2W_NETDATA_T *peer_data)
    354          {
   \                     AppS2wParse_AddrPort:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    355              UINT8 *p;
    356              UINT32 port;//,len;
    357              UINT8 status;
    358          	ULONG hostIpAddress;
    359          
    360              p = AppS2wParse_NextParamGet(temp);
   \   00000008   0x.... 0x....      BL       AppS2wParse_NextParamGet
   \   0000000C   0x0006             MOVS     R6,R0
    361              if (!p)
   \   0000000E   0xD039             BEQ.N    ??AppS2wParse_AddrPort_0
    362              {
    363                  return S2W_EINVAL;
    364              }
    365          
    366          	if(inet_addr((const char *)p) != -1)
   \   00000010   0x.... 0x....      BL       inet_addr
   \   00000014   0xF110 0x0F01      CMN      R0,#+1
   \   00000018   0xD005             BEQ.N    ??AppS2wParse_AddrPort_1
    367              {
    368              status = AppS2wParse_Ip(p, (UINT8 *) & peer_data->ipAddr);
   \   0000001A   0x1D29             ADDS     R1,R5,#+4
   \   0000001C   0x4630             MOV      R0,R6
   \   0000001E   0x.... 0x....      BL       AppS2wParse_Ip
    369              if (status != S2W_SUCCESS)
   \   00000022   0xB308             CBZ.N    R0,??AppS2wParse_AddrPort_2
    370              {
    371                  return status;
   \   00000024   0xE032             B.N      ??AppS2wParse_AddrPort_3
    372              }
    373          	}
    374          	else
    375          	{
    376                  //len = strlen((char *)p);
    377          		status = GsnNwIf_DnsHostByNameGet(&s2wappMainTaskCtxt->if0.nwifCtx, (UINT8*)p, &hostIpAddress , 5);
   \                     ??AppS2wParse_AddrPort_1:
   \   00000026   0x....             LDR.N    R0,??DataTable2
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF500 0x50A0      ADD      R0,R0,#+5120
   \   0000002E   0x2305             MOVS     R3,#+5
   \   00000030   0xAA01             ADD      R2,SP,#+4
   \   00000032   0x4631             MOV      R1,R6
   \   00000034   0x3050             ADDS     R0,R0,#+80
   \   00000036   0x.... 0x....      BL       GsnNwIf_DnsHostByNameGet
    378          		if (hostIpAddress == 0)
   \   0000003A   0x9801             LDR      R0,[SP, #+4]
   \   0000003C   0xB908             CBNZ.N   R0,??AppS2wParse_AddrPort_4
    379          			return S2W_FAILURE;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xE024             B.N      ??AppS2wParse_AddrPort_3
    380          		peer_data->ipAddr[0] = (hostIpAddress & 0xff000000)>>24 ;			
   \                     ??AppS2wParse_AddrPort_4:
   \   00000042   0x0E00             LSRS     R0,R0,#+24
   \   00000044   0x7128             STRB     R0,[R5, #+4]
    381          		peer_data->ipAddr[1] = (hostIpAddress & 0x00ff0000)>>16;
   \   00000046   0x9801             LDR      R0,[SP, #+4]
   \   00000048   0x0C00             LSRS     R0,R0,#+16
   \   0000004A   0x7168             STRB     R0,[R5, #+5]
    382          		peer_data->ipAddr[2] = (hostIpAddress & 0x0000ff00)>>8;
   \   0000004C   0x9801             LDR      R0,[SP, #+4]
   \   0000004E   0x0A00             LSRS     R0,R0,#+8
   \   00000050   0x71A8             STRB     R0,[R5, #+6]
    383          		peer_data->ipAddr[3] = (hostIpAddress & 0x000000ff);
   \   00000052   0x9801             LDR      R0,[SP, #+4]
   \   00000054   0x71E8             STRB     R0,[R5, #+7]
    384                  S2w_Printf("\r\nIP:%d.%d.%d.%d",peer_data->ipAddr[0],peer_data->ipAddr[1],
    385                             peer_data->ipAddr[2],peer_data->ipAddr[3]);
   \   00000056   0x79E8             LDRB     R0,[R5, #+7]
   \   00000058   0x9000             STR      R0,[SP, #+0]
   \   0000005A   0x79AB             LDRB     R3,[R5, #+6]
   \   0000005C   0x796A             LDRB     R2,[R5, #+5]
   \   0000005E   0x7929             LDRB     R1,[R5, #+4]
   \   00000060   0x.... 0x....      ADR.W    R0,`?<Constant "\\r\\nIP:%d.%d.%d.%d">`
   \   00000064   0x.... 0x....      BL       S2w_Printf
    386          	}
    387          
    388              p = AppS2wParse_NextParamGet(temp);
   \                     ??AppS2wParse_AddrPort_2:
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0x.... 0x....      BL       AppS2wParse_NextParamGet
   \   0000006E   0x0006             MOVS     R6,R0
    389              if (!p)
   \   00000070   0xD008             BEQ.N    ??AppS2wParse_AddrPort_0
    390              {
    391                  return S2W_EINVAL;
    392              }
    393          
    394              status = AppS2wParse_Int(p, &port);
    395              if (status != S2W_SUCCESS || !is_valid_port(port))
   \   00000072   0xA902             ADD      R1,SP,#+8
   \   00000074   0x.... 0x....      BL       AppS2wParse_Int
   \   00000078   0xB920             CBNZ.N   R0,??AppS2wParse_AddrPort_0
   \   0000007A   0x9802             LDR      R0,[SP, #+8]
   \   0000007C   0xB110             CBZ.N    R0,??AppS2wParse_AddrPort_0
   \   0000007E   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000082   0xD301             BCC.N    ??AppS2wParse_AddrPort_5
    396              {
    397                  return S2W_EINVAL;
   \                     ??AppS2wParse_AddrPort_0:
   \   00000084   0x2002             MOVS     R0,#+2
   \   00000086   0xE001             B.N      ??AppS2wParse_AddrPort_3
    398              }
    399          
    400              peer_data->port = port;
   \                     ??AppS2wParse_AddrPort_5:
   \   00000088   0x8068             STRH     R0,[R5, #+2]
    401          
    402              return S2W_SUCCESS;
   \   0000008A   0x2000             MOVS     R0,#+0
   \                     ??AppS2wParse_AddrPort_3:
   \   0000008C   0xB004             ADD      SP,SP,#+16
   \   0000008E   0xBD70             POP      {R4-R6,PC}       ;; return
    403          }
    404          
    405          /**
    406           ************************************************************************
    407           * @ingroup S2w-Application
    408           * @brief Parse the SSID from the input string.
    409           * @param p Pointer which points to the string to be parsed.
    410           * @param ssid Pointer to the buffer which holds the SSID.
    411           * @param lenp Pointer to a variable in which to store the length on the parsed
    412           *         SSID
    413           * @return status
    414           ************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    415          PUBLIC UINT8
    416          AppS2wParse_Ssid(UINT8 *p, UINT8 *ssid, UINT8 *lenp)
    417          {
   \                     AppS2wParse_Ssid:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    418              UINT8 len = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    419          
    420              memset(ssid, 0, S2W_MAX_SSID_LEN);
   \   0000000A   0x2220             MOVS     R2,#+32
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x4628             MOV      R0,R5
   \   00000010   0x.... 0x....      BL       memset
    421          
    422              while (*p)
   \                     ??AppS2wParse_Ssid_0:
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0xB160             CBZ.N    R0,??AppS2wParse_Ssid_1
    423              {
    424                  if (*p == '\\' && *(p + 1) == '"')
   \   00000018   0x285C             CMP      R0,#+92
   \   0000001A   0xBF01             ITTTT    EQ 
   \   0000001C   0x7861             LDRBEQ   R1,[R4, #+1]
   \   0000001E   0x2922             CMPEQ    R1,#+34
   \   00000020   0x2022             MOVEQ    R0,#+34
   \   00000022   0x1C64             ADDEQ    R4,R4,#+1
    425                  {
    426                      *ssid = '"';
    427                      p++;
    428                  }
    429                  else
    430                  {
    431                      *ssid = *p;
    432                  }
    433          
    434                  p++;
    435                  len++;
   \   00000024   0x1C7F             ADDS     R7,R7,#+1
   \   00000026   0x1C64             ADDS     R4,R4,#+1
    436                  ssid++;
    437          
    438                  if (len >= S2W_MAX_SSID_LEN)
   \   00000028   0xB2FF             UXTB     R7,R7
   \   0000002A   0xF805 0x0B01      STRB     R0,[R5], #+1
   \   0000002E   0x2F20             CMP      R7,#+32
   \   00000030   0xDBF0             BLT.N    ??AppS2wParse_Ssid_0
    439                  {
    440                      break;
    441                  }
    442              }
    443              *lenp = len;
   \                     ??AppS2wParse_Ssid_1:
   \   00000032   0x7037             STRB     R7,[R6, #+0]
    444              if (*p)
   \   00000034   0x7820             LDRB     R0,[R4, #+0]
   \   00000036   0xB900             CBNZ.N   R0,??AppS2wParse_Ssid_2
    445              {
    446                  return S2W_EINVAL;
    447              }
    448          
    449              if (len == 0)
   \   00000038   0xB907             CBNZ.N   R7,??AppS2wParse_Ssid_3
    450              {
    451                  return S2W_EINVAL;
   \                     ??AppS2wParse_Ssid_2:
   \   0000003A   0x2002             MOVS     R0,#+2
    452              }
    453          
    454              return S2W_SUCCESS;
   \                     ??AppS2wParse_Ssid_3:
   \   0000003C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    455          }
    456          
    457          
    458          
    459          /**
    460           ************************************************************************
    461           * @ingroup S2w-Application
    462           * @brief Parse the WEP key from user input string.
    463           * @param ptr Pointer which points to string to be parsed.
    464           * @param wep Pointer to the WEP structure to store the key in
    465           * @param idx WEP key index.
    466           * @return Key type on success, 0 if key is invalid.
    467           ************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    468          PUBLIC UINT8
    469          AppS2wParse_WepKey(UINT8 *ptr, S2W_WEPDATA_T *wep, UINT8 idx)
    470          {
   \                     AppS2wParse_WepKey:
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x4607             MOV      R7,R0
   \   00000008   0x4689             MOV      R9,R1
   \   0000000A   0x4615             MOV      R5,R2
    471              UINT8 temp[13];
    472              UINT32 len;
    473          
    474              S2W_ASSERT(idx >= 1 && idx <= 4);
    475          
    476              len = strlen ((const INT8*)ptr);
    477              if (len > 26)
   \   0000000C   0x.... 0x....      BL       strlen
   \   00000010   0x281B             CMP      R0,#+27
   \   00000012   0xD22C             BCS.N    ??AppS2wParse_WepKey_0
    478              {
    479                  return S2W_EINVAL;
    480              }
    481          
    482              len = AppS2wParse_KeyValueGet(ptr, temp);
   \   00000014   0x220D             MOVS     R2,#+13
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xA800             ADD      R0,SP,#+0
   \   0000001A   0x.... 0x....      BL       memset
   \   0000001E   0xE000             B.N      ??AppS2wParse_WepKey_1
   \                     ??AppS2wParse_WepKey_2:
   \   00000020   0x1C7F             ADDS     R7,R7,#+1
   \                     ??AppS2wParse_WepKey_1:
   \   00000022   0x7838             LDRB     R0,[R7, #+0]
   \   00000024   0x.... 0x....      BL       isspace
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD1F9             BNE.N    ??AppS2wParse_WepKey_2
   \   0000002C   0x2600             MOVS     R6,#+0
   \   0000002E   0xE016             B.N      ??AppS2wParse_WepKey_3
   \                     ??AppS2wParse_WepKey_4:
   \   00000030   0xF04F 0x0800      MOV      R8,#+0
   \   00000034   0x2400             MOVS     R4,#+0
   \                     ??AppS2wParse_WepKey_5:
   \   00000036   0x7838             LDRB     R0,[R7, #+0]
   \   00000038   0xB158             CBZ.N    R0,??AppS2wParse_WepKey_6
   \   0000003A   0x.... 0x....      BL       isxdigit
   \   0000003E   0xB1B0             CBZ.N    R0,??AppS2wParse_WepKey_0
   \   00000040   0xF817 0x0B01      LDRB     R0,[R7], #+1
   \   00000044   0x.... 0x....      BL       AppS2wParse_ToHex
   \   00000048   0x1C64             ADDS     R4,R4,#+1
   \   0000004A   0xEB00 0x1808      ADD      R8,R0,R8, LSL #+4
   \   0000004E   0x2C02             CMP      R4,#+2
   \   00000050   0xD3F1             BCC.N    ??AppS2wParse_WepKey_5
   \                     ??AppS2wParse_WepKey_6:
   \   00000052   0x2C02             CMP      R4,#+2
   \   00000054   0xD10B             BNE.N    ??AppS2wParse_WepKey_0
   \   00000056   0xA800             ADD      R0,SP,#+0
   \   00000058   0xF806 0x8000      STRB     R8,[R6, R0]
   \   0000005C   0x1C76             ADDS     R6,R6,#+1
   \                     ??AppS2wParse_WepKey_3:
   \   0000005E   0x7838             LDRB     R0,[R7, #+0]
   \   00000060   0xB108             CBZ.N    R0,??AppS2wParse_WepKey_7
   \   00000062   0x2E0D             CMP      R6,#+13
   \   00000064   0xD3E4             BCC.N    ??AppS2wParse_WepKey_4
    483              if (len != 5 && len != 13)
   \                     ??AppS2wParse_WepKey_7:
   \   00000066   0x2E05             CMP      R6,#+5
   \   00000068   0xBF18             IT       NE 
   \   0000006A   0x2E0D             CMPNE    R6,#+13
   \   0000006C   0xD001             BEQ.N    ??AppS2wParse_WepKey_8
    484              {
    485                  return S2W_EINVAL;
   \                     ??AppS2wParse_WepKey_0:
   \   0000006E   0x2002             MOVS     R0,#+2
   \   00000070   0xE00D             B.N      ??AppS2wParse_WepKey_9
    486              }
    487              idx--;
   \                     ??AppS2wParse_WepKey_8:
   \   00000072   0x1E6D             SUBS     R5,R5,#+1
    488          
    489              memcpy(wep->key[idx], temp, len);
   \   00000074   0xB2ED             UXTB     R5,R5
   \   00000076   0x200D             MOVS     R0,#+13
   \   00000078   0xFB00 0x9005      MLA      R0,R0,R5,R9
   \   0000007C   0x4632             MOV      R2,R6
   \   0000007E   0xA900             ADD      R1,SP,#+0
   \   00000080   0x1D40             ADDS     R0,R0,#+5
   \   00000082   0x.... 0x....      BL       memcpy
    490              wep->keyLen[idx] = len;
   \   00000086   0xEB05 0x0009      ADD      R0,R5,R9
   \   0000008A   0x7046             STRB     R6,[R0, #+1]
    491          
    492              return S2W_SUCCESS;
   \   0000008C   0x2000             MOVS     R0,#+0
   \                     ??AppS2wParse_WepKey_9:
   \   0000008E   0xB005             ADD      SP,SP,#+20
   \   00000090   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    493          }
    494          
    495          /**
    496           ************************************************************************
    497           * @ingroup S2w-Application
    498           * @brief Parse the user input string for SSID, BSSID, channel and
    499           *        scan time values.
    500           * @param ptr Pointer which points to string to be parsed.
    501           * @param params Pointer to structure which will hold the resulting parameters.
    502           * @param cmd Specifies the command for which the parameters
    503           *             are to be parsed (SCAN/ASSOC/WAUTO).
    504           *
    505           * @return S2W_SUCCESS on success, S2W_EINVAL if the parameter is invalid.
    506           ************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    507          PUBLIC UINT8
    508          AppS2wParse_Wcmd(UINT8 *ptr, S2W_WLANDATA_T *params, enum pwc_command cmd)
    509          {
   \                     AppS2wParse_Wcmd:
   \   00000000   0xB5B0             PUSH     {R4,R5,R7,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x460C             MOV      R4,R1
    510              UINT8 *pt = ptr;
    511              UINT8 *temp = ptr;
   \   00000006   0x9001             STR      R0,[SP, #+4]
    512              UINT32 tempint;
    513              UINT8 status,domain,chMax=0;
    514          	UINT32 mode=0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x9102             STR      R1,[SP, #+8]
   \   0000000C   0x4615             MOV      R5,R2
    515          
    516              if (!*pt)
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD070             BEQ.N    ??AppS2wParse_Wcmd_0
    517              {
    518                  return S2W_EINVAL;
    519              }
    520          
    521              if (cmd == pwc_wauto)
   \   00000014   0x....             LDR.N    R7,??DataTable2_1
   \   00000016   0x2D02             CMP      R5,#+2
   \   00000018   0xD10A             BNE.N    ??AppS2wParse_Wcmd_1
    522              {
    523                  /* WAUTO has mode first */
    524                  pt = AppS2wParse_NextParamGet(&temp);
   \   0000001A   0x.... 0x....      BL       ?Subroutine1
    525                  if (!pt)
   \                     ??CrossCallReturnLabel_13:
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD069             BEQ.N    ??AppS2wParse_Wcmd_0
    526                  {
    527                      return S2W_EINVAL;
    528                  }
    529          
    530                  status = AppS2wParse_Int(pt, &mode);
   \   00000022   0xA902             ADD      R1,SP,#+8
   \   00000024   0x.... 0x....      BL       AppS2wParse_Int
    531                  if (status != S2W_SUCCESS)
   \   00000028   0xB9E0             CBNZ.N   R0,??AppS2wParse_Wcmd_2
    532                  {
    533                      return status;
    534                  }
    535                  params->mode = mode;
   \   0000002A   0x9802             LDR      R0,[SP, #+8]
   \   0000002C   0x7020             STRB     R0,[R4, #+0]
   \   0000002E   0xE001             B.N      ??AppS2wParse_Wcmd_3
    536              }
    537          	else
    538          		mode = s2wCurrent.mode;
   \                     ??AppS2wParse_Wcmd_1:
   \   00000030   0x7938             LDRB     R0,[R7, #+4]
   \   00000032   0x9002             STR      R0,[SP, #+8]
    539          
    540              pt = AppS2wParse_NextParamGet(&temp);
   \                     ??AppS2wParse_Wcmd_3:
   \   00000034   0x.... 0x....      BL       ?Subroutine1
    541              if (!pt)
   \                     ??CrossCallReturnLabel_12:
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD05C             BEQ.N    ??AppS2wParse_Wcmd_0
    542              {
    543                  return S2W_EINVAL;
    544              }
    545          
    546              status = AppS2wParse_Ssid(pt, params->ssid, &params->ssidLen);
   \   0000003C   0x1CA2             ADDS     R2,R4,#+2
   \   0000003E   0xF104 0x010A      ADD      R1,R4,#+10
   \   00000042   0x.... 0x....      BL       AppS2wParse_Ssid
    547              if (status != S2W_SUCCESS)
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xBF1C             ITT      NE 
   \   0000004A   0x78A1             LDRBNE   R1,[R4, #+2]
   \   0000004C   0x2900             CMPNE    R1,#+0
   \   0000004E   0xD109             BNE.N    ??AppS2wParse_Wcmd_2
    548              {
    549                  if(((cmd != pwc_scan) && (params->ssidLen > 0))|| ((cmd == pwc_scan) && (params->ssidLen > 0)))
    550                  {
    551                  return status;
    552                  }
    553          
    554              }
    555          
    556              params->validBssid = 0;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x70E0             STRB     R0,[R4, #+3]
    557          
    558              pt = AppS2wParse_NextParamGet(&temp);
   \   00000054   0x.... 0x....      BL       ?Subroutine1
    559              if (!pt)
   \                     ??CrossCallReturnLabel_11:
   \   00000058   0xB930             CBNZ.N   R0,??AppS2wParse_Wcmd_4
    560              {
    561                  if((cmd != pwc_scan)&&(params->ssidLen == 0))
   \   0000005A   0xB115             CBZ.N    R5,??AppS2wParse_Wcmd_5
   \   0000005C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD049             BEQ.N    ??AppS2wParse_Wcmd_0
    562                  {
    563                      return S2W_EINVAL;
    564                  }
    565                  else
    566                  {
    567                      return S2W_SUCCESS;
    568                  }
    569                  //return (cmd == pwc_wauto) ? S2W_SUCCESS/*S2W_EINVAL*/ : S2W_SUCCESS;
    570              }
    571          
    572              if (*pt != '\0')
    573              {
    574                  status = AppS2wParse_Mac(pt, params->bssid);
    575                  if (status != S2W_SUCCESS)
    576                  {
    577                      return status;
    578                  }
    579                  params->validBssid = 1;
    580              }
    581              else
    582              {
    583                 if((cmd != pwc_scan) && (params->ssidLen == 0))
    584                 {
    585                    return S2W_EINVAL;
    586                 }
    587              }
    588          
    589              pt = AppS2wParse_NextParamGet(&temp);
    590              if (!pt)
    591              {
    592                  return S2W_SUCCESS;
    593              }
    594          
    595              status = AppS2wParse_Int(pt, &tempint);
    596              /* Allow 0 to mean default channel */
    597              if (status != S2W_SUCCESS)
    598              {
    599                 return S2W_EINVAL;
    600              }
    601          	if(mode == S2W_WLANDATA_MODE_AP)
    602          	{
    603          		domain = s2wCurrent.lmtdApConf.regDomain;
    604          	}
    605          	else
    606          	{
    607             		 domain= s2wCurrent.regDomain;
    608          	}
    609              switch(domain)
    610              {
    611                 case S2W_DOMAIN_FCC:
    612                     chMax=11;
    613                 break;
    614          
    615                 case S2W_DOMAIN_ETSI:
    616                     chMax=13;
    617                 break;
    618                 case S2W_DOMAIN_TELEC:
    619                     chMax=14;
    620                 break;
    621          
    622                 default:
    623                     chMax=11;
    624                 break;
    625          
    626              }
    627               if (tempint && (tempint < S2W_WLANDATA_CHANNEL_MIN
    628                          || tempint > chMax))
    629              {
    630                  return S2W_EINVAL;
    631              }
    632              params->channel = tempint;
    633          
    634              if (cmd == pwc_scan)
    635              {
    636                  /* SCAN can also have scan time */
    637                  pt = AppS2wParse_NextParamGet(&temp);
    638                  if (pt)
    639                  {
    640                      status = AppS2wParse_Int(pt, &tempint);
    641                      if (status != S2W_SUCCESS || tempint > 10000)// maximum 10 seconds
    642                      {
    643                          return S2W_EINVAL;
    644                      }
    645          
    646                      params->scanTime = tempint;
    647                  }
    648              }
    649          	else
    650          	{	/* optional argument for wa cmd*/
    651          		if (cmd == pwc_assoc)
    652          		{
    653          			pt = AppS2wParse_NextParamGet(&temp);
    654             			if (!pt)
    655              		{
    656                  		return S2W_SUCCESS;
    657              		}
    658          			if(AppS2wParse_Boolean(pt,&globalUseHRssi) != S2W_SUCCESS)
    659          			    return S2W_EINVAL;
    660          		}
    661          	}
    662              return S2W_SUCCESS;
   \                     ??AppS2wParse_Wcmd_5:
   \   00000062   0x2000             MOVS     R0,#+0
   \                     ??AppS2wParse_Wcmd_2:
   \   00000064   0xB004             ADD      SP,SP,#+16
   \   00000066   0xBDB0             POP      {R4,R5,R7,PC}    ;; return
   \                     ??AppS2wParse_Wcmd_4:
   \   00000068   0x7801             LDRB     R1,[R0, #+0]
   \   0000006A   0xB139             CBZ.N    R1,??AppS2wParse_Wcmd_6
   \   0000006C   0x1D21             ADDS     R1,R4,#+4
   \   0000006E   0x.... 0x....      BL       AppS2wParse_Mac
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD1F6             BNE.N    ??AppS2wParse_Wcmd_2
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x70E0             STRB     R0,[R4, #+3]
   \   0000007A   0xE003             B.N      ??AppS2wParse_Wcmd_7
   \                     ??AppS2wParse_Wcmd_6:
   \   0000007C   0xB115             CBZ.N    R5,??AppS2wParse_Wcmd_7
   \   0000007E   0x78A0             LDRB     R0,[R4, #+2]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD038             BEQ.N    ??AppS2wParse_Wcmd_0
   \                     ??AppS2wParse_Wcmd_7:
   \   00000084   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_10:
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD0EA             BEQ.N    ??AppS2wParse_Wcmd_5
   \   0000008C   0xA900             ADD      R1,SP,#+0
   \   0000008E   0x.... 0x....      BL       AppS2wParse_Int
   \   00000092   0xBB80             CBNZ.N   R0,??AppS2wParse_Wcmd_0
   \   00000094   0x9802             LDR      R0,[SP, #+8]
   \   00000096   0x2802             CMP      R0,#+2
   \   00000098   0xBF0C             ITE      EQ 
   \   0000009A   0xF897 0x0288      LDRBEQ   R0,[R7, #+648]
   \   0000009E   0xF897 0x0395      LDRBNE   R0,[R7, #+917]
   \   000000A2   0x2801             CMP      R0,#+1
   \   000000A4   0xD002             BEQ.N    ??AppS2wParse_Wcmd_8
   \   000000A6   0x2802             CMP      R0,#+2
   \   000000A8   0xD002             BEQ.N    ??AppS2wParse_Wcmd_9
   \   000000AA   0xE003             B.N      ??AppS2wParse_Wcmd_10
   \                     ??AppS2wParse_Wcmd_8:
   \   000000AC   0x200D             MOVS     R0,#+13
   \   000000AE   0xE002             B.N      ??AppS2wParse_Wcmd_11
   \                     ??AppS2wParse_Wcmd_9:
   \   000000B0   0x200E             MOVS     R0,#+14
   \   000000B2   0xE000             B.N      ??AppS2wParse_Wcmd_11
   \                     ??AppS2wParse_Wcmd_10:
   \   000000B4   0x200B             MOVS     R0,#+11
   \                     ??AppS2wParse_Wcmd_11:
   \   000000B6   0x9900             LDR      R1,[SP, #+0]
   \   000000B8   0xB109             CBZ.N    R1,??AppS2wParse_Wcmd_12
   \   000000BA   0x4288             CMP      R0,R1
   \   000000BC   0xD31B             BCC.N    ??AppS2wParse_Wcmd_0
   \                     ??AppS2wParse_Wcmd_12:
   \   000000BE   0x7061             STRB     R1,[R4, #+1]
   \   000000C0   0xB975             CBNZ.N   R5,??AppS2wParse_Wcmd_13
   \   000000C2   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_9:
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD0CB             BEQ.N    ??AppS2wParse_Wcmd_5
   \   000000CA   0xA900             ADD      R1,SP,#+0
   \   000000CC   0x.... 0x....      BL       AppS2wParse_Int
   \   000000D0   0xB988             CBNZ.N   R0,??AppS2wParse_Wcmd_0
   \   000000D2   0x9800             LDR      R0,[SP, #+0]
   \   000000D4   0xF242 0x7111      MOVW     R1,#+10001
   \   000000D8   0x4288             CMP      R0,R1
   \   000000DA   0xD20C             BCS.N    ??AppS2wParse_Wcmd_0
   \   000000DC   0x62E0             STR      R0,[R4, #+44]
   \   000000DE   0xE7C0             B.N      ??AppS2wParse_Wcmd_5
   \                     ??AppS2wParse_Wcmd_13:
   \   000000E0   0x2D01             CMP      R5,#+1
   \   000000E2   0xD1BE             BNE.N    ??AppS2wParse_Wcmd_5
   \   000000E4   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_8:
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD0BA             BEQ.N    ??AppS2wParse_Wcmd_5
   \   000000EC   0x....             LDR.N    R1,??DataTable2_2
   \   000000EE   0x.... 0x....      BL       AppS2wParse_Boolean
   \   000000F2   0x2800             CMP      R0,#+0
   \   000000F4   0xD0B5             BEQ.N    ??AppS2wParse_Wcmd_5
   \                     ??AppS2wParse_Wcmd_0:
   \   000000F6   0x2002             MOVS     R0,#+2
   \   000000F8   0xE7B4             B.N      ??AppS2wParse_Wcmd_2
    663          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0xA801             ADD      R0,SP,#+4
   \   00000002   0x....             B.N      AppS2wParse_NextParamGet
    664          
    665          
    666          
    667          /**
    668           ************************************************************************
    669           * @ingroup S2w-Application
    670           * @brief Parse the network config command parameters.
    671           * @param temp Pointer to a char pointer which must initially point
    672           *             to the string to be parsed.
    673           * @param config Pointer to structure which will hold the resulting
    674           *               configuration values.
    675           *
    676           * @return S2W_SUCCESS on success, S2W_EINVAL if the parameter is invalid.
    677           ************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    678          PUBLIC UINT8
    679          AppS2wParse_Nset(UINT8 **temp, S2W_NETCONF_T *config)
    680          {
   \                     AppS2wParse_Nset:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    681              UINT8 status;
    682              UINT8 *p;
    683              /* 1st parameter ip address */
    684              p = AppS2wParse_NextParamGet(temp);
   \   00000006   0x.... 0x....      BL       AppS2wParse_NextParamGet
    685              if (!p)
   \   0000000A   0xB180             CBZ.N    R0,??AppS2wParse_Nset_0
    686              {
    687                  return S2W_EINVAL;
    688              }
    689          
    690              status = AppS2wParse_Ip(p, (UINT8 *) & config->ipAddr);
   \   0000000C   0x1D29             ADDS     R1,R5,#+4
   \   0000000E   0x.... 0x....      BL       AppS2wParse_Ip
    691              if (status != S2W_SUCCESS)
   \   00000012   0xB998             CBNZ.N   R0,??AppS2wParse_Nset_1
    692              {
    693                  return status;
    694              }
    695          
    696              /* 2nd parameter subnet mask address */
    697              p = AppS2wParse_NextParamGet(temp);
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       AppS2wParse_NextParamGet
    698              if (!p)
   \   0000001A   0xB140             CBZ.N    R0,??AppS2wParse_Nset_0
    699              {
    700                  return S2W_EINVAL;
    701              }
    702          
    703              status = AppS2wParse_Ip(p, (UINT8 *) & config->netMask);
    704              if (status != S2W_SUCCESS)
   \   0000001C   0xF105 0x0108      ADD      R1,R5,#+8
   \   00000020   0x.... 0x....      BL       AppS2wParse_Ip
   \   00000024   0xB918             CBNZ.N   R0,??AppS2wParse_Nset_0
    705              {
    706                  return S2W_EINVAL;
    707              }
    708          
    709              /* 3rd parameter gateway address */
    710              p = AppS2wParse_NextParamGet(temp);
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       AppS2wParse_NextParamGet
    711              if (!p)
   \   0000002C   0xB908             CBNZ.N   R0,??AppS2wParse_Nset_2
    712              {
    713                  return S2W_EINVAL;
   \                     ??AppS2wParse_Nset_0:
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xBD32             POP      {R1,R4,R5,PC}
    714              }
    715          
    716              return AppS2wParse_Ip(p, (UINT8 *) & config->gateway);
   \                     ??AppS2wParse_Nset_2:
   \   00000032   0xF105 0x010C      ADD      R1,R5,#+12
   \   00000036   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000003A   0x....             B.N      AppS2wParse_Ip
   \                     ??AppS2wParse_Nset_1:
   \   0000003C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    717          }
    718          
    719          
    720          
    721          /**
    722           ************************************************************************
    723           * @ingroup S2w-Application
    724           * @brief Parse the fwup command parameters.
    725           * @param temp Pointer to a char pointer which must initially point
    726           *             to the string to be parsed.
    727           * @param params Pointer to structure which will hold the resulting
    728           *               configuration values.
    729           *
    730           * @return S2W_SUCCESS on success, S2W_EINVAL if the parameter is invalid.
    731           ************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    732          PUBLIC UINT8
    733          AppS2wParse_Fwup(UINT8 *temp, S2W_FWUP_CONF_T* params)
    734          {
   \                     AppS2wParse_Fwup:
   \   00000000   0xB511             PUSH     {R0,R4,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x460C             MOV      R4,R1
    735              UINT8 status;
    736              UINT8 *p;
    737          
    738              /* 1st parameter server ip address  */
    739              p = AppS2wParse_NextParamGet(&temp);
   \   00000006   0x.... 0x....      BL       ?Subroutine1
    740              if (!p)
   \                     ??CrossCallReturnLabel_7:
   \   0000000A   0xB168             CBZ.N    R0,??AppS2wParse_Fwup_0
    741              {
    742                  return S2W_EINVAL;
    743              }
    744              status = AppS2wParse_Ip(p, (UINT8 *) &params->fwSrvIp);
   \   0000000C   0x4621             MOV      R1,R4
   \   0000000E   0x.... 0x....      BL       AppS2wParse_Ip
    745              if (status != S2W_SUCCESS)
   \   00000012   0xB9F0             CBNZ.N   R0,??AppS2wParse_Fwup_1
    746              {
    747                  return status;
    748              }
    749          
    750              /* 2nd parameter dst port  */
    751              p = AppS2wParse_NextParamGet(&temp);
   \   00000014   0x.... 0x....      BL       ?Subroutine1
    752              if (!p)
   \                     ??CrossCallReturnLabel_6:
   \   00000018   0xB130             CBZ.N    R0,??AppS2wParse_Fwup_0
    753              {
    754                  return S2W_EINVAL;
    755              }
    756              status = AppS2wParse_Int(p,&params->dstPort);
   \   0000001A   0x1D21             ADDS     R1,R4,#+4
   \   0000001C   0x.... 0x....      BL       AppS2wParse_Int
    757              if (status != S2W_SUCCESS)
   \   00000020   0xB9B8             CBNZ.N   R0,??AppS2wParse_Fwup_1
    758              {
    759                  return status;
    760              }
    761          
    762              /* 3rd parameter source port  */
    763              p = AppS2wParse_NextParamGet(&temp);
   \   00000022   0x.... 0x....      BL       ?Subroutine1
    764              if (!p)
   \                     ??CrossCallReturnLabel_5:
   \   00000026   0xB908             CBNZ.N   R0,??AppS2wParse_Fwup_2
    765              {
    766                  return S2W_EINVAL;
   \                     ??AppS2wParse_Fwup_0:
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xBD16             POP      {R1,R2,R4,PC}
    767              }
    768              status = AppS2wParse_Int(p,&params->srcPort);
   \                     ??AppS2wParse_Fwup_2:
   \   0000002C   0xF104 0x0108      ADD      R1,R4,#+8
   \   00000030   0x.... 0x....      BL       AppS2wParse_Int
    769              if (status != S2W_SUCCESS)
   \   00000034   0xB968             CBNZ.N   R0,??AppS2wParse_Fwup_1
    770              {
    771                  return status;
    772              }
    773          
    774              /* 4th parameter retry count  */
    775              p = AppS2wParse_NextParamGet(&temp);
   \   00000036   0x.... 0x....      BL       ?Subroutine1
    776              if (!p)
   \                     ??CrossCallReturnLabel_4:
   \   0000003A   0xB148             CBZ.N    R0,??AppS2wParse_Fwup_3
    777              {
    778          #ifndef S2W_IP2WIFI_SUPPORT
    779                  return S2W_SUCCESS;
    780          #else
    781                  return S2W_EINVAL;
    782          #endif
    783              }
    784              if (*p != '\0')
   \   0000003C   0x7801             LDRB     R1,[R0, #+0]
   \   0000003E   0xB129             CBZ.N    R1,??AppS2wParse_Fwup_4
    785              {
    786                 status = AppS2wParse_Int(p,&params->retry);
   \   00000040   0xF104 0x010C      ADD      R1,R4,#+12
   \   00000044   0x.... 0x....      BL       AppS2wParse_Int
    787                 if (status != S2W_SUCCESS)
   \   00000048   0xB110             CBZ.N    R0,??AppS2wParse_Fwup_3
    788                 {
    789                     return status;
   \   0000004A   0xBD16             POP      {R1,R2,R4,PC}
    790                 }
    791              }
    792              else
    793              {
    794                 params->retry = 10;// default retry 10
   \                     ??AppS2wParse_Fwup_4:
   \   0000004C   0x200A             MOVS     R0,#+10
   \   0000004E   0x60E0             STR      R0,[R4, #+12]
    795              }
    796          #ifdef S2W_IP2WIFI_SUPPORT
    797              /* 5th parameter node ip  */
    798              p = AppS2wParse_NextParamGet(&temp);
    799              if (!p)
    800              {
    801                  return S2W_EINVAL;
    802              }
    803              status = AppS2wParse_Ip(p, (UINT8 *) &params->nodeIp);
    804              if (status != S2W_SUCCESS)
    805              {
    806                  return status;
    807              }
    808          
    809              /* 6th parameter node mask  */
    810              p = AppS2wParse_NextParamGet(&temp);
    811              if (!p)
    812              {
    813                  return S2W_EINVAL;
    814              }
    815              status = AppS2wParse_Ip(p, (UINT8 *) &params->nodMask);
    816              if (status != S2W_SUCCESS)
    817              {
    818                  return status;
    819              }
    820          
    821               /* 7th parameter node gateway  */
    822              p = AppS2wParse_NextParamGet(&temp);
    823              if (!p)
    824              {
    825                  return S2W_EINVAL;
    826              }
    827              status = AppS2wParse_Ip(p, (UINT8 *) &params->nodeGateway);
    828              if (status != S2W_SUCCESS)
    829              {
    830                  return status;
    831              }
    832          #endif
    833              return S2W_SUCCESS;
   \                     ??AppS2wParse_Fwup_3:
   \   00000050   0x2000             MOVS     R0,#+0
   \                     ??AppS2wParse_Fwup_1:
   \   00000052   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    834          
    835          }
    836          
    837          
    838          
    839          /**
    840           ************************************************************************
    841           * @ingroup S2w-Application
    842           * @brief Parse the psk set command parameters.
    843           * @param temp Pointer to a char pointer which must initially point
    844           *             to the string to be parsed.
    845           * @param psk Pointer to which will hold the resulting
    846           *               configuration values.
    847           *
    848           * @return S2W_SUCCESS on success, S2W_EINVAL if the parameter is invalid.
    849           ************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    850          PUBLIC UINT8
    851          AppS2wParse_Psk(UINT8 *temp, UINT8 *psk)
    852          {
   \                     AppS2wParse_Psk:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4688             MOV      R8,R1
    853              UINT8 key[32];
    854              UINT32 len=0;
    855              /* parse the psk  */
    856              len = AppS2wParse_PskValueGet(temp,key);
   \   0000000A   0x2220             MOVS     R2,#+32
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xA800             ADD      R0,SP,#+0
   \   00000010   0x.... 0x....      BL       memset
   \   00000014   0xE000             B.N      ??AppS2wParse_Psk_0
   \                     ??AppS2wParse_Psk_1:
   \   00000016   0x1C64             ADDS     R4,R4,#+1
   \                     ??AppS2wParse_Psk_0:
   \   00000018   0x7820             LDRB     R0,[R4, #+0]
   \   0000001A   0x.... 0x....      BL       isspace
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD1F9             BNE.N    ??AppS2wParse_Psk_1
   \   00000022   0x2600             MOVS     R6,#+0
   \   00000024   0xE014             B.N      ??AppS2wParse_Psk_2
   \                     ??AppS2wParse_Psk_3:
   \   00000026   0x2700             MOVS     R7,#+0
   \   00000028   0x2500             MOVS     R5,#+0
   \                     ??AppS2wParse_Psk_4:
   \   0000002A   0x7820             LDRB     R0,[R4, #+0]
   \   0000002C   0xB158             CBZ.N    R0,??AppS2wParse_Psk_5
   \   0000002E   0x.... 0x....      BL       isxdigit
   \   00000032   0xB198             CBZ.N    R0,??AppS2wParse_Psk_6
   \   00000034   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   00000038   0x.... 0x....      BL       AppS2wParse_ToHex
   \   0000003C   0x1C6D             ADDS     R5,R5,#+1
   \   0000003E   0xEB00 0x1707      ADD      R7,R0,R7, LSL #+4
   \   00000042   0x2D02             CMP      R5,#+2
   \   00000044   0xD3F1             BCC.N    ??AppS2wParse_Psk_4
   \                     ??AppS2wParse_Psk_5:
   \   00000046   0x2D02             CMP      R5,#+2
   \   00000048   0xD108             BNE.N    ??AppS2wParse_Psk_6
   \   0000004A   0xA800             ADD      R0,SP,#+0
   \   0000004C   0x5437             STRB     R7,[R6, R0]
   \   0000004E   0x1C76             ADDS     R6,R6,#+1
   \                     ??AppS2wParse_Psk_2:
   \   00000050   0x7820             LDRB     R0,[R4, #+0]
   \   00000052   0xB108             CBZ.N    R0,??AppS2wParse_Psk_7
   \   00000054   0x2E21             CMP      R6,#+33
   \   00000056   0xD3E6             BCC.N    ??AppS2wParse_Psk_3
    857              if(len!= 32)
   \                     ??AppS2wParse_Psk_7:
   \   00000058   0x2E20             CMP      R6,#+32
   \   0000005A   0xD001             BEQ.N    ??AppS2wParse_Psk_8
    858              {
    859                  return S2W_EINVAL;
   \                     ??AppS2wParse_Psk_6:
   \   0000005C   0x2002             MOVS     R0,#+2
   \   0000005E   0xE005             B.N      ??AppS2wParse_Psk_9
    860              }
    861              memcpy(psk, key, 32);
   \                     ??AppS2wParse_Psk_8:
   \   00000060   0x2220             MOVS     R2,#+32
   \   00000062   0xA900             ADD      R1,SP,#+0
   \   00000064   0x4640             MOV      R0,R8
   \   00000066   0x.... 0x....      BL       memcpy
    862              return S2W_SUCCESS;
   \   0000006A   0x2000             MOVS     R0,#+0
   \                     ??AppS2wParse_Psk_9:
   \   0000006C   0xB008             ADD      SP,SP,#+32
   \   0000006E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    863          }
    864          
    865          
    866          
    867          
    868          
    869          
    870          #ifndef S2W_HAVE_STRNCASECMP
    871          /**
    872           ************************************************************************
    873           * @ingroup S2w-Application
    874           * @brief Compare specified number of characters in two input strings
    875           *    irrespective of the alphabetical case.
    876           * @param s1 Input string 1.
    877           * @param s2 Input string 2.
    878           * @param n Number of bytes to be compared.
    879           ************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    880          PUBLIC INT32
    881          AppS2wParse_StrnCaseCmp(const char *s1, const char *s2, unsigned int n)
    882          {
   \                     AppS2wParse_StrnCaseCmp:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    883              int diff;
    884          
    885              while (n--)
   \                     ??AppS2wParse_StrnCaseCmp_0:
   \   00000008   0x4630             MOV      R0,R6
   \   0000000A   0x1E46             SUBS     R6,R0,#+1
   \   0000000C   0xB188             CBZ.N    R0,??AppS2wParse_StrnCaseCmp_1
    886              {
    887                  if (!*s1 && !*s2)
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xBF04             ITT      EQ 
   \   00000014   0x7828             LDRBEQ   R0,[R5, #+0]
   \   00000016   0x2800             CMPEQ    R0,#+0
   \   00000018   0xD00B             BEQ.N    ??AppS2wParse_StrnCaseCmp_1
    888                  {
    889                      break;
    890                  }
    891          
    892                  diff = toupper(*s1) - toupper(*s2);
   \   0000001A   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   0000001E   0x.... 0x....      BL       toupper
   \   00000022   0x4607             MOV      R7,R0
   \   00000024   0xF815 0x0B01      LDRB     R0,[R5], #+1
   \   00000028   0x.... 0x....      BL       toupper
   \   0000002C   0x1A38             SUBS     R0,R7,R0
    893                  if (diff)
   \   0000002E   0xD0EB             BEQ.N    ??AppS2wParse_StrnCaseCmp_0
    894                  {
    895                      return diff;
   \   00000030   0xBDF2             POP      {R1,R4-R7,PC}
    896                  }
    897                  s1++;
    898                  s2++;
    899              }
    900          
    901              return 0;
   \                     ??AppS2wParse_StrnCaseCmp_1:
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    902          }
    903          #endif
    904          
    905          
    906          /**
    907           ************************************************************************
    908           * @ingroup S2w-Application
    909           * @brief Gets the value of a single ASCII hex character.
    910           *   Doesn't validate the character.  Validation must be done before with
    911           *   isxidigit() or something similar.
    912           * @param -IN  Character
    913           *
    914           * @return Value of the character
    915           ************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    916          PUBLIC UINT8
    917          AppS2wParse_ToHex(UINT8 c)
    918          {
    919              UINT8 val = 0;
   \                     AppS2wParse_ToHex:
   \   00000000   0x2100             MOVS     R1,#+0
    920          
    921              if (c >= '0' && c <= '9')
   \   00000002   0xF1A0 0x0330      SUB      R3,R0,#+48
   \   00000006   0x2B0A             CMP      R3,#+10
   \   00000008   0xBF38             IT       CC 
   \   0000000A   0xF1A0 0x0130      SUBCC    R1,R0,#+48
    922              {
    923                  val = c - '0';
   \   0000000E   0xD30C             BCC.N    ??AppS2wParse_ToHex_0
    924              }
    925              else if (c >= 'A' && c <= 'F')
   \   00000010   0xF1A0 0x0341      SUB      R3,R0,#+65
   \   00000014   0x2B06             CMP      R3,#+6
   \   00000016   0xBF38             IT       CC 
   \   00000018   0xF1A0 0x0137      SUBCC    R1,R0,#+55
    926              {
    927                  val = c - 'A' + 10;
   \   0000001C   0xD305             BCC.N    ??AppS2wParse_ToHex_0
    928              }
    929              else if (c >= 'a' && c <= 'f')
   \   0000001E   0xF1A0 0x0261      SUB      R2,R0,#+97
   \   00000022   0x2A06             CMP      R2,#+6
   \   00000024   0xBF38             IT       CC 
   \   00000026   0xF1A0 0x0157      SUBCC    R1,R0,#+87
    930              {
    931                  val = c - 'a' + 10;
    932              }
    933          
    934              return val;
   \                     ??AppS2wParse_ToHex_0:
   \   0000002A   0xB2C8             UXTB     R0,R1
   \   0000002C   0x4770             BX       LR               ;; return
    935          }
    936          
    937          /**
    938           ************************************************************************
    939           * @ingroup S2w-Application
    940           * @brief Parse the string and convert it to integer,
    941           * @param ptr Pointer to user input string.
    942           * @param val Pointer to buffer to hold the resulting value.
    943           * @param hex Value represents whether the string to be converted to
    944           *            decimal or hexadecimal.
    945           *
    946           * @return S2W_SUCCESS, S2W_EINVAL.
    947           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    948          PRIVATE UINT8
    949          AppS2wParse_Number(UINT8 *ptr, UINT32 *val, UINT8 hex)
    950          {
   \                     AppS2wParse_Number:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x460C             MOV      R4,R1
    951              UINT32 temp = 0;
   \   00000004   0x2600             MOVS     R6,#+0
   \   00000006   0x4605             MOV      R5,R0
   \   00000008   0x4617             MOV      R7,R2
    952          
    953              *val = 0;
   \   0000000A   0x6026             STR      R6,[R4, #+0]
   \   0000000C   0xE000             B.N      ??AppS2wParse_Number_0
    954          
    955              while (isspace(*ptr))
    956              {
    957                  ptr++;
   \                     ??AppS2wParse_Number_1:
   \   0000000E   0x1C6D             ADDS     R5,R5,#+1
    958              }
   \                     ??AppS2wParse_Number_0:
   \   00000010   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1:
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD1FA             BNE.N    ??AppS2wParse_Number_1
    959          
    960              if (hex)
   \   00000018   0xB18F             CBZ.N    R7,??AppS2wParse_Number_2
    961              {
    962                  while (*ptr)
   \                     ??AppS2wParse_Number_3:
   \   0000001A   0x7828             LDRB     R0,[R5, #+0]
   \   0000001C   0xB198             CBZ.N    R0,??AppS2wParse_Number_4
    963                  {
    964                      if (!isxdigit(*ptr))
   \   0000001E   0x.... 0x....      BL       isxdigit
   \   00000022   0xB180             CBZ.N    R0,??AppS2wParse_Number_4
    965                      {
    966                          break;
    967                      }
    968                      temp = temp * 16 + AppS2wParse_ToHex(*ptr);
   \   00000024   0xF815 0x0B01      LDRB     R0,[R5], #+1
   \   00000028   0x.... 0x....      BL       AppS2wParse_ToHex
   \   0000002C   0xEB00 0x1606      ADD      R6,R0,R6, LSL #+4
    969                      ptr++;
   \   00000030   0xE7F3             B.N      ??AppS2wParse_Number_3
    970                  }
    971              }
    972              else
    973              {
    974                  for (; *ptr >= '0' && *ptr <= '9'; ptr++)
    975                  {
    976                      temp = temp * 10 + (*ptr - '0');
   \                     ??AppS2wParse_Number_5:
   \   00000032   0xF815 0x1B01      LDRB     R1,[R5], #+1
   \   00000036   0x200A             MOVS     R0,#+10
   \   00000038   0x3930             SUBS     R1,R1,#+48
   \   0000003A   0xFB00 0x1606      MLA      R6,R0,R6,R1
    977                  }
   \                     ??AppS2wParse_Number_2:
   \   0000003E   0x7828             LDRB     R0,[R5, #+0]
   \   00000040   0x3830             SUBS     R0,R0,#+48
   \   00000042   0x280A             CMP      R0,#+10
   \   00000044   0xD3F5             BCC.N    ??AppS2wParse_Number_5
    978              }
    979          
    980              if (*ptr)
   \                     ??AppS2wParse_Number_4:
   \   00000046   0x7828             LDRB     R0,[R5, #+0]
   \   00000048   0xB918             CBNZ.N   R0,??AppS2wParse_Number_6
    981              {
    982                  while (isspace(*ptr))
    983                  {
    984                      ptr++;
    985                  }
    986          
    987                  if (*ptr)
    988                  {
    989                      return S2W_EINVAL;
    990                  }
    991              }
    992          
    993              *val = temp;
   \                     ??AppS2wParse_Number_7:
   \   0000004A   0x6026             STR      R6,[R4, #+0]
    994              return S2W_SUCCESS;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??AppS2wParse_Number_8:
   \   00000050   0x1C6D             ADDS     R5,R5,#+1
   \                     ??AppS2wParse_Number_6:
   \   00000052   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0:
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD1FA             BNE.N    ??AppS2wParse_Number_8
   \   0000005A   0x7828             LDRB     R0,[R5, #+0]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD0F4             BEQ.N    ??AppS2wParse_Number_7
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0xBDF2             POP      {R1,R4-R7,PC}
    995          }
    996          
    997          
    998          
    999          /**
   1000           ************************************************************************
   1001           * @ingroup S2w-Application
   1002           * @brief Parse the string and convert it to 64 bit integer,
   1003           * @param ptr Pointer to user input string.
   1004           * @param val Pointer to buffer to hold the resulting value.
   1005           *
   1006           * @return S2W_SUCCESS, S2W_EINVAL.
   1007           *************************************************************************/
   1008          

   \                                 In section .text, align 2, keep-with-next
   1009          PUBLIC UINT8
   1010          AppS2wParse_64BitNumber(UINT8 *ptr, ULONG64 *val)
   1011          {
   \                     AppS2wParse_64BitNumber:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x460F             MOV      R7,R1
   1012              ULONG64 temp = 0;
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2500             MOVS     R5,#+0
   1013          
   1014              *val = 0;
   \   00000008   0xE9C7 0x4500      STRD     R4,R5,[R7, #+0]
   \   0000000C   0x4606             MOV      R6,R0
   \   0000000E   0xE000             B.N      ??AppS2wParse_64BitNumber_0
   1015          
   1016              while (isspace(*ptr))
   1017              {
   1018                  ptr++;
   \                     ??AppS2wParse_64BitNumber_1:
   \   00000010   0x1C76             ADDS     R6,R6,#+1
   1019              }
   \                     ??AppS2wParse_64BitNumber_0:
   \   00000012   0x7830             LDRB     R0,[R6, #+0]
   \   00000014   0x.... 0x....      BL       isspace
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD1F9             BNE.N    ??AppS2wParse_64BitNumber_1
   1020          
   1021          
   1022              {
   1023                  for (; *ptr >= '0' && *ptr <= '9'; ptr++)
   \                     ??AppS2wParse_64BitNumber_2:
   \   0000001C   0x7830             LDRB     R0,[R6, #+0]
   \   0000001E   0x3830             SUBS     R0,R0,#+48
   \   00000020   0x280A             CMP      R0,#+10
   \   00000022   0xD20B             BCS.N    ??AppS2wParse_64BitNumber_3
   1024                  {
   1025                      temp = temp * 10 + (*ptr - '0');
   \   00000024   0x200A             MOVS     R0,#+10
   \   00000026   0xFBA0 0x2304      UMULL    R2,R3,R0,R4
   \   0000002A   0xFB00 0x3305      MLA      R3,R0,R5,R3
   \   0000002E   0xF816 0x0B01      LDRB     R0,[R6], #+1
   \   00000032   0x3830             SUBS     R0,R0,#+48
   \   00000034   0x1814             ADDS     R4,R2,R0
   \   00000036   0xEB43 0x75E0      ADC      R5,R3,R0, ASR #+31
   1026                  }
   \   0000003A   0xE7EF             B.N      ??AppS2wParse_64BitNumber_2
   1027              }
   1028          
   1029              if (*ptr)
   \                     ??AppS2wParse_64BitNumber_3:
   \   0000003C   0x7830             LDRB     R0,[R6, #+0]
   \   0000003E   0xB920             CBNZ.N   R0,??AppS2wParse_64BitNumber_4
   1030              {
   1031                  while (isspace(*ptr))
   1032                  {
   1033                      ptr++;
   1034                  }
   1035          
   1036                  if (*ptr)
   1037                  {
   1038                      return S2W_EINVAL;
   1039                  }
   1040              }
   1041          
   1042              *val = temp;
   \                     ??AppS2wParse_64BitNumber_5:
   \   00000040   0xE9C7 0x4500      STRD     R4,R5,[R7, #+0]
   1043              return S2W_SUCCESS;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??AppS2wParse_64BitNumber_6:
   \   00000048   0x1C76             ADDS     R6,R6,#+1
   \                     ??AppS2wParse_64BitNumber_4:
   \   0000004A   0x7830             LDRB     R0,[R6, #+0]
   \   0000004C   0x.... 0x....      BL       isspace
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD1F9             BNE.N    ??AppS2wParse_64BitNumber_6
   \   00000054   0x7830             LDRB     R0,[R6, #+0]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD0F2             BEQ.N    ??AppS2wParse_64BitNumber_5
   \   0000005A   0x2002             MOVS     R0,#+2
   \   0000005C   0xBDF2             POP      {R1,R4-R7,PC}
   1044          }
   1045          

   \                                 In section .text, align 2, keep-with-next
   1046          PUBLIC UINT8
   1047          AppS2wParse_HexString(UINT8 *ptr, UINT8 *val, UINT32 len)
   1048          {
   \                     AppS2wParse_HexString:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   1049              UINT8 status;
   1050              UINT32 i=0,/*j=0,*/ value=0, v = 0;
   \   00000006   0x2700             MOVS     R7,#+0
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0x460D             MOV      R5,R1
   \   0000000C   0x4690             MOV      R8,R2
   \   0000000E   0x9700             STR      R7,[SP, #+0]
   \   00000010   0x2600             MOVS     R6,#+0
   1051              UINT8 indata[5];
   1052              for(i=0;i<len;(i+=2))
   \   00000012   0xE004             B.N      ??AppS2wParse_HexString_0
   1053              {
   1054                  memcpy(indata,ptr,2);
   1055                  indata[2]='\0';
   1056                  status = AppS2wParse_Hex(indata, &value);
   1057                  if(status != GSN_SUCCESS)
   1058                  {
   1059                      return S2W_EINVAL;
   1060                  }
   1061                  //S2w_Printf("\r\nVal:%x\r\n",value);
   1062                  v = ((v << 8) | value);
   \                     ??AppS2wParse_HexString_1:
   \   00000014   0x9900             LDR      R1,[SP, #+0]
   \   00000016   0xEA41 0x2606      ORR      R6,R1,R6, LSL #+8
   1063                  //val[j++] = value;
   1064                  ptr += 2;
   \   0000001A   0x1CA4             ADDS     R4,R4,#+2
   \   0000001C   0x1CBF             ADDS     R7,R7,#+2
   \                     ??AppS2wParse_HexString_0:
   \   0000001E   0x4547             CMP      R7,R8
   \   00000020   0xD20F             BCS.N    ??AppS2wParse_HexString_2
   \   00000022   0x2202             MOVS     R2,#+2
   \   00000024   0x4621             MOV      R1,R4
   \   00000026   0xA801             ADD      R0,SP,#+4
   \   00000028   0x.... 0x....      BL       memcpy
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF88D 0x0006      STRB     R0,[SP, #+6]
   \   00000032   0xA900             ADD      R1,SP,#+0
   \   00000034   0xA801             ADD      R0,SP,#+4
   \   00000036   0x.... 0x....      BL       AppS2wParse_Hex
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD0EA             BEQ.N    ??AppS2wParse_HexString_1
   \   0000003E   0x2002             MOVS     R0,#+2
   \   00000040   0xE001             B.N      ??AppS2wParse_HexString_3
   1065              }
   1066              *((UINT32*)val) = v;
   \                     ??AppS2wParse_HexString_2:
   \   00000042   0x602E             STR      R6,[R5, #+0]
   1067              return status;
   \   00000044   0xB2C0             UXTB     R0,R0
   \                     ??AppS2wParse_HexString_3:
   \   00000046   0xB004             ADD      SP,SP,#+16
   \   00000048   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1068          }
   1069          
   1070          /**
   1071           ***************************************************************************
   1072           * @ingroup S2w-Application
   1073           * @brief Parse the command parameter and convert to ascii string to WEP key
   1074           * @param str pointer which points to string to be parsed.
   1075           * @param key pointer to buffer which holds the resulting key.
   1076           *
   1077           * @return length of key.
   1078           ****************************************************************************/
   1079          PRIVATE UINT32
   1080          AppS2wParse_PskValueGet(UINT8 *str, UINT8 *key)
   1081          {
   1082              UINT32 val = 0, i, j;
   1083          
   1084              memset(key, 0, 32);
   1085          
   1086              while (isspace(*str))
   1087              {
   1088                  str++;
   1089              }
   1090          
   1091              for (j = 0; *str != '\0' && j < 33; j++)
   1092              {
   1093                  for (val = 0, i = 0; i < 2 && *str != '\0'; str++, i++)
   1094                  {
   1095                      if (!isxdigit(*str))
   1096                      {
   1097                          return 0;
   1098          
   1099                      }
   1100          
   1101                      val = val * 16 + AppS2wParse_ToHex(*str);
   1102                  }
   1103          
   1104                  if (i != 2)
   1105                  {
   1106                      return 0;
   1107                  }
   1108          
   1109                  key[j] = val;
   1110              }
   1111              return j;
   1112          }
   1113          
   1114          
   1115          /**
   1116           ***************************************************************************
   1117           * @ingroup S2w-Application
   1118           * @brief Parse the command parameter and convert to ascii string to WEP key
   1119           * @param str pointer which points to string to be parsed.
   1120           * @param key pointer to buffer which holds the resulting key.
   1121           *
   1122           * @return length of key.
   1123           ****************************************************************************/
   1124          PRIVATE UINT32
   1125          AppS2wParse_KeyValueGet(UINT8 *str, UINT8 *key)
   1126          {
   1127              UINT32 val = 0, i, j;
   1128          
   1129              memset(key, 0, 13);
   1130          
   1131              while (isspace(*str))
   1132              {
   1133                  str++;
   1134              }
   1135          
   1136              for (j = 0; *str != '\0' && j < 13; j++)
   1137              {
   1138                  for (val = 0, i = 0; i < 2 && *str != '\0'; str++, i++)
   1139                  {
   1140                      if (!isxdigit(*str))
   1141                      {
   1142                          return 0;
   1143                      }
   1144          
   1145                      val = val * 16 + AppS2wParse_ToHex(*str);
   1146                  }
   1147          
   1148                  if (i != 2)
   1149                  {
   1150                      return 0;
   1151                  }
   1152          
   1153                  key[j] = val;
   1154              }
   1155              return j;
   1156          }
   1157          

   \                                 In section .text, align 2, keep-with-next
   1158          PUBLIC BOOL
   1159          AppS2wParse_MdnsKeyValidate(UINT8 *str, UINT32 len)
   1160          {
   1161          	UINT32 i;
   1162          	for(i=0;i<len;i++)
   \                     AppS2wParse_MdnsKeyValidate:
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0xE000             B.N      ??AppS2wParse_MdnsKeyValidate_0
   \                     ??AppS2wParse_MdnsKeyValidate_1:
   \   00000004   0x1C52             ADDS     R2,R2,#+1
   \                     ??AppS2wParse_MdnsKeyValidate_0:
   \   00000006   0x428A             CMP      R2,R1
   \   00000008   0xD204             BCS.N    ??AppS2wParse_MdnsKeyValidate_2
   1163          	{
   1164          		if(*(str + i) == '=')		
   \   0000000A   0x5C13             LDRB     R3,[R2, R0]
   \   0000000C   0x2B3D             CMP      R3,#+61
   \   0000000E   0xD1F9             BNE.N    ??AppS2wParse_MdnsKeyValidate_1
   1165          			return TRUE;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR
   1166          	}
   1167          	return FALSE;
   \                     ??AppS2wParse_MdnsKeyValidate_2:
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR               ;; return
   1168          }

   \                                 In section .text, align 2, keep-with-next
   1169          PUBLIC UINT8
   1170          AppS2wParse_IntToChar(UINT8 c)
   1171          {
   1172              UINT8 val = 0;
   \                     AppS2wParse_IntToChar:
   \   00000000   0x2100             MOVS     R1,#+0
   1173          
   1174              if (c <= 9)
   \   00000002   0x280A             CMP      R0,#+10
   \   00000004   0xBFB8             IT       LT 
   \   00000006   0xF100 0x0130      ADDLT    R1,R0,#+48
   1175              {
   1176                  val = c + '0';
   \   0000000A   0xDB05             BLT.N    ??AppS2wParse_IntToChar_0
   1177              }
   1178              else if (c >= 0xA && c <= 0xF)
   \   0000000C   0xF1A0 0x020A      SUB      R2,R0,#+10
   \   00000010   0x2A06             CMP      R2,#+6
   \   00000012   0xBF38             IT       CC 
   \   00000014   0xF100 0x0137      ADDCC    R1,R0,#+55
   1179              {
   1180                  val = c + 'A' -0xA;
   1181              }
   1182              else if (c >= 0xa && c <= 0xf)
   1183              {
   1184                  val = c + 'a' - 0xa;
   1185              }
   1186              return val;
   \                     ??AppS2wParse_IntToChar_0:
   \   00000018   0xB2C8             UXTB     R0,R1
   \   0000001A   0x4770             BX       LR               ;; return
   1187          }
   1188          

   \                                 In section .text, align 2, keep-with-next
   1189          PUBLIC VOID
   1190          AppS2wParse_IntToStr(UINT8 *inPtr ,UINT8 *val, UINT32 len)
   1191          {
   \                     AppS2wParse_IntToStr:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   1192          	UINT8 i;	
   1193          	for(i = 0 ; i<len ; i++)
   \   00000008   0x2700             MOVS     R7,#+0
   \   0000000A   0xE00F             B.N      ??AppS2wParse_IntToStr_0
   1194          	{
   1195          		val[i*2]	   = AppS2wParse_IntToChar((inPtr[i]>>4 ) & 0x0f);
   \                     ??AppS2wParse_IntToStr_1:
   \   0000000C   0x5D38             LDRB     R0,[R7, R4]
   \   0000000E   0x0900             LSRS     R0,R0,#+4
   \   00000010   0x.... 0x....      BL       AppS2wParse_IntToChar
   \   00000014   0xF805 0x0017      STRB     R0,[R5, R7, LSL #+1]
   1196          		val[(2*i) + 1] = AppS2wParse_IntToChar((inPtr[i] ) & 0x0f);
   \   00000018   0x5D38             LDRB     R0,[R7, R4]
   \   0000001A   0xF000 0x000F      AND      R0,R0,#0xF
   \   0000001E   0x.... 0x....      BL       AppS2wParse_IntToChar
   \   00000022   0xEB05 0x0147      ADD      R1,R5,R7, LSL #+1
   1197          	}
   \   00000026   0x1C7F             ADDS     R7,R7,#+1
   \   00000028   0x7048             STRB     R0,[R1, #+1]
   \   0000002A   0xB2FF             UXTB     R7,R7
   \                     ??AppS2wParse_IntToStr_0:
   \   0000002C   0x42B7             CMP      R7,R6
   \   0000002E   0xD3ED             BCC.N    ??AppS2wParse_IntToStr_1
   1198          }
   \   00000030   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     s2wappMainTaskCtxt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     s2wCurrent

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     globalUseHRssi

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\r\\nIP:%d.%d.%d.%d">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012IP:%d.%d.%d.%d"
   \              0x49 0x50    
   \              0x3A 0x25    
   \              0x64 0x2E    
   \              0x25 0x64    
   \              0x2E 0x25    
   \              0x64 0x2E    
   \              0x25 0x64    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   1199          
   1200          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   AppS2wParse_64BitNumber
        24   -> isspace
      32   AppS2wParse_AddrPort
        32   -> AppS2wParse_Int
        32   -> AppS2wParse_Ip
        32   -> AppS2wParse_NextParamGet
        32   -> GsnNwIf_DnsHostByNameGet
        32   -> S2w_Printf
        32   -> inet_addr
      16   AppS2wParse_Boolean
        16   -> isspace
      16   AppS2wParse_Fwup
        16   -> AppS2wParse_Int
        16   -> AppS2wParse_Ip
        16   -> AppS2wParse_NextParamGet
       0   AppS2wParse_Hex
         0   -> AppS2wParse_Number
      40   AppS2wParse_HexString
        40   -> AppS2wParse_Hex
        40   -> memcpy
       0   AppS2wParse_Int
         0   -> AppS2wParse_Number
       0   AppS2wParse_IntToChar
      24   AppS2wParse_IntToStr
        24   -> AppS2wParse_IntToChar
      24   AppS2wParse_Ip
        24   -> isdigit
        24   -> isspace
        24   -> memset
      24   AppS2wParse_Mac
        24   -> AppS2wParse_ToHex
        24   -> isxdigit
        24   -> memset
       0   AppS2wParse_MdnsKeyValidate
      32   AppS2wParse_NextParamGet
        32   -> isspace
      16   AppS2wParse_Nset
         0   -> AppS2wParse_Ip
        16   -> AppS2wParse_Ip
        16   -> AppS2wParse_NextParamGet
      24   AppS2wParse_Number
        24   -> AppS2wParse_ToHex
        24   -> isspace
        24   -> isxdigit
      56   AppS2wParse_Psk
        56   -> AppS2wParse_ToHex
        56   -> isspace
        56   -> isxdigit
        56   -> memcpy
        56   -> memset
      24   AppS2wParse_Ssid
        24   -> memset
      24   AppS2wParse_StrnCaseCmp
        24   -> toupper
       0   AppS2wParse_ToHex
      32   AppS2wParse_Wcmd
        32   -> AppS2wParse_Boolean
        32   -> AppS2wParse_Int
        32   -> AppS2wParse_Mac
        32   -> AppS2wParse_NextParamGet
        32   -> AppS2wParse_Ssid
      48   AppS2wParse_WepKey
        48   -> AppS2wParse_ToHex
        48   -> isspace
        48   -> isxdigit
        48   -> memcpy
        48   -> memset
        48   -> strlen
       0   isdigit
       8   isxdigit
         8   -> isdigit
       8   memcpy
         8   -> __aeabi_memcpy
       8   memset
         8   -> __aeabi_memset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  ?<Constant "\r\nIP:%d.%d.%d.%d">
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       6  ?Subroutine0
       4  ?Subroutine1
      94  AppS2wParse_64BitNumber
     144  AppS2wParse_AddrPort
      52  AppS2wParse_Boolean
      84  AppS2wParse_Fwup
       4  AppS2wParse_Hex
      76  AppS2wParse_HexString
       4  AppS2wParse_Int
      28  AppS2wParse_IntToChar
      50  AppS2wParse_IntToStr
     118  AppS2wParse_Ip
     108  AppS2wParse_Mac
      24  AppS2wParse_MdnsKeyValidate
     120  AppS2wParse_NextParamGet
      62  AppS2wParse_Nset
     100  AppS2wParse_Number
     114  AppS2wParse_Psk
      62  AppS2wParse_Ssid
      54  AppS2wParse_StrnCaseCmp
      46  AppS2wParse_ToHex
     250  AppS2wParse_Wcmd
     148  AppS2wParse_WepKey
      10  isdigit
      30  isxdigit
      12  memcpy
      20  memset

 
 1 856 bytes in section .text
 
 1 784 bytes of CODE memory (+ 72 bytes shared)

Errors: none
Warnings: none
