###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.5.4819/W32 for ARM      02/Apr/2015  05:02:25 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\src\main\app_startup.c                        #
#    Command line =  F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\src\main\app_startup.c -D APP_MDNS_ENABLE -D  #
#                    ADK_OTAFU_ENABLE -D TX_ENABLE_IAR_LIBRARY_SUPPORT -D     #
#                    IAR -D TM_USE_HTTPD -D GSN_GSLINK -D                     #
#                    NX_INCLUDE_USER_DEFINE_FILE -D INLINE=static -lC         #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\Debug\List\ -lA                         #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\Debug\List\ --diag_suppress Pa050 -o    #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\Debug\Obj\ --no_cse --no_unroll         #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59 #
#                    \adk\tls_low_power\build\..\..\..\geps\inc\ -I           #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\geps\inc\core\ -I              #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\geps\inc\drivers\ -I           #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\geps\inc\modules\ -I           #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\geps\inc\modules\http\ -I      #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\geps\inc\rtos\ -I              #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\geps\inc\netx\ -I              #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\geps\inc\netx\netx_bsd_layer\  #
#                    -I F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\ #
#                    tls_low_power\build\..\..\..\geps\inc\main\ -I           #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\geps\inc\fs\ -I                #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\geps\inc\fs\hcc\src\ -I        #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\geps\inc\security\src\ -I      #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\geps\inc\security\hw_engine_if #
#                    \ -I F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\ad #
#                    k\tls_low_power\build\..\..\..\geps\inc\security\wpa_if\ #
#                     -I F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk #
#                    \tls_low_power\build\..\..\..\userlib\ncm\inc\ -I        #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\userlib\ -I                    #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\inc\ctx\ -I                          #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\inc\ -I                              #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\inc\main\ -I                         #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\inc\parser\ -I                       #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\inc\config\ -I                       #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\src\ -I                              #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\inc\tls\ -I                          #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\inc\rtc_mem\ -I                      #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\inc\sm\ -I                           #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\inc\ncm\ -I                          #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\inc\debug\ -I                        #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\adk\otafu\inc\ -I              #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\adk\provisioning\inc\ -I       #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\system\gsn\inc\ -I             #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\system\gsn\inc\core\ -I        #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\system\gsn\inc\drivers\ -I     #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\system\gsn\inc\modules\ -I     #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\system\\rtos\tx\ -I            #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\system\nw\ -I                  #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\system\nw\netx\ -I             #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\system\nw\netx\netx_bsd_layer\ #
#                     -I F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk #
#                    \tls_low_power\build\..\..\..\system\main\ -I            #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\system\security\src\ -I        #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\system\security\\inc\hw_engine #
#                    _if\ -I F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59 #
#                    \adk\tls_low_power\build\..\..\..\system\security\src\wp #
#                    a_supplicant-1.0\src\ -I F:\Development\GS2000\5.1.5\02_ #
#                    Apr_2015_05_01_59\adk\tls_low_power\build\..\..\..\syste #
#                    m\fs\hcc\src\ -I F:\Development\GS2000\5.1.5\02_Apr_2015 #
#                    _05_01_59\adk\tls_low_power\build\..\..\..\system\ -I    #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\inc\ -I                              #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\inc\ctx\ -I                          #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\inc\main\ -I                         #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\inc\fs_if\ -I                        #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\inc\config\ -I                       #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\inc\sm\ -I                           #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\inc\ncm\ -I                          #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\inc\debug\ -I                        #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\inc\tls\ -I                          #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\inc\rtc_mem\ -I                      #
#                    F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\..\..\..\adk\provisioning\inc\ -Ol      #
#                    --use_c++_inline -I "C:\Program Files (x86)\IAR          #
#                    Systems\Embedded Workbench 6.5\arm\CMSIS\Include\"       #
#    List file    =  F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\Debug\List\app_startup.lst              #
#    Object file  =  F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls #
#                    _low_power\build\Debug\Obj\app_startup.o                 #
#                                                                             #
#                                                                             #
###############################################################################

F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\adk\tls_low_power\src\main\app_startup.c
      1          /*******************************************************************************
      2          *
      3          *               COPYRIGHT (c) 2012-2013 GainSpan Corporation
      4          *                         All Rights Reserved
      5          *
      6          * The source code contained or described herein and all documents
      7          * related to the source code ("Material") are owned by GainSpan
      8          * Corporation or its licensors.  Title to the Material remains
      9          * with GainSpan Corporation or its suppliers and licensors.
     10          *
     11          * The Material is protected by worldwide copyright and trade secret
     12          * laws and treaty provisions. No part of the Material may be used,
     13          * copied, reproduced, modified, published, uploaded, posted, transmitted,
     14          * distributed, or disclosed in any way except in accordance with the
     15          * applicable license agreement.
     16          *
     17          * No license under any patent, copyright, trade secret or other
     18          * intellectual property right is granted to or conferred upon you by
     19          * disclosure or delivery of the Materials, either expressly, by
     20          * implication, inducement, estoppel, except in accordance with the
     21          * applicable license agreement.
     22          *
     23          * Unless otherwise agreed by GainSpan in writing, you may not remove or
     24          * alter this notice or any other notice embedded in Materials by GainSpan
     25          * or GainSpan's suppliers or licensors in any way.
     26          *
     27          * $RCSfile: app_startup.c,v $
     28          *******************************************************************************/
     29          /*
     30          Different memory section placed in SRAM is given below
     31          	  _________________________________________ 0x20000000
     32          	|										|
     33          	|	16KB reserved for ROM PATCH AUTO	|
     34          	|										|
     35          	|---------------------------------------|
     36          	|										|
     37          	|	8KB reserved for ROM PATCH FPT		|
     38          	|										|
     39          	|---------------------------------------|
     40          	|										|
     41          	|	8KB reserved for predefined heap	|
     42          	|			  ( Heap 1) 				|
     43          	|---------------------------------------|
     44          	|										|
     45          	|										|
     46          	|	CSTACK, 							|
     47          	|										|
     48          	|	(APP + ROM )data section			|
     49          	|										|
     50          	|---------------------------------------|
     51          	|										|
     52          	|	Heap 2								|
     53          	|										|
     54          	|---------------------------------------|
     55          	|										|
     56          	|	App Code							|
     57          	|										|
     58          	|---------------------------------------|
     59          	|										|
     60          	|	Heap 3								|
     61          	|										|
     62          	|---------------------------------------| 0x2007FFFF
     63          
     64          */
     65          /*****************************************************************************
     66            * File Inclusions
     67            ****************************************************************************/
     68          
     69          #include "gsn_includes.h"

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp void *memset(void *, int, size_t)
   \                     memset:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0010             MOVS     R0,R2
   \   00000006   0x000A             MOVS     R2,R1
   \   00000008   0x0001             MOVS     R1,R0
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       __aeabi_memset
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0xBD10             POP      {R4,PC}          ;; return

  		 void *ctx, struct wpa_sm *sm);
  		                   ^
"F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\geps\inc\supplicant\rsn_supp\pmksa_cache.h",52  Warning[Pe231]: 
          declaration is not visible outside of function

  struct rsn_pmksa_cache_entry * pmksa_cache_get_current(struct wpa_sm *sm);
                                                                ^
"F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\geps\inc\supplicant\rsn_supp\pmksa_cache.h",60  Warning[Pe231]: 
          declaration is not visible outside of function

  void pmksa_cache_clear_current(struct wpa_sm *sm);
                                        ^
"F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\geps\inc\supplicant\rsn_supp\pmksa_cache.h",61  Warning[Pe231]: 
          declaration is not visible outside of function

  int pmksa_cache_set_current(struct wpa_sm *sm, const u8 *pmkid,
                                     ^
"F:\Development\GS2000\5.1.5\02_Apr_2015_05_01_59\geps\inc\supplicant\rsn_supp\pmksa_cache.h",62  Warning[Pe231]: 
          declaration is not visible outside of function
     70          
     71          /*****************************************************************************
     72          * Private Definitions
     73          ****************************************************************************/
     74          #pragma section = "BSS_SECTION"       /* Points to the BSS segment of FLASH code */
     75          #pragma section = "DATA_SECTION"      /* Points to the DATA section of FLASH code */
     76          #pragma section = "APP_READWRITE_SECTION"      /* Points to the readwrite section of FLASH code */
     77          #pragma section = "DATA_INIT_SECTION" /* Points to the DATA INIT section of FLASH code */
     78          
     79          #pragma section = "ROM_PATCH_FPT_SECTION" /* Points to the ROM PATCH FPT section in FLASH code */
     80          #pragma section = "APP_CODE_SECTION" /* Points to the APP CODE section in FLASH code */
     81          #pragma section = "ROM_PATCH_AUTO" /* Points to the ROM PATCH section in FLASH code */
     82          #pragma section = "FREE_MEM" /* Points to the ROM PATCH section in FLASH code */
     83          #pragma section = "APP_CODE_SECTION_1"
     84          #pragma section = "APP_CODE_SECTION_2"
     85          

   \                                 In section .bss, align 1
     86          UINT8 noFlashFetchFlag = 0;
   \                     noFlashFetchFlag:
   \   00000000                      DS8 1
     87          
     88          /*****************************************************************************
     89           *NO FLASH FETCH
     90           ****************************************************************************/
     91          #ifdef NO_FLASH_FETCH
     92          /* Download the code directly in to SRAM using the debugger and run
     93          This Mathod will be used during development phase */
     94          
     95          #define GSN_ROM_PATCH_FPT_LOCATION 0x20004000 /* 0x20004000 Location in RAM where the ROM
     96                                                        function pointers has to be copied */
     97          #define START_OF_SRAM 0x20000000
     98          #define END_OF_SRAM   0x2007FFFF
     99          #define APP_CODE_START          0x20040000
    100          #define ROM_PATCH_AUTO_SECTION_LENGTH 0x2000
    101          #define CONTROL_BLOCK_SIZE 0x1000
    102          
    103          /* These two varibales are part of ROM code */
    104          #define APP_STARTUP_COPY_PROG( src, len, dst ) memcpy((char*)dst, (char*)src, len);
    105          /*Get word aligned address*/
    106          #define WORD_ALIGNED_ADDR(a)	(((a) & (~0x3)) + 0x4)
    107          
    108          /* This marks the start of free memory available for byte-pool creation */
    109          __no_init int GsnSramFreeMem @ "FREE_MEM";
    110          
    111          /* Used for cerating Byte Memory pools to be used as heap*/
    112          GSN_BYTE_POOL_LINK_T bytePool[3] ;//= {{,NULL}, {, NULL}, {,NU}};
    113          unsigned int* codeAddrArray[4];
    114          
    115          extern INT32 App_Main( void );
    116          
    117          /*****************************************************************************
    118           *Function definitions
    119           ****************************************************************************/
    120          void GsnStartup_Main( void )
    121          {
    122              unsigned int* bssEnd = __section_end("BSS_SECTION");
    123              unsigned int* bssStart = __section_begin("BSS_SECTION");
    124              unsigned int* dataEnd = __section_end("DATA_SECTION");
    125              unsigned int* dataStart = __section_begin("DATA_SECTION");
    126              unsigned int* dataInitStart = __section_begin("DATA_INIT_SECTION");
    127              unsigned int* romPatchFptEnd = __section_end("ROM_PATCH_FPT_SECTION");
    128              unsigned int* romPatchFptStart = __section_begin("ROM_PATCH_FPT_SECTION");
    129          
    130              unsigned int* appCodeEnd = __section_end("APP_CODE_SECTION");
    131              unsigned int* appCodeStart = (unsigned int*)APP_CODE_START;
    132          
    133              unsigned int* app_code_1_start = __section_begin("APP_CODE_SECTION_1");
    134              unsigned int* app_code_1_end = __section_end("APP_CODE_SECTION_1");
    135              unsigned int* app_code_2_start = __section_begin("APP_CODE_SECTION_2");
    136              unsigned int* app_code_2_end   = __section_end("APP_CODE_SECTION_2");
    137          
    138              unsigned int length, src, dst, heap1Start/*, heap2Start*/;
    139              int heap1Length/*, heap2Length*/;
    140          
    141          codeAddrArray[0] = app_code_1_start ;
    142          codeAddrArray[1] = app_code_1_end ;
    143          codeAddrArray[2] = app_code_2_start ;
    144          codeAddrArray[3] = app_code_2_end ;
    145          
    146          	noFlashFetchFlag = 1;
    147          
    148          
    149          	/* 1. Copy from SRAM to initialize the "initialised data" in data	segment. */
    150          	length = (unsigned int)( dataEnd )- (unsigned int)(dataStart);
    151          	src = (unsigned int)dataInitStart; /* Location in Flash */
    152          	dst = (unsigned int)dataStart; /* RAM location to copy, i.e. the DATA section */
    153              APP_STARTUP_COPY_PROG(src, length, dst);
    154          
    155          
    156          	/*
    157               * 2. Copy patch function pointers from the flash to the SRAM.
    158               */
    159              length = (unsigned int)( romPatchFptEnd )- (unsigned int)(romPatchFptStart);
    160              src = (unsigned int)romPatchFptStart;/* Location in Flash for ROM PATCH FPT */
    161              dst = GSN_ROM_PATCH_FPT_LOCATION;/* RAM location to copy */
    162              APP_STARTUP_COPY_PROG(src, length,  dst );
    163          
    164          	/* 3. Won't be copying the APP code. Calculate the heap at the end*/
    165          	heap1Start = (((unsigned int)&GsnSramFreeMem) & ~0x3) + 0x8;
    166          	heap1Length = (unsigned int)(appCodeStart)  - heap1Start;
    167          	if( heap1Length < 0 )
    168          	{
    169          		/* ERROR APP CODE Section is more than what it can fit in the SRAM. */
    170          		while(1);
    171          	}
    172          
    173          	/*heap2Start = (((unsigned int)appCodeEnd) & ~0x3) + 0x8;
    174          	heap2Length = 0x2008FFFF - heap2Start;*/
    175          
    176          
    177          	/*
    178          	* 4. Initialize BSS segment. memset uninitailize data.
    179          	*/
    180          
    181              src = (unsigned int)bssStart;
    182              length = (unsigned int)( bssEnd )- (unsigned int)( bssStart );
    183              memset((void*) src, 0, length );
    184          
    185              /*5.  Initialize the free memory section to use tx byte pool for dynamic memory
    186                 allocation */
    187              tx_byte_pool_create(&bytePool[0].bPool, NULL, (void*)heap1Start,
    188                                         (UINT32)heap1Length );
    189          #if 0
    190              tx_byte_pool_create(&bytePool[1].bPool, NULL, (void*)heap2Start,
    191                                         (UINT32)heap2Length );
    192          	pGsnBytePoolHead =  ( heap2Length > heap1Length ) ?
    193          					&bytePool[1] : &bytePool[0];
    194          	pGsnBytePoolHead->pNext = ( heap2Length > heap1Length ) ?
    195          					&bytePool[0] : &bytePool[1];
    196          
    197          	pGsnBytePoolHead->pNext->pNext = NULL;
    198          #else
    199          	pGsnBytePoolHead = &bytePool[0];
    200          	pGsnBytePoolHead->pNext = NULL;
    201          #endif
    202          
    203          	/* Assign 3 SRAM blocks to wlan*/
    204          	 *((volatile UINT32 *)(0x40080008)) = (UINT32)0x1C;
    205          
    206          	/* Call APP MAIN */
    207              App_Main();
    208              while(1)
    209              {
    210              	__WFI();
    211              }
    212          }
    213          
    214          #else /*Store code in to FLASH. prefetch/flash cache during run time*/
    215          /*****************************************************************************
    216           *FLASH FETCH
    217           ****************************************************************************/
    218          
    219          /*****************************************************************************
    220           *Function prototypes
    221           ****************************************************************************/
    222          extern GSN_BYTE_POOL_LINK_T *pGsnBytePoolHead;
    223          
    224          extern UINT32 romFwImageFlashAddr;/* This holds the starting address of the App Fw*/
    225          
    226          extern INT32 App_Main( void );
    227          
    228          BOOL
    229          App_FlashIfFlashCheckAndConfigure();
    230          /*****************************************************************************
    231           *Private definitions
    232           ****************************************************************************/
    233          #define APP_STARTUP_COPY_PROG( dst, src, len) GsnFlashCache_BlkFetch( src, dst, len, NULL );
    234          
    235          #define CB1_RESERVED_SIZE			0x1000
    236          #define FPT_RESERVED_SIZE			0x2000
    237          #define GSN_STARTUP_RESERVED_SIZE	0x800
    238          
    239          #define SRAM_START_ADDR				0x20000000
    240          #define SRAM_END_ADDR				0x2007FFFF /* 512 + 64 KB*/
    241          
    242          #define FPT_LOCATION 				0x20004000 /* 0x20004000 Location in RAM where the ROM
    243                                                       	 function pointers has to be copied */
    244          #define APP_CODE_SRAM_BLOCK_1_ADDR	0x20030000 /* 192 KB */
    245          #define APP_CODE_SRAM_BLOCK_1_SIZE	0x10000 /* 16KB */
    246          
    247          #define APP_CODE_SRAM_BLOCK_2_ADDR	0x20040000 /* at 256KB */
    248          #define APP_CODE_SRAM_BLOCK_2_SIZE	0x40000 /* 128 */
    249          

   \                                 In section .bss, align 4
    250          GSN_BYTE_POOL_LINK_T heapBytePool[4];/* create up to 4 byte poola to be used as heap*/
   \                     heapBytePool:
   \   00000000                      DS8 224
    251          
    252          #define WORD_ALIGNED_ADDR(a)         (((a) & (~0x3)) + 0x4)
    253          
    254          typedef struct HEAP_INFO
    255          {
    256          	UINT32 start;
    257          	UINT32 size;
    258          }HEAP_INFO_T;
    259          VOID App_CodePostFetch();
    260          /*****************************************************************************
    261           *Function definitions
    262           ****************************************************************************/
    263          #pragma location = "StartupSection1"
    264          

   \                                 In section StartupSection1, align 4, keep-with-next
    265          void GsnStartup_Main( void )
    266          {
   \                     GsnStartup_Main:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB091             SUB      SP,SP,#+68
    267          	UINT32 appFwImageFlashAddr;
    268          	UINT32 sectionFlshAddr,sectionSize;
    269          	HEAP_INFO_T heap[4] = {0};
   \   00000006   0xA809             ADD      R0,SP,#+36
   \   00000008   0x2120             MOVS     R1,#+32
   \   0000000A   0x.... 0x....      BL       __aeabi_memclr4
    270              GSN_FLASHCACHE_BLK_REMAP_T remap;
    271          	UINT32 remapIndx = 1;
   \   0000000E   0x2401             MOVS     R4,#+1
    272          	/* Program address space - Address assigned in icf file*/
    273          	UINT32 *autoPatchStart = __section_begin("ROM_PATCH_AUTO");
   \   00000010   0x484A             LDR.N    R0,??GsnStartup_Main_0
   \   00000012   0x9001             STR      R0,[SP, #+4]
    274          	UINT32 *autoPatchEnd = __section_end("ROM_PATCH_AUTO");
   \   00000014   0x484A             LDR.N    R0,??GsnStartup_Main_0+0x4
   \   00000016   0x9000             STR      R0,[SP, #+0]
    275          	UINT32 *fptStart = __section_begin("ROM_PATCH_FPT_SECTION");
   \   00000018   0x484A             LDR.N    R0,??GsnStartup_Main_0+0x8
   \   0000001A   0x9004             STR      R0,[SP, #+16]
    276          	UINT32 *fptEnd = __section_end("ROM_PATCH_FPT_SECTION");
   \   0000001C   0x4D4A             LDR.N    R5,??GsnStartup_Main_0+0xC
    277              UINT32 *bssStart = __section_begin("BSS_SECTION");
   \   0000001E   0x484B             LDR.N    R0,??GsnStartup_Main_0+0x10
   \   00000020   0x9003             STR      R0,[SP, #+12]
    278              UINT32 *bssEnd = __section_end("BSS_SECTION");
   \   00000022   0x4E4B             LDR.N    R6,??GsnStartup_Main_0+0x14
    279              UINT32 *dataStart = __section_begin("DATA_SECTION");
   \   00000024   0x494B             LDR.N    R1,??GsnStartup_Main_0+0x18
    280              /*UINT32 *dataEnd = __section_end("DATA_SECTION");*/
    281              UINT32 *appCode1Start = __section_begin("APP_CODE_SECTION_1");
   \   00000026   0x4F4C             LDR.N    R7,??GsnStartup_Main_0+0x1C
    282          	UINT32 *appCode1End = __section_end("APP_CODE_SECTION_1");
   \   00000028   0xF8DF 0x8130      LDR.W    R8,??GsnStartup_Main_0+0x20
    283              UINT32 *appCode2Start = __section_begin("APP_CODE_SECTION_2");
   \   0000002C   0x484C             LDR.N    R0,??GsnStartup_Main_0+0x24
   \   0000002E   0x9002             STR      R0,[SP, #+8]
    284          	UINT32 *appCode2End = __section_end("APP_CODE_SECTION_2");
   \   00000030   0xF8DF 0x9130      LDR.W    R9,??GsnStartup_Main_0+0x28
    285              UINT32 totalCode;
    286              UINT32 *dataInitStart = __section_begin("DATA_INIT_SECTION");
   \   00000034   0x4A4C             LDR.N    R2,??GsnStartup_Main_0+0x2C
    287          	UINT32 *dataInitEnd = __section_end("DATA_INIT_SECTION");
   \   00000036   0x4B4D             LDR.N    R3,??GsnStartup_Main_0+0x30
    288          	UINT32 *freeMemStart = __section_begin("FREE_MEM");
   \   00000038   0xF8DF 0xA134      LDR.W    R10,??GsnStartup_Main_0+0x34
    289          
    290          #if 0
    291          	volatile UINT32 flag = 1;
    292          	while(flag);
    293          #endif
    294          	/*App_FlashIfFlashCheckAndConfigure();*/
    295          	appFwImageFlashAddr = romFwImageFlashAddr;
   \   0000003C   0x484D             LDR.N    R0,??GsnStartup_Main_0+0x38
   \   0000003E   0xF8D0 0xB000      LDR      R11,[R0, #+0]
    296          
    297              totalCode = ((UINT32)appCode1End - (UINT32)appCode1Start) + ((UINT32)dataInitStart - (UINT32)appCode2Start);
   \   00000042   0xEBB8 0x0007      SUBS     R0,R8,R7
   \   00000046   0x1810             ADDS     R0,R2,R0
   \   00000048   0xF8DD 0xC008      LDR      R12,[SP, #+8]
   \   0000004C   0xEBB0 0x000C      SUBS     R0,R0,R12
    298          
    299          	/* Copy data init section. "dataStart" gives absolute SRAM location*/
    300          	sectionFlshAddr = appFwImageFlashAddr + CB1_RESERVED_SIZE +
    301          						((UINT32)autoPatchEnd - (UINT32)autoPatchStart ) +
    302          						FPT_RESERVED_SIZE + GSN_STARTUP_RESERVED_SIZE +
    303                                    totalCode;
   \   00000050   0xF8DD 0xC000      LDR      R12,[SP, #+0]
   \   00000054   0xEB1C 0x0C0B      ADDS     R12,R12,R11
   \   00000058   0xF51C 0x5C80      ADDS     R12,R12,#+4096
   \   0000005C   0xF8DD 0xE004      LDR      LR,[SP, #+4]
   \   00000060   0xEBBC 0x0C0E      SUBS     R12,R12,LR
   \   00000064   0xEB10 0x000C      ADDS     R0,R0,R12
   \   00000068   0xF510 0x5020      ADDS     R0,R0,#+10240
    304          
    305          	sectionSize = (UINT32)dataInitEnd - (UINT32)dataInitStart;
   \   0000006C   0x1A9A             SUBS     R2,R3,R2
    306          	APP_STARTUP_COPY_PROG( (UINT32)dataStart, sectionFlshAddr, sectionSize);
   \   0000006E   0x2300             MOVS     R3,#+0
   \   00000070   0x.... 0x....      BL       GsnFlashCache_BlkFetch
    307          
    308          	/* Copy Function Pointer Table (FPT)*/
    309          	sectionFlshAddr = appFwImageFlashAddr + CB1_RESERVED_SIZE +
    310          						((UINT32)autoPatchEnd - (UINT32)autoPatchStart );
   \   00000074   0x9800             LDR      R0,[SP, #+0]
   \   00000076   0xEB10 0x000B      ADDS     R0,R0,R11
   \   0000007A   0xF510 0x5080      ADDS     R0,R0,#+4096
   \   0000007E   0x9901             LDR      R1,[SP, #+4]
   \   00000080   0x1A40             SUBS     R0,R0,R1
    311          	sectionSize = (UINT32)fptEnd - (UINT32)fptStart;
   \   00000082   0x9904             LDR      R1,[SP, #+16]
   \   00000084   0x1A6A             SUBS     R2,R5,R1
    312          	APP_STARTUP_COPY_PROG( (UINT32)FPT_LOCATION, sectionFlshAddr, sectionSize);
   \   00000086   0x2300             MOVS     R3,#+0
   \   00000088   0x493B             LDR.N    R1,??GsnStartup_Main_0+0x3C  ;; 0x20004000
   \   0000008A   0x.... 0x....      BL       GsnFlashCache_BlkFetch
    313          
    314          	/*Copy App code*/
    315          	sectionSize = (UINT32)appCode1End - (UINT32)appCode1Start;
   \   0000008E   0xEBB8 0x0207      SUBS     R2,R8,R7
    316          
    317          	sectionFlshAddr = appFwImageFlashAddr + CB1_RESERVED_SIZE +
    318          						((UINT32)autoPatchEnd - (UINT32)autoPatchStart ) +
    319          						FPT_RESERVED_SIZE + GSN_STARTUP_RESERVED_SIZE;
   \   00000092   0x9800             LDR      R0,[SP, #+0]
   \   00000094   0xEB10 0x000B      ADDS     R0,R0,R11
   \   00000098   0xF510 0x5080      ADDS     R0,R0,#+4096
   \   0000009C   0x9901             LDR      R1,[SP, #+4]
   \   0000009E   0x1A40             SUBS     R0,R0,R1
   \   000000A0   0xF510 0x5020      ADDS     R0,R0,#+10240
    320          
    321          	APP_STARTUP_COPY_PROG((UINT32)APP_CODE_SRAM_BLOCK_1_ADDR, sectionFlshAddr, sectionSize);
   \   000000A4   0x2300             MOVS     R3,#+0
   \   000000A6   0x4935             LDR.N    R1,??GsnStartup_Main_0+0x40  ;; 0x20030000
   \   000000A8   0x.... 0x....      BL       GsnFlashCache_BlkFetch
    322          	/*remap*/
    323          	remap.codeAddr = (UINT32)appCode1Start + 1;
   \   000000AC   0x1C78             ADDS     R0,R7,#+1
   \   000000AE   0x9006             STR      R0,[SP, #+24]
    324              remap.remapIndex = remapIndx++;
   \   000000B0   0x9405             STR      R4,[SP, #+20]
   \   000000B2   0x1C64             ADDS     R4,R4,#+1
    325              remap.remapSize = APP_CODE_SRAM_BLOCK_1_SIZE;
   \   000000B4   0xF45F 0x3080      MOVS     R0,#+65536
   \   000000B8   0x9008             STR      R0,[SP, #+32]
    326              remap.sramAddr = APP_CODE_SRAM_BLOCK_1_ADDR;
   \   000000BA   0x4830             LDR.N    R0,??GsnStartup_Main_0+0x40  ;; 0x20030000
   \   000000BC   0x9007             STR      R0,[SP, #+28]
    327              GsnFlashCache_BlkRemapSet(&remap);
   \   000000BE   0xA805             ADD      R0,SP,#+20
   \   000000C0   0x.... 0x....      BL       GsnFlashCache_BlkRemapSet
    328          
    329          	/* Set uninitialised data section to zero*/
    330          	memset((void *)bssStart, 0, ((UINT32)bssEnd- (UINT32)bssStart));
   \   000000C4   0x9803             LDR      R0,[SP, #+12]
   \   000000C6   0x1A32             SUBS     R2,R6,R0
   \   000000C8   0x2100             MOVS     R1,#+0
   \   000000CA   0x9803             LDR      R0,[SP, #+12]
   \   000000CC   0x.... 0x....      BL       memset
    331          
    332          	/* Calculate the heap */
    333          	heap[0].start = (((UINT32)freeMemStart & ~3 ) + 8 );
   \   000000D0   0xEA5F 0x009A      LSRS     R0,R10,#+2
   \   000000D4   0x0080             LSLS     R0,R0,#+2
   \   000000D6   0x3008             ADDS     R0,R0,#+8
   \   000000D8   0x9009             STR      R0,[SP, #+36]
    334              heap[0].size = APP_CODE_SRAM_BLOCK_1_ADDR - heap[0].start;
   \   000000DA   0x4828             LDR.N    R0,??GsnStartup_Main_0+0x40  ;; 0x20030000
   \   000000DC   0x9909             LDR      R1,[SP, #+36]
   \   000000DE   0x1A40             SUBS     R0,R0,R1
   \   000000E0   0x900A             STR      R0,[SP, #+40]
    335              tx_byte_pool_create(&heapBytePool[0].bPool, NULL, (void*)heap[0].start,
    336              					(UINT32)heap[0].size);
   \   000000E2   0x9B0A             LDR      R3,[SP, #+40]
   \   000000E4   0x9A09             LDR      R2,[SP, #+36]
   \   000000E6   0x2100             MOVS     R1,#+0
   \   000000E8   0x4825             LDR.N    R0,??GsnStartup_Main_0+0x44
   \   000000EA   0x.... 0x....      BL       _tx_byte_pool_create
    337              					
    338          	// allocating second heap memory
    339              heap[1].start = APP_CODE_SRAM_BLOCK_2_ADDR +
    340                      ((UINT32)appCode2End - (UINT32)appCode2Start);
   \   000000EE   0x9802             LDR      R0,[SP, #+8]
   \   000000F0   0xEBB9 0x0000      SUBS     R0,R9,R0
   \   000000F4   0x4923             LDR.N    R1,??GsnStartup_Main_0+0x48  ;; 0x20040000
   \   000000F6   0x1808             ADDS     R0,R1,R0
   \   000000F8   0x900B             STR      R0,[SP, #+44]
    341              heap[1].start = ((heap[1].start & ~3 ) + 8 );/* World Align the start address*/
   \   000000FA   0x980B             LDR      R0,[SP, #+44]
   \   000000FC   0x0880             LSRS     R0,R0,#+2
   \   000000FE   0x0080             LSLS     R0,R0,#+2
   \   00000100   0x3008             ADDS     R0,R0,#+8
   \   00000102   0x900B             STR      R0,[SP, #+44]
    342              heap[1].size = SRAM_END_ADDR - heap[1].start;
   \   00000104   0x4820             LDR.N    R0,??GsnStartup_Main_0+0x4C  ;; 0x2007ffff
   \   00000106   0x990B             LDR      R1,[SP, #+44]
   \   00000108   0x1A40             SUBS     R0,R0,R1
   \   0000010A   0x900C             STR      R0,[SP, #+48]
    343          
    344              tx_byte_pool_create(&heapBytePool[1].bPool, NULL, (void*)heap[1].start,
    345                                                                              (UINT32)heap[1].size);
   \   0000010C   0x9B0C             LDR      R3,[SP, #+48]
   \   0000010E   0x9A0B             LDR      R2,[SP, #+44]
   \   00000110   0x2100             MOVS     R1,#+0
   \   00000112   0x481E             LDR.N    R0,??GsnStartup_Main_0+0x50
   \   00000114   0x.... 0x....      BL       _tx_byte_pool_create
    346          
    347              pGsnBytePoolHead =  &heapBytePool[0];
   \   00000118   0x481D             LDR.N    R0,??GsnStartup_Main_0+0x54
   \   0000011A   0x491E             LDR.N    R1,??GsnStartup_Main_0+0x58
   \   0000011C   0x6001             STR      R1,[R0, #+0]
    348              pGsnBytePoolHead->pNext = &heapBytePool[1];
   \   0000011E   0x481C             LDR.N    R0,??GsnStartup_Main_0+0x54
   \   00000120   0x6800             LDR      R0,[R0, #+0]
   \   00000122   0x491D             LDR.N    R1,??GsnStartup_Main_0+0x5C
   \   00000124   0x6001             STR      R1,[R0, #+0]
    349              heapBytePool[1].pNext = NULL;
   \   00000126   0x481B             LDR.N    R0,??GsnStartup_Main_0+0x58
   \   00000128   0x2100             MOVS     R1,#+0
   \   0000012A   0x6381             STR      R1,[R0, #+56]
    350          
    351          
    352          	/* 3 blocks of 64K SRAM is released to wlan - Temporary*/
    353          	*((volatile UINT32 *)(0x40080008)) = (UINT32)0x1C;
   \   0000012C   0x481B             LDR.N    R0,??GsnStartup_Main_0+0x60  ;; 0x40080008
   \   0000012E   0x211C             MOVS     R1,#+28
   \   00000130   0x6001             STR      R1,[R0, #+0]
    354          
    355          	/* Call APP MAIN */
    356              App_Main();
   \   00000132   0x.... 0x....      BL       App_Main
    357              while(1)
    358              {
    359              	__WFI();
   \                     ??GsnStartup_Main_1:
   \   00000136   0xBF30             WFI      
   \   00000138   0xE7FD             B.N      ??GsnStartup_Main_1
   \   0000013A   0xBF00             Nop      
   \                     ??GsnStartup_Main_0:
   \   0000013C   0x........         DC32     SFB(ROM_PATCH_AUTO)
   \   00000140   0x........         DC32     SFE(ROM_PATCH_AUTO)
   \   00000144   0x........         DC32     SFB(ROM_PATCH_FPT_SECTION)
   \   00000148   0x........         DC32     SFE(ROM_PATCH_FPT_SECTION)
   \   0000014C   0x........         DC32     SFB(BSS_SECTION)
   \   00000150   0x........         DC32     SFE(BSS_SECTION)
   \   00000154   0x........         DC32     SFB(DATA_SECTION)
   \   00000158   0x........         DC32     SFB(APP_CODE_SECTION_1)
   \   0000015C   0x........         DC32     SFE(APP_CODE_SECTION_1)
   \   00000160   0x........         DC32     SFB(APP_CODE_SECTION_2)
   \   00000164   0x........         DC32     SFE(APP_CODE_SECTION_2)
   \   00000168   0x........         DC32     SFB(DATA_INIT_SECTION)
   \   0000016C   0x........         DC32     SFE(DATA_INIT_SECTION)
   \   00000170   0x........         DC32     SFB(FREE_MEM)
   \   00000174   0x........         DC32     romFwImageFlashAddr
   \   00000178   0x20004000         DC32     0x20004000
   \   0000017C   0x20030000         DC32     0x20030000
   \   00000180   0x........         DC32     heapBytePool+0x4
   \   00000184   0x20040000         DC32     0x20040000
   \   00000188   0x2007FFFF         DC32     0x2007ffff
   \   0000018C   0x........         DC32     heapBytePool+0x3C
   \   00000190   0x........         DC32     pGsnBytePoolHead
   \   00000194   0x........         DC32     heapBytePool
   \   00000198   0x........         DC32     heapBytePool+0x38
   \   0000019C   0x40080008         DC32     0x40080008
    360              }
    361          }
    362          
    363          #if 0
    364          #pragma location = "StartupSection2"
    365          PUBLIC UINT
    366          App_FlashIfDmaCtlSet(UINT32 dmaReadCtlWord, UINT32 dmaCmd, BOOL blocking)
    367          {
    368          	GSN_STATUS_T status = GSN_SUCCESS;
    369          
    370          	/* setup dma control word register */
    371              FLASHIF_DMACTL_SET(FLASHIF, dmaReadCtlWord);
    372              /* setup dma command */
    373              FLASHIF_DMACMD_SET(FLASHIF, dmaCmd);
    374          
    375              return status;
    376          }
    377          #pragma location = "StartupSection3"
    378          BOOL
    379          App_FlashIfFlashCheckAndConfigure()
    380          {
    381              UINT32 flashId = 0, mfgId;
    382              BOOL flashExists;
    383          
    384              /* request PIO control */
    385              GsnFlashIf_PioReq();
    386          
    387              /* reset flash HPM mode */
    388              GsnFlashIf_HpmReset();
    389              GsnFlashIf_HpmReset();
    390          
    391              flashId = GsnFlashIf_FlashIdRead() & 0xFFFF;
    392              if (flashId == 0x0000)
    393              {
    394                  flashExists = FALSE;
    395                  goto GsnFlashIfStartup_FlashCheckAndConfigure_Exit;
    396              }
    397          
    398              flashExists = TRUE;
    399          
    400              /* Release flash from deep power down mode */
    401              GsnFlashIf_DeepPowerDownRelease();
    402          
    403              /* enable quad mode for known flash devices */
    404              if (
    405                      (flashId == 0xba20) /* micron */
    406                  ||  (flashId == 0x20c2) /* macronix mx25l3235e(4MB) 3.3v */
    407                  ||  (flashId == 0x24c2) /* macronix mx25l1633e(2MB) 3.3v */
    408                  ||  (flashId == 0x25c2) /* macronix mx25u3235f(4MB), mx25u1635e(2MB) 1.8v */
    409                  ||  (flashId == 0x60c8) /* gigadevice gd25lq32(4MB), gd25lq16(2MB) 1.8v */
    410                  ||  (flashId == 0x40c8) /* gigadevice gd25q16b(2MB), gd25q32b(4MB) 3.3v */
    411                  ||  (flashId == 0x151c) /* eon en25qh16(2MB) 3.3v */
    412                  ||  (flashId == 0x301c) /* eon en25qh32(2MB) 3.3v */
    413                 )
    414              {
    415                  mfgId = flashId & 0xff;
    416          
    417                  if ((mfgId == 0xc2) || (mfgId == 0xc8) || (mfgId == 0x1c))
    418                  {
    419                      /* switch to quad mode */
    420                      App_FlashIfDmaCtlSet(GSN_FLASHIF_DMA_QUADREAD_CTL_WORD_6DUMMYCYCLES,
    421                                          GSN_FLASHIF_FLASH_QUADIO_FAST_READ, TRUE);
    422          
    423                      /* For macronix, enable quad mode in status register */
    424                      if (mfgId == 0xc2)
    425                      {
    426                          UINT32 statusReg = 0;
    427                          statusReg = GsnFlashIf_FlashStatusRead();
    428                          statusReg |= 0x40;
    429                          GsnFlashIf_FlashStatusWrite(statusReg, 1);
    430                      }
    431          
    432                      /* For gigadevice, enable quad mode in status register */
    433                      if (mfgId == 0xc8)
    434                      {
    435                          UINT32 statusReg = 0;
    436                          statusReg = GsnFlashIf_FlashStatusRead();
    437                          statusReg |= 0x200;
    438                          GsnFlashIf_FlashStatusWrite(statusReg, 2);
    439                      }
    440                  }
    441          
    442                  if (flashId == 0xba20) /* micron also needs this for quad setting */
    443                  {
    444                      /* switch to quad mode */
    445                      App_FlashIfDmaCtlSet(GSN_FLASHIF_DMA_QUADREAD_CTL_WORD,
    446                                              GSN_FLASHIF_FLASH_QUADIO_FAST_READ, TRUE);
    447                      /* required for quad mode read/dma */
    448                      /* write dummy cycles in volatile config: XIP=1, WRAP=Disable */
    449                      GsnFlashIf_FlashRegWrite(GSN_FLASHIF_FLASH_VOLCFG, 0xAB,TRUE);
    450                  }
    451              }
    452          
    453              /* release PIO control */
    454              GsnFlashIf_PioRelease();
    455          
    456          GsnFlashIfStartup_FlashCheckAndConfigure_Exit:
    457              return flashExists;
    458          }
    459          #endif
    460          #pragma location = "StartupSection2"

   \                                 In section StartupSection2, align 4, keep-with-next
    461          VOID App_CodePostFetch()
    462          {
   \                     App_CodePostFetch:
   \   00000000   0xB57F             PUSH     {R0-R6,LR}
    463              UINT32 appFwImageFlashAddr;
    464          	UINT32 sectionFlshAddr,sectionSize;
    465              GSN_FLASHCACHE_BLK_REMAP_T remap;
    466          	/* Program address space - Address assigned in icf file*/
    467              UINT32 *autoPatchStart = __section_begin("ROM_PATCH_AUTO");
   \   00000002   0x4911             LDR.N    R1,??App_CodePostFetch_0
    468          	UINT32 *autoPatchEnd = __section_end("ROM_PATCH_AUTO");
   \   00000004   0x4B11             LDR.N    R3,??App_CodePostFetch_0+0x4
    469              UINT32 *appCode1Start = __section_begin("APP_CODE_SECTION_1");
   \   00000006   0x4D12             LDR.N    R5,??App_CodePostFetch_0+0x8
    470          	UINT32 *appCode1End = __section_end("APP_CODE_SECTION_1");
   \   00000008   0x4E12             LDR.N    R6,??App_CodePostFetch_0+0xC
    471              UINT32 *appCode2Start = __section_begin("APP_CODE_SECTION_2");
   \   0000000A   0x4C13             LDR.N    R4,??App_CodePostFetch_0+0x10
    472          	UINT32 *appCode2End = __section_end("APP_CODE_SECTION_2");
   \   0000000C   0x4A13             LDR.N    R2,??App_CodePostFetch_0+0x14
    473              /*UINT32 *dataInitStart = __section_begin("DATA_INIT_SECTION");
    474          	UINT32 *dataInitEnd = __section_end("DATA_INIT_SECTION");
    475          	UINT32 *freeMemStart = __section_begin("FREE_MEM");*/
    476          
    477          	appFwImageFlashAddr = romFwImageFlashAddr;
   \   0000000E   0x4814             LDR.N    R0,??App_CodePostFetch_0+0x18
   \   00000010   0x6800             LDR      R0,[R0, #+0]
    478          
    479          	/*Copy App code*/
    480          	sectionSize = (UINT32)appCode2End - (UINT32)appCode2Start;
   \   00000012   0x1B12             SUBS     R2,R2,R4
    481          	sectionFlshAddr = appFwImageFlashAddr + CB1_RESERVED_SIZE +
    482          						((UINT32)autoPatchEnd - (UINT32)autoPatchStart ) +
    483          						FPT_RESERVED_SIZE + GSN_STARTUP_RESERVED_SIZE +
    484                                   ((UINT32)appCode1End - (UINT32)appCode1Start) ;
   \   00000014   0x1818             ADDS     R0,R3,R0
   \   00000016   0xF510 0x5080      ADDS     R0,R0,#+4096
   \   0000001A   0x1A40             SUBS     R0,R0,R1
   \   0000001C   0x1830             ADDS     R0,R6,R0
   \   0000001E   0xF510 0x5020      ADDS     R0,R0,#+10240
   \   00000022   0x1B40             SUBS     R0,R0,R5
    485          
    486          	APP_STARTUP_COPY_PROG((UINT32)APP_CODE_SRAM_BLOCK_2_ADDR, sectionFlshAddr, sectionSize);
   \   00000024   0x2300             MOVS     R3,#+0
   \   00000026   0x490F             LDR.N    R1,??App_CodePostFetch_0+0x1C  ;; 0x20040000
   \   00000028   0x.... 0x....      BL       GsnFlashCache_BlkFetch
    487          	/*remap*/
    488          	remap.codeAddr = (UINT32)appCode2Start + 1;
   \   0000002C   0x1C60             ADDS     R0,R4,#+1
   \   0000002E   0x9001             STR      R0,[SP, #+4]
    489              remap.remapIndex = 2;
   \   00000030   0x2002             MOVS     R0,#+2
   \   00000032   0x9000             STR      R0,[SP, #+0]
    490              remap.remapSize = APP_CODE_SRAM_BLOCK_2_SIZE;
   \   00000034   0xF45F 0x2080      MOVS     R0,#+262144
   \   00000038   0x9003             STR      R0,[SP, #+12]
    491              remap.sramAddr = APP_CODE_SRAM_BLOCK_2_ADDR;
   \   0000003A   0x480A             LDR.N    R0,??App_CodePostFetch_0+0x1C  ;; 0x20040000
   \   0000003C   0x9002             STR      R0,[SP, #+8]
    492              GsnFlashCache_BlkRemapSet(&remap);
   \   0000003E   0xA800             ADD      R0,SP,#+0
   \   00000040   0x.... 0x....      BL       GsnFlashCache_BlkRemapSet
    493          
    494          }
   \   00000044   0xBD7F             POP      {R0-R6,PC}       ;; return
   \   00000046   0xBF00             Nop      
   \                     ??App_CodePostFetch_0:
   \   00000048   0x........         DC32     SFB(ROM_PATCH_AUTO)
   \   0000004C   0x........         DC32     SFE(ROM_PATCH_AUTO)
   \   00000050   0x........         DC32     SFB(APP_CODE_SECTION_1)
   \   00000054   0x........         DC32     SFE(APP_CODE_SECTION_1)
   \   00000058   0x........         DC32     SFB(APP_CODE_SECTION_2)
   \   0000005C   0x........         DC32     SFE(APP_CODE_SECTION_2)
   \   00000060   0x........         DC32     romFwImageFlashAddr
   \   00000064   0x20040000         DC32     0x20040000

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000018   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    495          #endif/*NO_FLASH_FETCH*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   App_CodePostFetch
        32   -> GsnFlashCache_BlkFetch
        32   -> GsnFlashCache_BlkRemapSet
     104   GsnStartup_Main
       104   -> App_Main
       104   -> GsnFlashCache_BlkFetch
       104   -> GsnFlashCache_BlkRemapSet
       104   -> __aeabi_memclr4
       104   -> _tx_byte_pool_create
       104   -> memset
       8   memset
         8   -> __aeabi_memset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      32  ?<Constant {{0}}>
     104  App_CodePostFetch
     416  GsnStartup_Main
     224  heapBytePool
      20  memset
       1  noFlashFetchFlag

 
 225 bytes in section .bss
  32 bytes in section .rodata
  20 bytes in section .text
 416 bytes in section StartupSection1
 104 bytes in section StartupSection2
 
 520 bytes of CODE  memory (+ 20 bytes shared)
  32 bytes of CONST memory
 225 bytes of DATA  memory

Errors: none
Warnings: 4
