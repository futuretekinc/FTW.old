<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<title>GEPS Documentation</title>
<table style="text-align: left; height: 28px; width: 710px;" border="0" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td style="width: 360px;" align="center" valign="middle"><img style="width: 300px; height: 82px;" alt="GainSpan" src="GainSpan_logo_hi-res.jpg"><br><span style="font-family: Verdana; font-style: italic;">Gainspan Embedded Platform Software</span></td>
<td style="width: 202px;" align="center" valign="middle"></td>
<td style="width: 120px;" align="center" valign="middle"><br></td>
</tr>
</tbody>
</table>
<br>
</head>

<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Groups</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a00671.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">GSN Persistent Timer</div>  </div>
<div class="ingroups"><a class="el" href="a00685.html">Modules</a></div></div>
<div class="contents">

<p>This module manages timers whose state persists through Standby.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00671.html#gaf983eb2e91bbb6a2e9a7d373419d69dd">GSN_P_TMR_NVDS_MEM_SIZE</a>(maxNumOfPTmr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory needed in NVDS for persistent timer module.  <a href="#gaf983eb2e91bbb6a2e9a7d373419d69dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00671.html#ga814ac6b7dfd3d718d276b4794cb4b5d3">GSN_P_TMR_NVRAM_MEM_SIZE</a>(maxNumOfConstPTmr, maxNumOfVarPTmr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory needed in NVRAM for persistent timer module.  <a href="#ga814ac6b7dfd3d718d276b4794cb4b5d3"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="a00671.html#gadc3540874fb3842b2eb56edd0c82945b">GSN_P_TIMER_TYPE_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00671.html#gad756dc4e5d1d8eb116b9daf7bddddb69">GSN_P_TIMER_TYPE_T</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent Timer type definition.  <a href="#gad756dc4e5d1d8eb116b9daf7bddddb69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="a00671.html#ga9aa5599a087c6080868052f86ecad7df">GSN_P_TMR_REF_TIME</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00671.html#ga8d27b193b47e23bf2bd68b439badf3d6">GSN_P_TMR_REF_TIME_T</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">enum for the reference time for the re-start API.  <a href="#ga8d27b193b47e23bf2bd68b439badf3d6"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00671.html#gadc3540874fb3842b2eb56edd0c82945b">GSN_P_TIMER_TYPE_T</a> { <br/>
&#160;&#160;<a class="el" href="a00671.html#ggadc3540874fb3842b2eb56edd0c82945bac4338c7c860b0a33c9371d86d41b87c8">GSN_TIMER_TYPE_PERSISTENT_CONSTANT</a>, 
<br/>
&#160;&#160;<a class="el" href="a00671.html#ggadc3540874fb3842b2eb56edd0c82945bae46518ab7c9f147305e08200cf63b9ed">GSN_TIMER_TYPE_PERSISTENT_VARIABLE</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent Timer type definition.  <a href="a00671.html#gadc3540874fb3842b2eb56edd0c82945b">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00671.html#ga9aa5599a087c6080868052f86ecad7df">GSN_P_TMR_REF_TIME</a> { <br/>
&#160;&#160;<a class="el" href="a00671.html#gga9aa5599a087c6080868052f86ecad7dfa2ab194528197fe1eeed47e7efabb3701">GSN_P_TMR_CURRENT_TIME</a>, 
<br/>
&#160;&#160;<a class="el" href="a00671.html#gga9aa5599a087c6080868052f86ecad7dfad4c5b6ce85e5ffed6b4474dd639db19e">GSN_P_TMR_PREV_EXP_TIME</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">enum for the reference time for the re-start API.  <a href="a00671.html#ga9aa5599a087c6080868052f86ecad7df">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00671.html#ga5e91b9000f2f5e74d9d70ee0591035ae">GsnPersistTmr_Init</a> (VOID *pNvRamLoc, VOID *pNvdsLoc, <a class="el" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> numOfVarTimer, <a class="el" href="a00660.html#gab27e9918b538ce9d8ca692479b375b6a">UINT8</a> numOfConstTimer, <a class="el" href="a00229.html">GSN_SOFT_TMR_T</a> *pSoftTmrStructTbl)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization for Persistent Timer module.  <a href="#ga5e91b9000f2f5e74d9d70ee0591035ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00671.html#ga21c2beb3a3544b189800c56051ca9b6f">GsnPersistTmr_Restore</a> (VOID)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent timer restore.  <a href="#ga21c2beb3a3544b189800c56051ca9b6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC <a class="el" href="a00660.html#ga1f04022c0a182c51c059438790ea138c">BOOL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00671.html#ga9af57957c6755f2cc4c6c3d140c623a2">GsnPersistTmr_Store</a> (VOID)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent timer Store.  <a href="#ga9af57957c6755f2cc4c6c3d140c623a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC <a class="el" href="a00660.html#gada5951904ac6110b1fa95e51a9ddc217">GSN_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00671.html#ga17f353c07fe849751becba1144e0f8f8">GsnPersistTmr_Create</a> (<a class="el" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> timerId, <a class="el" href="a00671.html#gadc3540874fb3842b2eb56edd0c82945b">GSN_P_TIMER_TYPE_T</a> type, <a class="el" href="a00660.html#ga28961430434ccabca6862ea93fe9a15b">ULONG64</a> period, <a class="el" href="a00673.html#ga9bb74ab1272c117587bf1fadf84849de">GSN_SOFT_TMR_CBR_T</a> cb, VOID *context, <a class="el" href="a00660.html#ga1f04022c0a182c51c059438790ea138c">BOOL</a> autoStart)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Persistent Timer.  <a href="#ga17f353c07fe849751becba1144e0f8f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC <a class="el" href="a00660.html#gada5951904ac6110b1fa95e51a9ddc217">GSN_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00671.html#gaacdba3e378b84c6d8d5373afebb43f6b">GsnPersistTmr_Delete</a> (<a class="el" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> timerId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a Persistent Timer.  <a href="#gaacdba3e378b84c6d8d5373afebb43f6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC <a class="el" href="a00660.html#gada5951904ac6110b1fa95e51a9ddc217">GSN_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00671.html#ga13a97f1941e64cdab5ad524f5d244985">GsnPersistTmr_Start</a> (<a class="el" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> timerId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the Persistent Timer.  <a href="#ga13a97f1941e64cdab5ad524f5d244985"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC <a class="el" href="a00660.html#gada5951904ac6110b1fa95e51a9ddc217">GSN_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00671.html#ga038419003a0a454c1e3641818a4a8a1b">GsnPersistTmr_Stop</a> (<a class="el" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> timerId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the Persistent Timer.  <a href="#ga038419003a0a454c1e3641818a4a8a1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC <a class="el" href="a00660.html#gada5951904ac6110b1fa95e51a9ddc217">GSN_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00671.html#ga1caf8a120d6264cd9e8780110d306e98">GsnPersistTmr_ReStart</a> (<a class="el" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> timerId, <a class="el" href="a00660.html#ga28961430434ccabca6862ea93fe9a15b">ULONG64</a> period, <a class="el" href="a00671.html#ga8d27b193b47e23bf2bd68b439badf3d6">GSN_P_TMR_REF_TIME_T</a> refTime)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-starts a Persistent Timer.  <a href="#ga1caf8a120d6264cd9e8780110d306e98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC <a class="el" href="a00660.html#ga28961430434ccabca6862ea93fe9a15b">ULONG64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00671.html#ga6f5bc2af45625f650fe1de1b30274d4c">GsnPersistTmr_SystemTimeAtExpire</a> (<a class="el" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> timerId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">System time at expire. Gives the system time at expire for the requested persistent timer.  <a href="#ga6f5bc2af45625f650fe1de1b30274d4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC <a class="el" href="a00660.html#ga28961430434ccabca6862ea93fe9a15b">ULONG64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00671.html#ga72958206fd50e03c6e781bcca39728da">GsnPersistTmr_RemainingTimeGet</a> (<a class="el" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> timerId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent Timer remaining time. Gives the remaining time to expire for the requested persistent timer.  <a href="#ga72958206fd50e03c6e781bcca39728da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC <a class="el" href="a00660.html#ga28961430434ccabca6862ea93fe9a15b">ULONG64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00671.html#ga267caddf2e14e33f5b59cd084fbc090a">GsnPersistTmr_MinExpireTime</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum expire time of all persistenet timer. Gives the min expire time of all persistent timer.  <a href="#ga267caddf2e14e33f5b59cd084fbc090a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC <a class="el" href="a00660.html#ga1f04022c0a182c51c059438790ea138c">BOOL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00671.html#ga7faefe68a4dfa5d59f0f04e8f4eb4a15">GsnPersistTmr_IsActive</a> (<a class="el" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> timerId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer is active or not. Finds whether the requested persistent timer is active.  <a href="#ga7faefe68a4dfa5d59f0f04e8f4eb4a15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC <a class="el" href="a00660.html#ga28961430434ccabca6862ea93fe9a15b">ULONG64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00671.html#ga2acab3c99e8f6bd8a1573c3811092c02">GsnPersistTmr_PeriodGet</a> (<a class="el" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> timerId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Period of the persistent timer. Gives the current period of the requested persistent timer. The period of the variable persistent timer may be different then the period with which it was created or started.  <a href="#ga2acab3c99e8f6bd8a1573c3811092c02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC <a class="el" href="a00660.html#ga28961430434ccabca6862ea93fe9a15b">ULONG64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00671.html#gae8bc845575767075c35df8096dd08fbc">GsnPersistTmr_DfltPeriodGet</a> (<a class="el" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> timerId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default period of the persistenet timer. Gives the period stores in NVDS for the requested persistent timer. This is useful for variable persistent timer type to find the period passed when it was created or started..  <a href="#gae8bc845575767075c35df8096dd08fbc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00671.html#ga72f5225fa0da29f815d14a417c29611e">GsnPersistTmr_DfltPeriodSet</a> (<a class="el" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> timerId, <a class="el" href="a00660.html#ga28961430434ccabca6862ea93fe9a15b">ULONG64</a> period)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default period of the persistenet timer. Chnages the default period. It stores the period in NVDS, If it is set to 0, the timer is stopped, else it is restarted with the set value maintaining the previous reference time.  <a href="#ga72f5225fa0da29f815d14a417c29611e"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>This module manages timers whose state persists through Standby. </p>
<p>This group of API functions manages timers whose state can persist across Standby/Wakeup cycles. This module permits the user to manage multiple software timers based on a single hardware timer.</p>
<p>A soft timer provides timer capabilities when the system is running. Without special provisions, the state of a soft timer will be lost in Standby. To retain the timer state through a Standby-Wakeup cycle, GEPS provides persistent timers. Persistent timers are soft timers whose active timer context is saved in NVRAM(defaulted to RTC) and NVDS(flash).</p>
<p>The user can decide how many persistent timers to use. Based on this value, module functions reserve space in NVRAM and NVDS. The user must provide the NVRAM and NVDS content reserved for this module in the init routine, and then can call the restore routine to restore all the context of the active persistent timer(s). If a persistent timer has expired, this function calls the corresponding callback routine. In every boot, the user has to call these two routines. Before going to Standby, the user must call the store routine to store the context of the persistent timer into the NVDS and NVRAM. The user must take care to copy the relevant SRAM data into NVDS and NVRAM.</p>
<p>To create a persistent timer, the user calls Tmr_Create; to delete it, call Tmr_Delete. Tmr_Create is called only once to create a persistent timer. If deleted, the resources used by this timer are released (soft timer, NVRAM and NVDS), so that any other persistent timer can use them. Functions are provided to start, stop and restart a persistent timer. The user must manage the timer Id. The persistent timer module uses this timer Id as an index to the array stored in the NVRAM / NVDS structure, so the timer Id should be between 0 and [(the maximum number of persistent timers allowed) - 1]. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gaf983eb2e91bbb6a2e9a7d373419d69dd"></a><!-- doxytag: member="gsn_persistent_timer.h::GSN_P_TMR_NVDS_MEM_SIZE" ref="gaf983eb2e91bbb6a2e9a7d373419d69dd" args="(maxNumOfPTmr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GSN_P_TMR_NVDS_MEM_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">maxNumOfPTmr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">( 2 * <span class="keyword">sizeof</span>( <a class="code" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> )) +                                       \
    (( maxNumOfPTmr ) *                                             \
        ( <span class="keyword">sizeof</span>( <a class="code" href="a00228.html" title="GSN Soft timer callback information. A callback includes both a Callback Routine, and its execution c...">GSN_SOFT_TMR_CALLBACK_T</a> ) + <span class="keyword">sizeof</span>( <a class="code" href="a00660.html#ga28961430434ccabca6862ea93fe9a15b">ULONG64</a> )))
</pre></div>
<p>Memory needed in NVDS for persistent timer module. </p>
<p>MACRO to get NVDS memory size for the persistent timer module for a given number of persistent timers.</p>
<p>User can allocate memory of this size in NVDS using this MACRO.</p>
<p>Here NVDS is refered to flash memory. The information which rarely changes are written to this segment. </p>

<p>Definition at line <a class="el" href="a00539_source.html#l00125">125</a> of file <a class="el" href="a00539_source.html">gsn_persistent_timer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga814ac6b7dfd3d718d276b4794cb4b5d3"></a><!-- doxytag: member="gsn_persistent_timer.h::GSN_P_TMR_NVRAM_MEM_SIZE" ref="ga814ac6b7dfd3d718d276b4794cb4b5d3" args="(maxNumOfConstPTmr, maxNumOfVarPTmr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GSN_P_TMR_NVRAM_MEM_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">maxNumOfConstPTmr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">maxNumOfVarPTmr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">sizeof</span>( <a class="code" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> ) +                                                  \
    ( <span class="keyword">sizeof</span>( <a class="code" href="a00660.html#ga28961430434ccabca6862ea93fe9a15b">ULONG64</a> ) * ( maxNumOfVarPTmr )) +                        \
    ((( maxNumOfConstPTmr ) + ( maxNumOfVarPTmr )) * <span class="keyword">sizeof</span>( <a class="code" href="a00660.html#ga28961430434ccabca6862ea93fe9a15b">ULONG64</a> ))
</pre></div>
<p>Memory needed in NVRAM for persistent timer module. </p>
<p>MACRO to get NVRAM memory size for the persistent timer module for a given number of const and variable persistent timer.</p>
<p>User can allocate memory of this size in NVRAM using this MACRO.</p>
<p>Here NVRAM is refered to RTC memory in our case. The information which changes frequenty and need to be retained over standby wakeup cycle are written to this segment. </p>

<p>Definition at line <a class="el" href="a00539_source.html#l00144">144</a> of file <a class="el" href="a00539_source.html">gsn_persistent_timer.h</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gad756dc4e5d1d8eb116b9daf7bddddb69"></a><!-- doxytag: member="gsn_persistent_timer.h::GSN_P_TIMER_TYPE_T" ref="gad756dc4e5d1d8eb116b9daf7bddddb69" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="a00671.html#gadc3540874fb3842b2eb56edd0c82945b">GSN_P_TIMER_TYPE_T</a>  <a class="el" href="a00671.html#gadc3540874fb3842b2eb56edd0c82945b">GSN_P_TIMER_TYPE_T</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Persistent Timer type definition. </p>
<p>A Persistent Constant timer's state can persist during Standby, but the timeout value can only be changed if we update the timeout in NVDS.</p>
<p>A Persistent Variable timer's state persists during Standby, and the timeout value can be changed in any wakeup cycle. This timer starts with the value provided in the Create function, and the period of the timer is stored into NVDS. The timeout can be changed without updating the NVDS, unlike GSN_TIMER_TYPE_PERSISTENT_CONSTANT timer. If a persistent timer has to be started with different period frequently then user should use this timer type, but a variable timer uses 64 bits of NVRAM! There is not enough room many variable timers; use only when needed. </p>

</div>
</div>
<a class="anchor" id="ga8d27b193b47e23bf2bd68b439badf3d6"></a><!-- doxytag: member="gsn_persistent_timer.h::GSN_P_TMR_REF_TIME_T" ref="ga8d27b193b47e23bf2bd68b439badf3d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="a00671.html#ga9aa5599a087c6080868052f86ecad7df">GSN_P_TMR_REF_TIME</a> <a class="el" href="a00671.html#ga8d27b193b47e23bf2bd68b439badf3d6">GSN_P_TMR_REF_TIME_T</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>enum for the reference time for the re-start API. </p>
<p>Reference time to restart the timer. If GSN_TMR_CURRENT_TIME is choosed then the timer is restarted with the period from the current time. If GSN_TMR_PREV_EXP_TIME is choosed then timer is started from the previous expire time, and the callback is called after Nth period such that</p>
<p>PrevExpTime + N*Period &gt; CurrentTime, where PrevExpTime is the previous expire time and period is the period passed in the Restart API. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gadc3540874fb3842b2eb56edd0c82945b"></a><!-- doxytag: member="gsn_persistent_timer.h::GSN_P_TIMER_TYPE_T" ref="gadc3540874fb3842b2eb56edd0c82945b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00671.html#gadc3540874fb3842b2eb56edd0c82945b">GSN_P_TIMER_TYPE_T</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Persistent Timer type definition. </p>
<p>A Persistent Constant timer's state can persist during Standby, but the timeout value can only be changed if we update the timeout in NVDS.</p>
<p>A Persistent Variable timer's state persists during Standby, and the timeout value can be changed in any wakeup cycle. This timer starts with the value provided in the Create function, and the period of the timer is stored into NVDS. The timeout can be changed without updating the NVDS, unlike GSN_TIMER_TYPE_PERSISTENT_CONSTANT timer. If a persistent timer has to be started with different period frequently then user should use this timer type, but a variable timer uses 64 bits of NVRAM! There is not enough room many variable timers; use only when needed. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggadc3540874fb3842b2eb56edd0c82945bac4338c7c860b0a33c9371d86d41b87c8"></a><!-- doxytag: member="GSN_TIMER_TYPE_PERSISTENT_CONSTANT" ref="ggadc3540874fb3842b2eb56edd0c82945bac4338c7c860b0a33c9371d86d41b87c8" args="" -->GSN_TIMER_TYPE_PERSISTENT_CONSTANT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggadc3540874fb3842b2eb56edd0c82945bae46518ab7c9f147305e08200cf63b9ed"></a><!-- doxytag: member="GSN_TIMER_TYPE_PERSISTENT_VARIABLE" ref="ggadc3540874fb3842b2eb56edd0c82945bae46518ab7c9f147305e08200cf63b9ed" args="" -->GSN_TIMER_TYPE_PERSISTENT_VARIABLE</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00539_source.html#l00171">171</a> of file <a class="el" href="a00539_source.html">gsn_persistent_timer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga9aa5599a087c6080868052f86ecad7df"></a><!-- doxytag: member="gsn_persistent_timer.h::GSN_P_TMR_REF_TIME" ref="ga9aa5599a087c6080868052f86ecad7df" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00671.html#ga9aa5599a087c6080868052f86ecad7df">GSN_P_TMR_REF_TIME</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>enum for the reference time for the re-start API. </p>
<p>Reference time to restart the timer. If GSN_TMR_CURRENT_TIME is choosed then the timer is restarted with the period from the current time. If GSN_TMR_PREV_EXP_TIME is choosed then timer is started from the previous expire time, and the callback is called after Nth period such that</p>
<p>PrevExpTime + N*Period &gt; CurrentTime, where PrevExpTime is the previous expire time and period is the period passed in the Restart API. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga9aa5599a087c6080868052f86ecad7dfa2ab194528197fe1eeed47e7efabb3701"></a><!-- doxytag: member="GSN_P_TMR_CURRENT_TIME" ref="gga9aa5599a087c6080868052f86ecad7dfa2ab194528197fe1eeed47e7efabb3701" args="" -->GSN_P_TMR_CURRENT_TIME</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9aa5599a087c6080868052f86ecad7dfad4c5b6ce85e5ffed6b4474dd639db19e"></a><!-- doxytag: member="GSN_P_TMR_PREV_EXP_TIME" ref="gga9aa5599a087c6080868052f86ecad7dfad4c5b6ce85e5ffed6b4474dd639db19e" args="" -->GSN_P_TMR_PREV_EXP_TIME</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00539_source.html#l00194">194</a> of file <a class="el" href="a00539_source.html">gsn_persistent_timer.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga17f353c07fe849751becba1144e0f8f8"></a><!-- doxytag: member="gsn_persistent_timer.h::GsnPersistTmr_Create" ref="ga17f353c07fe849751becba1144e0f8f8" args="(UINT32 timerId, GSN_P_TIMER_TYPE_T type, ULONG64 period, GSN_SOFT_TMR_CBR_T cb, VOID *context, BOOL autoStart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC <a class="el" href="a00660.html#gada5951904ac6110b1fa95e51a9ddc217">GSN_STATUS</a> GsnPersistTmr_Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a>&#160;</td>
          <td class="paramname"><em>timerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00671.html#gadc3540874fb3842b2eb56edd0c82945b">GSN_P_TIMER_TYPE_T</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00660.html#ga28961430434ccabca6862ea93fe9a15b">ULONG64</a>&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00673.html#ga9bb74ab1272c117587bf1fadf84849de">GSN_SOFT_TMR_CBR_T</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00660.html#ga1f04022c0a182c51c059438790ea138c">BOOL</a>&#160;</td>
          <td class="paramname"><em>autoStart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a Persistent Timer. </p>
<p>This function creates a persistent timer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timerId</td><td>- IN ID of the timer to create. It should be less than the maximum persistenet timer supported i.e. numOfVarTimer + numOfConstTimer<ul>
<li>1 passed in GsnPersistTmr_Init API. </li>
</ul>
</td></tr>
    <tr><td class="paramname">type</td><td>- IN Type of the persistent timer. </td></tr>
    <tr><td class="paramname">period</td><td>- IN period of the persistent timer. </td></tr>
    <tr><td class="paramname">cb</td><td>- IN Callback function of the timer. </td></tr>
    <tr><td class="paramname">context</td><td>- IN Context to be passed in the callback function. </td></tr>
    <tr><td class="paramname">autoStart</td><td>- IN Starts the timer if passed true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This API is called to give the callback information and the period to the persistent timer module. This API is expected to be called when the cb and context changes, i.e. after doing FWUP(Firmware upgrade).</dd></dl>
<p>If autoStart is passed TRUE then the persistent timer is started automatically, else user has to call GsnPersistTmr_Start to explictly start it. Once started, the cb is called when the timer expires, and the persistent timer starts running when GsnPersistTmr_Init is called after every wakeup. If any persistent timer has expired when GsnPersistTmr_Init is called, the cb of the corresponding persistent timer is called.</p>
<p>User has to manage the timer Id. </p>

</div>
</div>
<a class="anchor" id="gaacdba3e378b84c6d8d5373afebb43f6b"></a><!-- doxytag: member="gsn_persistent_timer.h::GsnPersistTmr_Delete" ref="gaacdba3e378b84c6d8d5373afebb43f6b" args="(UINT32 timerId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC <a class="el" href="a00660.html#gada5951904ac6110b1fa95e51a9ddc217">GSN_STATUS</a> GsnPersistTmr_Delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a>&#160;</td>
          <td class="paramname"><em>timerId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes a Persistent Timer. </p>
<p>This function deletes a persistent timer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timerId</td><td>- IN ID of the timer to create. It should be less than the maximum persistenet timer supported i.e. numOfVarTimer + numOfConstTimer<ul>
<li>1 passed in GsnPersistTmr_Init API. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This API is called to delete a persistent timer. Once deleted the timer Id can be reused and the NVRAM and NVDS resource can be reused for some other timer. </dd></dl>

</div>
</div>
<a class="anchor" id="gae8bc845575767075c35df8096dd08fbc"></a><!-- doxytag: member="gsn_persistent_timer.h::GsnPersistTmr_DfltPeriodGet" ref="gae8bc845575767075c35df8096dd08fbc" args="(UINT32 timerId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC <a class="el" href="a00660.html#ga28961430434ccabca6862ea93fe9a15b">ULONG64</a> GsnPersistTmr_DfltPeriodGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a>&#160;</td>
          <td class="paramname"><em>timerId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default period of the persistenet timer. Gives the period stores in NVDS for the requested persistent timer. This is useful for variable persistent timer type to find the period passed when it was created or started.. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timerId</td><td>- IN ID of the timer. It should be less than the maximum persistenet timer supported i.e. numOfVarTimer + numOfConstTimer passed in GsnPersistTmr_Init API. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">Remaining</td><td>time in timer ticks </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga72f5225fa0da29f815d14a417c29611e"></a><!-- doxytag: member="gsn_persistent_timer.h::GsnPersistTmr_DfltPeriodSet" ref="ga72f5225fa0da29f815d14a417c29611e" args="(UINT32 timerId, ULONG64 period)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC VOID GsnPersistTmr_DfltPeriodSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a>&#160;</td>
          <td class="paramname"><em>timerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00660.html#ga28961430434ccabca6862ea93fe9a15b">ULONG64</a>&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set default period of the persistenet timer. Chnages the default period. It stores the period in NVDS, If it is set to 0, the timer is stopped, else it is restarted with the set value maintaining the previous reference time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timerId</td><td>- IN ID of the timer. It should be less than the maximum persistenet timer supported i.e. numOfVarTimer + numOfConstTimer passed in GsnPersistTmr_Init API. </td></tr>
    <tr><td class="paramname">period</td><td>- IN Period to Set </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga5e91b9000f2f5e74d9d70ee0591035ae"></a><!-- doxytag: member="gsn_persistent_timer.h::GsnPersistTmr_Init" ref="ga5e91b9000f2f5e74d9d70ee0591035ae" args="(VOID *pNvRamLoc, VOID *pNvdsLoc, UINT32 numOfVarTimer, UINT8 numOfConstTimer, GSN_SOFT_TMR_T *pSoftTmrStructTbl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC VOID GsnPersistTmr_Init </td>
          <td>(</td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>pNvRamLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>pNvdsLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a>&#160;</td>
          <td class="paramname"><em>numOfVarTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00660.html#gab27e9918b538ce9d8ca692479b375b6a">UINT8</a>&#160;</td>
          <td class="paramname"><em>numOfConstTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00229.html">GSN_SOFT_TMR_T</a> *&#160;</td>
          <td class="paramname"><em>pSoftTmrStructTbl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialization for Persistent Timer module. </p>
<p>This function performs initialization of Persistent timer module. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pNvRamLoc</td><td>- IN SRAM loc where the NVRAM details for this module is stored. </td></tr>
    <tr><td class="paramname">pNvdsLoc</td><td>- IN SRAM loc where the NVDS detaild for this module is stored. </td></tr>
    <tr><td class="paramname">numOfVarTimer</td><td>- IN Number of varibale timer the user wants. </td></tr>
    <tr><td class="paramname">numOfConstTimer</td><td>- IN Number of const timer the user wants. </td></tr>
    <tr><td class="paramname">pSoftTmrStructTbl</td><td>- IN Pointer to the soft timer table which would be used to start/stop soft timers. The size of the memory buffer should be sizeof( GSN_SOFT_TMR_T ) * ( numOfVarTimer + numOfConstTimer ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function must be called after calling the initialization function of the soft timer module. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7faefe68a4dfa5d59f0f04e8f4eb4a15"></a><!-- doxytag: member="gsn_persistent_timer.h::GsnPersistTmr_IsActive" ref="ga7faefe68a4dfa5d59f0f04e8f4eb4a15" args="(UINT32 timerId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC <a class="el" href="a00660.html#ga1f04022c0a182c51c059438790ea138c">BOOL</a> GsnPersistTmr_IsActive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a>&#160;</td>
          <td class="paramname"><em>timerId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Timer is active or not. Finds whether the requested persistent timer is active. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timerId</td><td>- IN ID of the timer. It should be less than the maximum persistenet timer supported i.e. numOfVarTimer + numOfConstTimer passed in GsnPersistTmr_Init API. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if active else FALSE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga267caddf2e14e33f5b59cd084fbc090a"></a><!-- doxytag: member="gsn_persistent_timer.h::GsnPersistTmr_MinExpireTime" ref="ga267caddf2e14e33f5b59cd084fbc090a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC <a class="el" href="a00660.html#ga28961430434ccabca6862ea93fe9a15b">ULONG64</a> GsnPersistTmr_MinExpireTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Minimum expire time of all persistenet timer. Gives the min expire time of all persistent timer. </p>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">Remaining</td><td>time in timer ticks </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga2acab3c99e8f6bd8a1573c3811092c02"></a><!-- doxytag: member="gsn_persistent_timer.h::GsnPersistTmr_PeriodGet" ref="ga2acab3c99e8f6bd8a1573c3811092c02" args="(UINT32 timerId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC <a class="el" href="a00660.html#ga28961430434ccabca6862ea93fe9a15b">ULONG64</a> GsnPersistTmr_PeriodGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a>&#160;</td>
          <td class="paramname"><em>timerId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Period of the persistent timer. Gives the current period of the requested persistent timer. The period of the variable persistent timer may be different then the period with which it was created or started. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timerId</td><td>- IN ID of the timer. It should be less than the maximum persistenet timer supported i.e. numOfVarTimer + numOfConstTimer passed in GsnPersistTmr_Init API. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">Remaining</td><td>time in timer ticks </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga72958206fd50e03c6e781bcca39728da"></a><!-- doxytag: member="gsn_persistent_timer.h::GsnPersistTmr_RemainingTimeGet" ref="ga72958206fd50e03c6e781bcca39728da" args="(UINT32 timerId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC <a class="el" href="a00660.html#ga28961430434ccabca6862ea93fe9a15b">ULONG64</a> GsnPersistTmr_RemainingTimeGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a>&#160;</td>
          <td class="paramname"><em>timerId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Persistent Timer remaining time. Gives the remaining time to expire for the requested persistent timer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timerId</td><td>- IN ID of the timer. It should be less than the maximum persistenet timer supported i.e. numOfVarTimer + numOfConstTimer passed in GsnPersistTmr_Init API. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">Remaining</td><td>time in timer ticks </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga1caf8a120d6264cd9e8780110d306e98"></a><!-- doxytag: member="gsn_persistent_timer.h::GsnPersistTmr_ReStart" ref="ga1caf8a120d6264cd9e8780110d306e98" args="(UINT32 timerId, ULONG64 period, GSN_P_TMR_REF_TIME_T refTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC <a class="el" href="a00660.html#gada5951904ac6110b1fa95e51a9ddc217">GSN_STATUS</a> GsnPersistTmr_ReStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a>&#160;</td>
          <td class="paramname"><em>timerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00660.html#ga28961430434ccabca6862ea93fe9a15b">ULONG64</a>&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00671.html#ga8d27b193b47e23bf2bd68b439badf3d6">GSN_P_TMR_REF_TIME_T</a>&#160;</td>
          <td class="paramname"><em>refTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Re-starts a Persistent Timer. </p>
<p>This function re-starts a persistent timer. This API is mainly used to change the period of the persistent timer if the timer is already active or to start the timer if it is de-active. In case of persistent const timer the change in period triggers a NVDS write. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timerId</td><td>- IN ID of the timer to re-start. It should be less than the maximum persistenet timer supported i.e. numOfVarTimer + numOfConstTimer passed in GsnPersistTmr_Init API. </td></tr>
    <tr><td class="paramname">period</td><td>- Period in system ticks </td></tr>
    <tr><td class="paramname">refTime</td><td>- Reference time to restart the timer. If GSN_P_TMR_CURRENT_TIME is passed then the timer is restarted with the period from the current time. If GSN_P_TMR_PREV_EXP_TIME is passed then timer is started from the previous expire time, and the callback is called after Nth period such that PrevExpTime + N * Period &gt; CurrentTime, where "PrevExpTime" is the previous expire time, "N" is any integer value and "period" is the period passed in this API.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This API is expected to be called for a persistent timer, only if the persistent timer is already started. It returns error if it is do so. A persistent timer is assumed to be started if the start API is called once in any boot or create API is called with autoStart TRUE. It is assumed that all the input parameters are passed correctly. </dd></dl>

</div>
</div>
<a class="anchor" id="ga21c2beb3a3544b189800c56051ca9b6f"></a><!-- doxytag: member="gsn_persistent_timer.h::GsnPersistTmr_Restore" ref="ga21c2beb3a3544b189800c56051ca9b6f" args="(VOID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC VOID GsnPersistTmr_Restore </td>
          <td>(</td>
          <td class="paramtype">VOID&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Persistent timer restore. </p>
<p>Loads the Persistent timer details from the NVDS and NVRAM to the SRAM in <a class="el" href="a00229.html" title="GSN Soft timer structure. Timer structure to store the context of the soft timer.">GSN_SOFT_TMR_T</a> format. And calls callback function of the expired persistent timers. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This calls the callback function of the expired timer and starts the timer. </dd></dl>

</div>
</div>
<a class="anchor" id="ga13a97f1941e64cdab5ad524f5d244985"></a><!-- doxytag: member="gsn_persistent_timer.h::GsnPersistTmr_Start" ref="ga13a97f1941e64cdab5ad524f5d244985" args="(UINT32 timerId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC <a class="el" href="a00660.html#gada5951904ac6110b1fa95e51a9ddc217">GSN_STATUS</a> GsnPersistTmr_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a>&#160;</td>
          <td class="paramname"><em>timerId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start the Persistent Timer. </p>
<p>This function starts a persistent timer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timerId</td><td>- IN ID of the timer to create. It should be less than the maximum persistenet timer supported i.e. numOfVarTimer + numOfConstTimer<ul>
<li>1 passed in GsnPersistTmr_Init API. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>It is assumed that the input parameter passed is correct. </dd></dl>

</div>
</div>
<a class="anchor" id="ga038419003a0a454c1e3641818a4a8a1b"></a><!-- doxytag: member="gsn_persistent_timer.h::GsnPersistTmr_Stop" ref="ga038419003a0a454c1e3641818a4a8a1b" args="(UINT32 timerId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC <a class="el" href="a00660.html#gada5951904ac6110b1fa95e51a9ddc217">GSN_STATUS</a> GsnPersistTmr_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a>&#160;</td>
          <td class="paramname"><em>timerId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stop the Persistent Timer. </p>
<p>This function stops a persistent timer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timerId</td><td>- IN ID of the timer to create. It should be less than the maximum persistenet timer supported i.e. numOfVarTimer + numOfConstTimer<ul>
<li>1 passed in GsnPersistTmr_Init API. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>It is assumed that the input parameter passed is correct. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9af57957c6755f2cc4c6c3d140c623a2"></a><!-- doxytag: member="gsn_persistent_timer.h::GsnPersistTmr_Store" ref="ga9af57957c6755f2cc4c6c3d140c623a2" args="(VOID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC <a class="el" href="a00660.html#ga1f04022c0a182c51c059438790ea138c">BOOL</a> GsnPersistTmr_Store </td>
          <td>(</td>
          <td class="paramtype">VOID&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Persistent timer Store. </p>
<p>Updates the information that has to be stored in NVRAM section and into the NVDS if there is any change in the NVDS data. It return TRUE if NVDS section has changed. </p>

</div>
</div>
<a class="anchor" id="ga6f5bc2af45625f650fe1de1b30274d4c"></a><!-- doxytag: member="gsn_persistent_timer.h::GsnPersistTmr_SystemTimeAtExpire" ref="ga6f5bc2af45625f650fe1de1b30274d4c" args="(UINT32 timerId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC <a class="el" href="a00660.html#ga28961430434ccabca6862ea93fe9a15b">ULONG64</a> GsnPersistTmr_SystemTimeAtExpire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00660.html#gae1e6edbbc26d6fbc71a90190d0266018">UINT32</a>&#160;</td>
          <td class="paramname"><em>timerId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>System time at expire. Gives the system time at expire for the requested persistent timer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timerId</td><td>- IN ID of the timer. It should be less than the maximum persistenet timer supported i.e. numOfVarTimer + numOfConstTimer passed in GsnPersistTmr_Init API. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">Remaining</td><td>time in timer ticks </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="footer">Generated on Tue May 13 2014 11:12:10 for GEPS 5.1.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
